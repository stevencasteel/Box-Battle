+---------------------------------+
|       B O X  B A T T L E        |
|  Godot Project Source Context   |
+---------------------------------+
Generated on: Sun Aug 24 17:52:46 CDT 2025

=====================================
PROJECT DIRECTORY STRUCTURE:
=====================================
.
├── LICENSE
├── README.md
├── addons
│   └── gut
│       ├── GutScene.gd
│       ├── GutScene.tscn
│       ├── LICENSE.md
│       ├── UserFileViewer.gd
│       ├── UserFileViewer.tscn
│       ├── autofree.gd
│       ├── awaiter.gd
│       ├── cli
│       │   ├── change_project_warnings.gd
│       │   ├── gut_cli.gd
│       │   └── optparse.gd
│       ├── collected_script.gd
│       ├── collected_test.gd
│       ├── comparator.gd
│       ├── compare_result.gd
│       ├── diff_formatter.gd
│       ├── diff_tool.gd
│       ├── double_templates
│       │   ├── function_template.txt
│       │   ├── init_template.txt
│       │   └── script_template.txt
│       ├── double_tools.gd
│       ├── doubler.gd
│       ├── dynamic_gdscript.gd
│       ├── fonts
│       │   ├── AnonymousPro-Bold.ttf
│       │   ├── AnonymousPro-BoldItalic.ttf
│       │   ├── AnonymousPro-Italic.ttf
│       │   ├── AnonymousPro-Regular.ttf
│       │   ├── CourierPrime-Bold.ttf
│       │   ├── CourierPrime-BoldItalic.ttf
│       │   ├── CourierPrime-Italic.ttf
│       │   ├── CourierPrime-Regular.ttf
│       │   ├── LobsterTwo-Bold.ttf
│       │   ├── LobsterTwo-BoldItalic.ttf
│       │   ├── LobsterTwo-Italic.ttf
│       │   ├── LobsterTwo-Regular.ttf
│       │   └── OFL.txt
│       ├── gui
│       │   ├── BottomPanelShortcuts.gd
│       │   ├── BottomPanelShortcuts.tscn
│       │   ├── GutBottomPanel.gd
│       │   ├── GutBottomPanel.tscn
│       │   ├── GutControl.gd
│       │   ├── GutControl.tscn
│       │   ├── GutRunner.gd
│       │   ├── GutRunner.tscn
│       │   ├── GutSceneTheme.tres
│       │   ├── MinGui.tscn
│       │   ├── NormalGui.tscn
│       │   ├── OutputText.gd
│       │   ├── OutputText.tscn
│       │   ├── ResizeHandle.gd
│       │   ├── ResizeHandle.tscn
│       │   ├── ResultsTree.gd
│       │   ├── ResultsTree.tscn
│       │   ├── RunAtCursor.gd
│       │   ├── RunAtCursor.tscn
│       │   ├── RunResults.gd
│       │   ├── RunResults.tscn
│       │   ├── Settings.tscn
│       │   ├── ShortcutButton.gd
│       │   ├── ShortcutButton.tscn
│       │   ├── arrow.png
│       │   ├── editor_globals.gd
│       │   ├── gut_config_gui.gd
│       │   ├── gut_gui.gd
│       │   ├── gut_user_preferences.gd
│       │   ├── panel_controls.gd
│       │   ├── play.png
│       │   ├── run_from_editor.gd
│       │   ├── run_from_editor.tscn
│       │   └── script_text_editor_controls.gd
│       ├── gut.gd
│       ├── gut_cmdln.gd
│       ├── gut_config.gd
│       ├── gut_loader.gd
│       ├── gut_loader_the_scene.tscn
│       ├── gut_plugin.gd
│       ├── gut_to_move.gd
│       ├── gut_vscode_debugger.gd
│       ├── hook_script.gd
│       ├── icon.png
│       ├── images
│       │   ├── Folder.svg
│       │   ├── Script.svg
│       │   ├── green.png
│       │   ├── red.png
│       │   └── yellow.png
│       ├── inner_class_registry.gd
│       ├── input_factory.gd
│       ├── input_sender.gd
│       ├── junit_xml_export.gd
│       ├── lazy_loader.gd
│       ├── logger.gd
│       ├── method_maker.gd
│       ├── one_to_many.gd
│       ├── orphan_counter.gd
│       ├── parameter_factory.gd
│       ├── parameter_handler.gd
│       ├── plugin.cfg
│       ├── printers.gd
│       ├── result_exporter.gd
│       ├── script_parser.gd
│       ├── signal_watcher.gd
│       ├── source_code_pro.fnt
│       ├── spy.gd
│       ├── strutils.gd
│       ├── stub_params.gd
│       ├── stubber.gd
│       ├── summary.gd
│       ├── test.gd
│       ├── test_collector.gd
│       ├── thing_counter.gd
│       ├── utils.gd
│       ├── version_conversion.gd
│       ├── version_numbers.gd
│       └── warnings_manager.gd
├── default_bus_layout.tres
├── docs
│   ├── ARCHITECTURE.txt
│   ├── ARENA_CONCEPTS.txt
│   ├── ASSETS.txt
│   ├── BRAINSTORM.txt
│   ├── BUGS.txt
│   ├── CHANGELOG.txt
│   ├── DEPRECATION.md
│   ├── DESIGN.txt
│   ├── DOCS_PROTOCOL.txt
│   ├── HOW_TO_ADD_AN_EFFECT.md
│   ├── PLAYTESTING.txt
│   ├── ROADMAP.txt
│   ├── TODO.txt
│   ├── all_godot_source_code_no_docs.txt
│   ├── all_script_errors.txt
│   ├── create_all_addons_collector.sh
│   ├── create_all_godot_source_code_txt.command
│   ├── create_all_godot_source_code_txt.sh
│   ├── create_all_godot_source_code_txt_no_docs.command
│   ├── last_commit_command.txt
│   └── sprint_0_audit
│       ├── ADR-002_Communication_Patterns.md
│       ├── ADR.md
│       ├── ADR.mdADR-001_Service_Locator_Pattern.md
│       ├── ARCH-001_Refactoring_Principles.md
│       ├── ARCH-002_Acceptance_Criteria.md
│       ├── EVENT-001_Event_Flow_Map.md
│       ├── FSM-001_Entity_State_Flows.md
│       ├── STYLE-001_GDScript_Style_Guide.md
│       ├── TEST-001_Baseline_Metrics.md
│       ├── TEST-002_Smoke_Tests.md
│       ├── TEST-003_Regression_Checklist.md
│       ├── config_usage.txt
│       ├── event_usage.txt
│       ├── singleton_map.txt
│       └── state_machine_flow.md
├── export_presets.cfg
├── icon.svg
├── materials
│   ├── dissolve_material.tres
│   └── entity_hit_flash_material.tres
├── pico.save
├── progess
│   └── progress_001-1.jpg
├── project.godot
├── shaders
│   ├── entity
│   │   ├── dissolve.gdshader
│   │   ├── red_hit_flash_test.gdshader
│   │   └── red_hit_flash_test.gdshader.save
│   ├── fullscreen
│   ├── includes
│   │   ├── color.gdshaderinc
│   │   ├── common_math.gdshaderinc
│   │   ├── fx_blend.gdshaderinc
│   │   └── noise.gdshaderinc
│   └── ui
├── src
│   ├── api
│   │   ├── combat
│   │   │   ├── damage_info.gd
│   │   │   └── damage_result.gd
│   │   ├── global_preloader.gd
│   │   └── interfaces
│   │       ├── IComponent.gd
│   │       ├── IDamageable.gd
│   │       ├── IFXManager.gd
│   │       ├── IObjectPool.gd
│   │       ├── IPoolable.gd
│   │       └── ISceneController.gd
│   ├── arenas
│   ├── core
│   │   ├── DEPRECATION.md
│   │   ├── README.md
│   │   ├── boot
│   │   │   └── boot_manager.gd
│   │   ├── building
│   │   │   ├── arena_builder.gd
│   │   │   ├── level_build_data.gd
│   │   │   ├── level_parser.gd
│   │   │   └── terrain_builder.gd
│   │   ├── data
│   │   │   ├── config
│   │   │   │   ├── combat_config.gd
│   │   │   │   └── settings.gd
│   │   │   ├── effects
│   │   │   │   ├── boss_death_shake.tres
│   │   │   │   ├── boss_phase_change_shake.tres
│   │   │   │   ├── dissolve_effect.tres
│   │   │   │   ├── player_damage_shake.tres
│   │   │   │   ├── player_hit_spark_effect.tres
│   │   │   │   ├── screen_shake_effect.gd
│   │   │   │   ├── shader_effect.gd
│   │   │   │   └── vfx_effect.gd
│   │   │   └── game_state_data.gd
│   │   ├── events
│   │   │   ├── event_bus.gd
│   │   │   ├── event_catalog.gd
│   │   │   └── typed_events
│   │   │       ├── boss_health_changed_event.gd
│   │   │       ├── player_healing_charges_changed_event.gd
│   │   │       └── player_health_changed_event.gd
│   │   ├── sequencing
│   │   │   ├── sequence_handle.gd
│   │   │   ├── sequence_step.gd
│   │   │   ├── sequencer.gd
│   │   │   └── steps
│   │   │       ├── callable_step.gd
│   │   │       ├── emit_step.gd
│   │   │       └── wait_step.gd
│   │   ├── systems
│   │   │   ├── audio_manager.gd
│   │   │   ├── camera_manager.gd
│   │   │   ├── camera_shaker.gd
│   │   │   ├── camera_shaker.tscn
│   │   │   ├── cursor_manager.gd
│   │   │   ├── dialogue_manager.gd
│   │   │   ├── fx_bindings
│   │   │   │   └── fx_manager_adapter.gd
│   │   │   ├── fx_manager.gd
│   │   │   ├── game_manager.gd
│   │   │   ├── object_pool.gd
│   │   │   ├── pool_bindings
│   │   │   │   └── object_pool_adapter.gd
│   │   │   └── scene_manager.gd
│   │   └── util
│   │       ├── asset_paths.gd
│   │       ├── combat_utils.gd
│   │       ├── constants.gd
│   │       ├── dependency_validator.gd
│   │       ├── grid_utils.gd
│   │       ├── identifiers.gd
│   │       ├── palette.gd
│   │       ├── physics_layers.gd
│   │       ├── scene_validator.gd
│   │       └── service_locator.gd
│   ├── data
│   │   ├── audio
│   │   │   ├── sfx_player_footsteps.tres
│   │   │   └── sfx_player_impact.tres
│   │   ├── combat_config.tres
│   │   ├── dialogue
│   │   │   ├── dialogue_data.gd
│   │   │   ├── dialogue_line.gd
│   │   │   └── test_conversation.tres
│   │   ├── effects
│   │   │   └── entity_hit_flash_effect.tres
│   │   ├── encounters
│   │   │   ├── encounter_00.tres
│   │   │   └── encounter_data.gd
│   │   └── layouts
│   │       ├── layout_00.tres
│   │       └── level_layout.gd
│   ├── entities
│   │   ├── README.md
│   │   ├── archetypes
│   │   │   ├── boss_archetype.tres
│   │   │   ├── entity_archetype.gd
│   │   │   ├── minion_archetype.tres
│   │   │   └── player_archetype.tres
│   │   ├── base_entity.gd
│   │   ├── boss
│   │   │   ├── attack_patterns
│   │   │   │   ├── attack_logic.gd
│   │   │   │   ├── attack_pattern.gd
│   │   │   │   ├── homing_omni_burst_logic.gd
│   │   │   │   ├── homing_omni_burst_logic.tres
│   │   │   │   ├── homing_omni_burst_pattern.tres
│   │   │   │   ├── lunge_attack.tres
│   │   │   │   ├── lunge_logic.gd
│   │   │   │   ├── lunge_logic.tres
│   │   │   │   ├── projectile_logic.gd
│   │   │   │   ├── single_shot.tres
│   │   │   │   ├── single_shot_logic.tres
│   │   │   │   ├── volley_3_shot.tres
│   │   │   │   ├── volley_5_shot.tres
│   │   │   │   └── volley_shot_logic.tres
│   │   │   ├── base_boss.gd
│   │   │   ├── base_boss.tscn
│   │   │   ├── boss_state_data.gd
│   │   │   ├── data
│   │   │   │   ├── boss_behavior.gd
│   │   │   │   └── default_boss_behavior.tres
│   │   │   └── states
│   │   │       ├── state_boss_attack.gd
│   │   │       ├── state_boss_cooldown.gd
│   │   │       ├── state_boss_idle.gd
│   │   │       ├── state_boss_lunge.gd
│   │   │       └── state_boss_patrol.gd
│   │   ├── components
│   │   │   ├── base_state.gd
│   │   │   ├── base_state_machine.gd
│   │   │   ├── base_state_machine.tscn
│   │   │   ├── combat_component.gd
│   │   │   ├── combat_component.tscn
│   │   │   ├── fx_component.gd
│   │   │   ├── fx_component.tscn
│   │   │   ├── health_component.gd
│   │   │   ├── health_component.tscn
│   │   │   ├── input_component.gd
│   │   │   ├── input_component.tscn
│   │   │   ├── telegraph_component.gd
│   │   │   └── telegraph_component.tscn
│   │   ├── minions
│   │   │   ├── data
│   │   │   │   ├── minion_behavior.gd
│   │   │   │   └── turret_behavior.tres
│   │   │   ├── minion.gd
│   │   │   ├── minion.tscn
│   │   │   ├── minion_state_data.gd
│   │   │   ├── movement_logic
│   │   │   │   ├── movement_logic.gd
│   │   │   │   ├── patrol_movement.tres
│   │   │   │   ├── patrol_movement_logic.gd
│   │   │   │   ├── stationary_movement.tres
│   │   │   │   └── stationary_movement_logic.gd
│   │   │   └── states
│   │   │       ├── state_minion_attack.gd
│   │   │       └── state_minion_idle.gd
│   │   └── player
│   │       ├── components
│   │       │   ├── player_ability_component.gd
│   │       │   ├── player_ability_component.tscn
│   │       │   ├── player_jump_helper.gd
│   │       │   ├── player_physics_component.gd
│   │       │   ├── player_physics_component.tscn
│   │       │   ├── player_resource_component.gd
│   │       │   └── player_resource_component.tscn
│   │       ├── data
│   │       │   ├── forward_attack_shape.tres
│   │       │   ├── player_state_data.gd
│   │       │   └── upward_attack_shape.tres
│   │       ├── player.gd
│   │       ├── player.tscn
│   │       └── states
│   │           ├── state_attack.gd
│   │           ├── state_dash.gd
│   │           ├── state_fall.gd
│   │           ├── state_heal.gd
│   │           ├── state_hurt.gd
│   │           ├── state_jump.gd
│   │           ├── state_move.gd
│   │           ├── state_pogo.gd
│   │           └── state_wall_slide.gd
│   ├── projectiles
│   │   ├── base_projectile.gd
│   │   ├── boss_shot.gd
│   │   ├── boss_shot.tscn
│   │   ├── homing_boss_shot.gd
│   │   ├── homing_boss_shot.tscn
│   │   ├── player_shot.gd
│   │   ├── player_shot.tscn
│   │   ├── turret_shot.gd
│   │   └── turret_shot.tscn
│   ├── scenes
│   │   ├── game
│   │   │   ├── encounter_scene.gd
│   │   │   └── encounter_scene.tscn
│   │   ├── game_over
│   │   │   ├── game_over_screen.gd
│   │   │   └── game_over_screen.tscn
│   │   ├── loading
│   │   │   ├── loading_screen.gd
│   │   │   └── loading_screen.tscn
│   │   ├── main
│   │   │   ├── main.gd
│   │   │   └── main.tscn
│   │   ├── menus
│   │   │   ├── controls_screen.gd
│   │   │   ├── controls_screen.tscn
│   │   │   ├── credits_screen.gd
│   │   │   ├── credits_screen.tscn
│   │   │   ├── options_screen.gd
│   │   │   ├── options_screen.tscn
│   │   │   ├── sound_screen.gd
│   │   │   ├── sound_screen.tscn
│   │   │   ├── title_screen.gd
│   │   │   └── title_screen.tscn
│   │   └── victory
│   │       ├── victory_screen.gd
│   │       └── victory_screen.tscn
│   ├── tests
│   │   ├── fakes
│   │   │   ├── fake_damageable.gd
│   │   │   ├── fake_event_bus.gd
│   │   │   └── fake_service_locator.gd
│   │   ├── integration
│   │   ├── isolation
│   │   └── unit
│   │       ├── test_combat_utils.gd
│   │       ├── test_health_component.gd
│   │       ├── test_idamageable_contract.gd
│   │       ├── test_input_component.gd
│   │       └── test_player_resource_component.gd
│   ├── ui
│   │   ├── components
│   │   │   ├── control_setting_row
│   │   │   │   ├── control_setting_row.gd
│   │   │   │   └── control_setting_row.tscn
│   │   │   ├── custom_slider
│   │   │   │   ├── custom_slider.gd
│   │   │   │   └── custom_slider.tscn
│   │   │   ├── logo_display
│   │   │   │   ├── logo_display.gd
│   │   │   │   └── logo_display.tscn
│   │   │   ├── mute_button
│   │   │   │   ├── mute_button.gd
│   │   │   │   └── mute_button.tscn
│   │   │   ├── sound_setting_row
│   │   │   │   ├── sound_setting_row.gd
│   │   │   │   └── sound_setting_row.tscn
│   │   │   └── styled_menu_item
│   │   │       ├── styled_menu_item.gd
│   │   │       └── styled_menu_item.tscn
│   │   ├── dev
│   │   │   ├── debug_overlay.gd
│   │   │   └── debug_overlay.tscn
│   │   ├── dialogue
│   │   │   ├── dialogue_box.gd
│   │   │   └── dialogue_box.tscn
│   │   ├── game_hud
│   │   │   ├── game_hud.gd
│   │   │   └── game_hud.tscn
│   │   └── menu_manager
│   │       └── menu_manager.gd
│   └── vfx
│       ├── hit_spark.gd
│       └── hit_spark.tscn
└── tools
    ├── fx_playground.gd
    ├── fx_playground.tscn
    └── mock_entity.gd

84 directories, 373 files


=====================================
FILE: ./.gutconfig.json
=====================================
{
    "dirs": [
        "res://src/tests"
    ],
    "include_subdirs": true
}

=====================================
FILE: ./tools/fx_playground.tscn
=====================================
[gd_scene load_steps=5 format=3 uid="uid://qfvxrbic3utx"]

[ext_resource type="Script" uid="uid://chl2ii0j6x47a" path="res://tools/fx_playground.gd" id="1_script"]
[ext_resource type="Resource" path="res://src/data/effects/entity_hit_flash_effect.tres" id="2_effect"]
[ext_resource type="PackedScene" uid="uid://g7h8jaj0k1l2" path="res://src/entities/components/fx_component.tscn" id="3_fx_component"]
[ext_resource type="Resource" uid="uid://bps1fb52qcel8" path="res://src/core/data/effects/dissolve_effect.tres" id="4_dissolve_effect"]

[node name="FXPlayground" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_script")
_hit_flash_effect = ExtResource("2_effect")
_dissolve_effect = ExtResource("4_dissolve_effect")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0.1, 0.1, 0.1, 1)

[node name="CenterContainer" type="CenterContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="TestSubject" type="ColorRect" parent="CenterContainer"]
unique_name_in_owner = true
custom_minimum_size = Vector2(200, 200)
layout_mode = 2
color = Color(0.8, 0.8, 0.8, 1)

[node name="FXComponent" parent="CenterContainer/TestSubject" instance=ExtResource("3_fx_component")]

[node name="ButtonGrid" type="GridContainer" parent="."]
layout_mode = 1
anchors_preset = 7
anchor_left = 0.5
anchor_top = 1.0
anchor_right = 0.5
anchor_bottom = 1.0
offset_left = -225.0
offset_top = -125.0
offset_right = 225.0
offset_bottom = -25.0
grow_horizontal = 2
grow_vertical = 0
columns = 2

[node name="ButtonRed" type="Button" parent="ButtonGrid"]
custom_minimum_size = Vector2(200, 40)
layout_mode = 2
text = "Play Hit-Flash (Red)"

[node name="ButtonBlue" type="Button" parent="ButtonGrid"]
custom_minimum_size = Vector2(200, 40)
layout_mode = 2
text = "Play Hit-Flash (Blue)"

[node name="ButtonDissolve" type="Button" parent="ButtonGrid"]
custom_minimum_size = Vector2(200, 40)
layout_mode = 2
text = "Play Dissolve"

[node name="ButtonPlaceholder" type="Button" parent="ButtonGrid"]
custom_minimum_size = Vector2(200, 40)
layout_mode = 2
disabled = true
text = "(Future Effect)"

[connection signal="pressed" from="ButtonGrid/ButtonRed" to="." method="_on_button_red_pressed"]
[connection signal="pressed" from="ButtonGrid/ButtonBlue" to="." method="_on_button_blue_pressed"]
[connection signal="pressed" from="ButtonGrid/ButtonDissolve" to="." method="_on_button_dissolve_pressed"]


=====================================
FILE: ./tools/mock_entity.gd
=====================================
# tools/mock_entity.gd
## A mock entity for testing components in isolation, particularly for use with
## the DebugOverlay or in unit tests. It provides the properties that various
## systems expect an entity to have, without the overhead of a full scene.
class_name MockEntity
extends Node

# --- Private Member Variables ---
var fx_component: FXComponent
var state_machine: BaseStateMachine
var health_component: HealthComponent


# --- Public Methods ---

## Instantiates and holds component nodes for testing.
func initialize_components() -> void:
	health_component = HealthComponent.new()
	add_child(health_component)
	fx_component = FXComponent.new()
	add_child(fx_component)
	state_machine = BaseStateMachine.new()
	add_child(state_machine)


## Mimics the real BaseEntity's get_component method for test compatibility.
func get_component(type: Script) -> IComponent:
	if type == HealthComponent:
		return health_component
	if type == FXComponent:
		return fx_component
	if type == BaseStateMachine:
		return state_machine
	return null


# Mimic CharacterBody2D methods for the overlay's checks to prevent errors.
func is_on_floor() -> bool:
	return true

=====================================
FILE: ./tools/fx_playground.gd
=====================================
# tools/fx_playground.gd
@tool
extends Control

@export var _hit_flash_effect: ShaderEffect
@export var _dissolve_effect: ShaderEffect

@onready var test_subject: ColorRect = %TestSubject
@onready var fx_component: FXComponent = %TestSubject/FXComponent


func _ready() -> void:
	if not Engine.is_editor_hint():
		# THE FIX: When running the scene, the ServiceLocator autoload is
		# available globally. We must provide it to the component's setup
		# method to satisfy its dependency contract.
		var dependencies = {
			"visual_node": test_subject,
			"services": ServiceLocator,
			"hit_effect": _hit_flash_effect # Provide a default hit effect
		}
		fx_component.setup(test_subject, dependencies)
		test_subject.visible = true


func _on_button_red_pressed() -> void:
	if not is_instance_valid(_hit_flash_effect):
		print("ERROR: No Hit Flash ShaderEffect resource assigned.")
		return
	test_subject.visible = true
	fx_component.play_effect(_hit_flash_effect)


func _on_button_blue_pressed() -> void:
	if not is_instance_valid(_hit_flash_effect):
		print("ERROR: No Hit Flash ShaderEffect resource assigned.")
		return

	test_subject.visible = true
	var overrides = {"tint_color": Color.BLUE}
	fx_component.play_effect(_hit_flash_effect, overrides)


func _on_button_dissolve_pressed() -> void:
	if not is_instance_valid(_dissolve_effect):
		print("ERROR: No Dissolve ShaderEffect resource assigned.")
		return

	test_subject.visible = true
	if test_subject.material:
		test_subject.material = null

	var effect_tween: Tween = fx_component.play_effect(_dissolve_effect)
	if is_instance_valid(effect_tween):
		await effect_tween.finished
		# After dissolving, make the subject invisible but still present.
		test_subject.visible = false


=====================================
FILE: ./materials/dissolve_material.tres
=====================================
[gd_resource type="ShaderMaterial" load_steps=3 format=3 uid="uid://bkiertsatpb34"]

[ext_resource type="Shader" uid="uid://bjx4w0wd5cbl" path="res://shaders/entity/dissolve.gdshader" id="1_shader"]
[ext_resource type="Texture2D" uid="uid://07p7ttqtioqu" path="res://assets/textures/noise_texture.tres" id="2_noise"]

[resource]
shader = ExtResource("1_shader")
shader_parameter/noise_texture = ExtResource("2_noise")
shader_parameter/fx_progress = 0.0
shader_parameter/border_color = Color(1, 1, 1, 1)
shader_parameter/border_width = 0.02


=====================================
FILE: ./materials/entity_hit_flash_material.tres
=====================================
[gd_resource type="ShaderMaterial" load_steps=2 format=3 uid="uid://entity_hit_flash_mat"]

[ext_resource type="Shader" path="res://shaders/entity/red_hit_flash_test.gdshader" id="1_shader"]

[resource]
shader = ExtResource("1_shader")
shader_parameter/fx_progress = 0.0
shader_parameter/tint_color = Color(1, 0, 0, 1)

=====================================
FILE: ./README.md
=====================================
# BOX BATTLE

```
██████╗  ██████╗ ██╗  ██╗    ██████╗  █████╗ ████████╗████████╗██╗     ███████╗
██╔══██╗██╔═══██╗╗██╗██╔╝    ██╔══██╗██╔══██╗╚══██╔══╝╚══██╔══╝██║     ██╔════╝
██████╔╝██║   ██║╚███╔╝      ██████╔╝███████║   ██║      ██║   ██║     █████╗  
██╔══██╗██║   ██║██╔██╗      ██╔══██╗██╔══██║   ██║      ██║   ██║     ██╔══╝  
██████╔╝╚██████╔╝██╔╝ ██╗    ██████╔╝██║  ██║   ██║      ██║   ███████╗███████╗
╚═════╝  ╚═════╝ ╚═╝  ╚═╝    ╚═════╝ ╚═╝  ╚═╝   ╚═╝      ╚═╝   ╚══════╝╚══════╝
```


A combat-focused 2D action game built in Godot 4. This repo contains the engine, gameplay systems, and tools used to produce a modular, maintainable boss-arena prototype.

**Current Status:** Architecturally stable. The codebase has been fully refactored to use a modular, component-based entity system, a standardized code style, and data-driven design patterns.

---

## Architectural Highlights
- **Component-Based Entities:** The Player and Boss are lean orchestrators for single-responsibility components (`HealthComponent`, `PlayerPhysicsComponent`, `IComponent` interface).
- **State Pattern:** Complex entity logic is encapsulated in discrete state classes (`BaseState`, `BaseStateMachine`).
- **Data-Driven Design:** All gameplay tuning is managed in `Resource` files (`.tres`) for easy balancing.
- **Robust Core Systems:** A suite of decoupled singletons manage global services (`EventBus`, `SceneManager`, `ObjectPool`, `AudioManager`).
- **Performance:** Stutter is minimized via asynchronous level building, object pooling, and enhanced shader pre-warming.

---

## Quick Start
1.  Install Godot 4.x.
2.  Clone the repository.
3.  Open the project in Godot and run `res://src/scenes/main/main.tscn`.

**Controls (default)**
-   Move: Arrow Keys / WASD
-   Jump / Confirm: X / Space / Enter
-   Attack / Pogo: C / Left-Click
-   Dash: Z / Shift
-   Heal: Down + Jump (on ground)

---

## Repository Layout

src/
├── api/ # "Interface" contracts (IComponent, IDamageable)
├── core/ # Autoloaded singletons and core infrastructure
├── data/ # Data resources (.tres files for encounters, layouts)
├── entities/ # Player, Boss, Minions, and their components/states
├── scenes/ # Main scenes (game, loading, menus)
├── ui/ # UI components, HUD, and menu controllers
└── ...
docs/ # High-level design, architecture, and style guide


---

## Key Documentation
-   `docs/ARCHITECTURE.txt`: A high-level summary of all key technical patterns.
-   `docs/sprint_0_audit/STYLE-001_GDScript_Style_Guide.md`: The official coding standard for the project.
-   `docs/DESIGN.txt`: The design philosophy and breakdown of core gameplay mechanics.
-   `docs/CHANGELOG.txt`: A log of all notable changes to the project.

=====================================
FILE: ./default_bus_layout.tres
=====================================
[gd_resource type="AudioBusLayout" format=3 uid="uid://c65ja7dwrkbrc"]

[resource]
bus/1/name = &"Music"
bus/1/solo = false
bus/1/mute = false
bus/1/bypass_fx = false
bus/1/volume_db = 0.0
bus/1/send = &"Master"
bus/2/name = &"SFX"
bus/2/solo = false
bus/2/mute = false
bus/2/bypass_fx = false
bus/2/volume_db = 0.0
bus/2/send = &"Master"

=====================================
FILE: ./.github/scripts/get_version.gd
=====================================
# .github/scripts/get_version.gd
# This script runs in the CI environment to get the version
# from project.godot and print it to the command line.
extends SceneTree


func _init():
	var version = ProjectSettings.get_setting("application/config/version")
	print(version)
	quit()


=====================================
FILE: ./.github/scripts/lint_shaders.gd
=====================================
# .github/scripts/lint_shaders.gd
## A command-line script to lint all .gdshader files in the project.
## It enforces project-specific best practices for shader development.
extends SceneTree

var _shader_files: Array[String] = []
var _error_count: int = 0


func _init() -> void:
	print("--- Running Shader Linter ---")
	_find_all_shaders("res://")
	_lint_files()

	if _error_count > 0:
		print("\nLinter FAILED: Found %d error(s)." % _error_count)
		quit(1)
	else:
		print("\nLinter PASSED: All shader files are compliant.")
		quit(0)


## Recursively finds all .gdshader files in the project.
func _find_all_shaders(path: String) -> void:
	var dir = DirAccess.open(path)
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			var full_path = path.path_join(file_name)
			if dir.current_is_dir() and file_name != "." and file_name != "..":
				_find_all_shaders(full_path)
			elif file_name.ends_with(".gdshader"):
				_shader_files.append(full_path)
			file_name = dir.get_next()


## Iterates through found shader files and applies linting rules.
func _lint_files() -> void:
	for file_path in _shader_files:
		var file = FileAccess.open(file_path, FileAccess.READ)
		if not is_instance_valid(file):
			_report_error(file_path, -1, "Could not open file.")
			continue

		var content = file.get_as_text()
		var lines = content.split("\n")

		_check_shader_type_present(file_path, content)
		_check_source_color_hints(file_path, lines)


## Linter Rule 1: Ensure 'shader_type' is declared.
func _check_shader_type_present(file_path: String, content: String) -> void:
	if not content.contains("shader_type"):
		_report_error(file_path, 1, "Missing required 'shader_type' declaration.")


## Linter Rule 2: Ensure color uniforms have ': source_color'.
func _check_source_color_hints(file_path: String, lines: Array[String]) -> void:
	for i in range(lines.size()):
		var line = lines[i].strip_edges()
		if line.begins_with("uniform vec4") and "color" in line.to_lower():
			if not line.contains(": source_color"):
				_report_error(
					file_path,
					i + 1,
					"Color uniform is missing ': source_color' hint. Line: '%s'" % line
				)


## Reports a formatted error message to the console.
func _report_error(file_path: String, line_num: int, message: String) -> void:
	_error_count += 1
	var line_str = "L%d" % line_num if line_num > 0 else "FILE"
	print("ERROR: %s:%s - %s" % [file_path, line_str, message])


=====================================
FILE: ./shaders/entity/dissolve.gdshader
=====================================
// shaders/entity/dissolve.gdshader
shader_type canvas_item;

uniform sampler2D noise_texture;
uniform float fx_progress : hint_range(0.0, 1.0);
uniform vec4 border_color : source_color = vec4(1.0, 1.0, 1.0, 1.0);
uniform float border_width : hint_range(0.0, 0.1) = 0.02;

void fragment() {
	vec4 original_color = COLOR;
	// THE FIX: Sample the noise texture using screen-space UVs, which are
	// always available, instead of local UVs, which Polygon2D does not have.
	float noise_value = texture(noise_texture, SCREEN_UV).r;

	if (noise_value < fx_progress) {
		discard;
	} else if (noise_value < fx_progress + border_width) {
		COLOR = border_color;
	} else {
		COLOR = original_color;
	}
}

=====================================
FILE: ./shaders/entity/red_hit_flash_test.gdshader
=====================================
// shaders/entity/red_hit_flash_test.gdshader
shader_type canvas_item;

uniform vec4 tint_color : source_color = vec4(1.0, 0.0, 0.0, 1.0);
// The effect's progress, from 0.0 (start) to 1.0 (end).
uniform float fx_progress : hint_range(0.0, 1.0);

void fragment() {
    // Get the base color from the ColorRect
    vec4 original_color = COLOR;
    
    // As fx_progress goes from 0 to 1, intensity goes from 1 to 0.
    float intensity = 1.0 - fx_progress;
    
    // Mix the original color with the tint color
    vec3 mixed_rgb = mix(original_color.rgb, tint_color.rgb, intensity);
    
    // Apply the mixed color, preserving the original alpha
    COLOR = vec4(mixed_rgb, original_color.a);
}

=====================================
FILE: ./project.godot
=====================================
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="BOX BATTLE"
config/version="0.14.0"
run/main_scene="res://src/scenes/main/main.tscn"
config/features=PackedStringArray("4.4", "Mobile")
config/icon="res://icon.svg"

[autoload]

GameManager="*res://src/core/systems/game_manager.gd"
SceneManager="*res://src/core/systems/scene_manager.gd"
AudioManager="*res://src/core/systems/audio_manager.gd"
FXManager="*res://src/core/systems/fx_manager.gd"
CameraManager="*res://src/core/systems/camera_manager.gd"
CursorManager="*res://src/core/systems/cursor_manager.gd"
DialogueManager="*res://src/core/systems/dialogue_manager.gd"
ObjectPool="*res://src/core/systems/object_pool.gd"
EventBus="*res://src/core/events/event_bus.gd"
Sequencer="*res://src/core/sequencing/sequencer.gd"
ArenaBuilder="*res://src/core/building/arena_builder.gd"
Settings="*res://src/core/data/config/settings.gd"
GlobalPreloader="*res://src/api/global_preloader.gd"
ServiceLocator="*res://src/core/util/service_locator.gd"
AssetPaths="*res://src/core/util/asset_paths.gd"
Constants="*res://src/core/util/constants.gd"
GridUtils="*res://src/core/util/grid_utils.gd"
CombatUtils="*res://src/core/util/combat_utils.gd"
Identifiers="*res://src/core/util/identifiers.gd"
Palette="*res://src/core/util/palette.gd"
PhysicsLayers="*res://src/core/util/physics_layers.gd"
FXManagerAdapter="*res://src/core/systems/fx_bindings/fx_manager_adapter.gd"
ObjectPoolAdapter="*res://src/core/systems/pool_bindings/object_pool_adapter.gd"

[display]

window/size/viewport_width=1800
window/size/viewport_height=1000
window/stretch/mode="canvas_items"

[editor_plugins]

enabled=PackedStringArray("res://addons/gut/plugin.cfg")

[input]

ui_left={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194319,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
]
}
ui_right={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194321,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
]
}
ui_up={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194320,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
]
}
ui_down={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":4194322,"physical_keycode":0,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
]
}
ui_jump={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":32,"physical_keycode":32,"key_label":0,"unicode":32,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":88,"physical_keycode":88,"key_label":0,"unicode":120,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":46,"physical_keycode":46,"key_label":0,"unicode":46,"location":0,"echo":false,"script":null)
]
}
ui_attack={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":67,"physical_keycode":67,"key_label":0,"unicode":99,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":44,"physical_keycode":44,"key_label":0,"unicode":44,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":true,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":16777218,"physical_keycode":16777218,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":2,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}
ui_dash={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":90,"physical_keycode":90,"key_label":0,"unicode":122,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":47,"physical_keycode":47,"key_label":0,"unicode":47,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":true,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":16777217,"physical_keycode":16777217,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventMouseButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"button_mask":0,"position":Vector2(0, 0),"global_position":Vector2(0, 0),"factor":1.0,"button_index":3,"canceled":false,"pressed":false,"double_click":false,"script":null)
]
}
debug_toggle_overlay={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":89,"key_label":0,"unicode":121,"location":0,"echo":false,"script":null)
]
}
debug_cycle_target={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":85,"key_label":0,"unicode":117,"location":0,"echo":false,"script":null)
]
}
debug_dialogue={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":0,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":73,"key_label":0,"unicode":105,"location":0,"echo":false,"script":null)
]
}

[layer_names]

2d_physics/layer_1="player"
2d_physics/layer_2="platforms"
2d_physics/layer_3="enemy"
2d_physics/layer_4="hazard"
2d_physics/layer_5="enemy_projectile"
2d_physics/layer_6="player_hitbox"
2d_physics/layer_7="player_hurtbox"
2d_physics/layer_8="solid_world"

[rendering]

renderer/rendering_method="mobile"
textures/vram_compression/import_etc2_astc=true
environment/defaults/default_clear_color=Color(0, 0, 0, 1)

[shader_globals]

fx_global_time={
"type": "float",
"value": 0.0
}
vignette_intensity={
"type": "float",
"value": 0.0
}
desat_amount={
"type": "float",
"value": 0.0
}
pal_index={
"type": "int",
"value": 0
}


=====================================
FILE: ./.vscode/settings.json
=====================================
{
    "godotTools.editorPath.godot4": "/Applications/Godot.app"
}

=====================================
FILE: ./src/ui/game_hud/game_hud.gd
=====================================
# src/ui/game_hud/game_hud.gd
## Manages the in-game heads-up display.
##
## Subscribes to [EventBus] events to keep the player health, boss health,
## and phase indicators updated in real-time.
extends CanvasLayer

# --- Constants ---
const COMBAT_CONFIG = preload("res://src/data/combat_config.tres")

# --- Node References ---
@onready var player_health_value: Label = $PlayerInfo/PlayerHealthHBox/PlayerHealthValue
@onready
var player_heal_charges_value: Label = $PlayerInfo/PlayerHealChargesHBox/PlayerHealChargesValue
@onready var boss_health_bar: ProgressBar = $BossHealthBar
@onready var phase_indicators: HBoxContainer = $PhaseIndicators

# --- Private Member Variables ---
var _phase_squares: Array[Panel] = []
var _total_phases: int = 3
var _player_health_token: int
var _player_charges_token: int
var _boss_health_token: int
var _boss_phase_token: int
var _boss_died_token: int
var _filled_style: StyleBoxFlat
var _empty_style: StyleBoxFlat

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	_subscribe_to_events()
	_create_styles()
	_initialize_ui_state()


func _exit_tree() -> void:
	_unsubscribe_from_events()


# --- Private Methods ---


func _subscribe_to_events() -> void:
	_player_health_token = EventBus.on(EventCatalog.PLAYER_HEALTH_CHANGED, on_player_health_changed)
	_player_charges_token = EventBus.on(
		EventCatalog.PLAYER_HEALING_CHARGES_CHANGED, on_player_healing_charges_changed
	)
	_boss_health_token = EventBus.on(EventCatalog.BOSS_HEALTH_CHANGED, on_boss_health_changed)
	_boss_phase_token = EventBus.on(EventCatalog.BOSS_PHASE_CHANGED, on_boss_phase_changed)
	_boss_died_token = EventBus.on(EventCatalog.BOSS_DIED, on_boss_died)


func _unsubscribe_from_events() -> void:
	EventBus.off(_player_health_token)
	EventBus.off(_player_charges_token)
	EventBus.off(_boss_health_token)
	EventBus.off(_boss_phase_token)
	EventBus.off(_boss_died_token)


func _initialize_ui_state() -> void:
	var max_health = COMBAT_CONFIG.player_max_health
	player_health_value.text = "%d / %d" % [max_health, max_health]
	player_heal_charges_value.text = "0"

	var health_bar_style = boss_health_bar.get_theme_stylebox("fill").duplicate()
	health_bar_style.bg_color = Palette.COLOR_PLAYER_PROJECTILE
	boss_health_bar.add_theme_stylebox_override("fill", health_bar_style)

	boss_health_bar.max_value = COMBAT_CONFIG.boss_health
	boss_health_bar.value = boss_health_bar.max_value

	phase_indicators.add_theme_constant_override("separation", 5)
	_create_phase_indicators()


func _create_styles() -> void:
	_filled_style = StyleBoxFlat.new()
	_filled_style.bg_color = Palette.COLOR_HAZARD_PRIMARY
	_filled_style.border_width_bottom = 3
	_filled_style.border_width_left = 3
	_filled_style.border_width_right = 3
	_filled_style.border_width_top = 3
	_filled_style.border_color = Palette.COLOR_UI_ACCENT_PRIMARY

	_empty_style = _filled_style.duplicate()
	_empty_style.bg_color = Palette.COLOR_BACKGROUND


func _create_phase_indicators() -> void:
	for i in range(_total_phases):
		var panel = Panel.new()
		panel.custom_minimum_size = Vector2(40, 40)
		phase_indicators.add_child(panel)
		_phase_squares.append(panel)
	_update_phase_visuals(_total_phases)


func _update_phase_visuals(phases_remaining: int) -> void:
	for i in range(_phase_squares.size()):
		var square = _phase_squares[i]
		if i < phases_remaining:
			square.add_theme_stylebox_override("panel", _filled_style)
		else:
			square.add_theme_stylebox_override("panel", _empty_style)


# --- EventBus Callbacks ---


func on_player_health_changed(payload: PlayerHealthChangedEvent) -> void:
	player_health_value.text = str(payload.current_health) + " / " + str(payload.max_health)


func on_player_healing_charges_changed(payload: PlayerHealingChargesChangedEvent) -> void:
	player_heal_charges_value.text = str(payload.current_charges)


func on_boss_health_changed(payload: BossHealthChangedEvent) -> void:
	boss_health_bar.max_value = payload.max_health
	boss_health_bar.value = payload.current_health


func on_boss_phase_changed(payload: Dictionary) -> void:
	var phases_remaining = payload.get("phases_remaining", 1)
	_update_phase_visuals(phases_remaining)


func on_boss_died(_payload) -> void:
	_update_phase_visuals(0)


=====================================
FILE: ./src/ui/game_hud/game_hud.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://c1qkhw0snj226"]

[ext_resource type="Script" path="res://src/ui/game_hud/game_hud.gd" id="1_3f8wa"]

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_1"]
bg_color = Color(0.262745, 0.262745, 0.262745, 1)

[sub_resource type="StyleBoxFlat" id="StyleBoxFlat_2"]
bg_color = Color(0.92549, 0.92549, 0.92549, 1)

[node name="GameHUD" type="CanvasLayer"]
script = ExtResource("1_3f8wa")

[node name="PlayerInfo" type="VBoxContainer" parent="."]
anchors_preset = 2
anchor_top = 1.0
anchor_bottom = 1.0
offset_left = 20.0
offset_top = -100.0
offset_right = 220.0
offset_bottom = -20.0
grow_vertical = 0

[node name="PlayerHealthHBox" type="HBoxContainer" parent="PlayerInfo"]
layout_mode = 2

[node name="PlayerHealthLabel" type="Label" parent="PlayerInfo/PlayerHealthHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Health:"

[node name="PlayerHealthValue" type="Label" parent="PlayerInfo/PlayerHealthHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "5 / 5"

[node name="PlayerHealChargesHBox" type="HBoxContainer" parent="PlayerInfo"]
layout_mode = 2

[node name="PlayerHealChargesLabel" type="Label" parent="PlayerInfo/PlayerHealChargesHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "Heal Charges:"

[node name="PlayerHealChargesValue" type="Label" parent="PlayerInfo/PlayerHealChargesHBox"]
layout_mode = 2
theme_override_font_sizes/font_size = 24
text = "0"

[node name="BossHealthBar" type="ProgressBar" parent="."]
anchors_preset = 10
anchor_right = 1.0
offset_left = 250.0
offset_top = 20.0
offset_right = -250.0
offset_bottom = 50.0
grow_horizontal = 2
theme_override_styles/background = SubResource("StyleBoxFlat_1")
theme_override_styles/fill = SubResource("StyleBoxFlat_2")
max_value = 30.0
step = 1.0
value = 30.0
show_percentage = false

[node name="PhaseIndicators" type="HBoxContainer" parent="."]
anchors_preset = 1
anchor_left = 1.0
anchor_right = 1.0
offset_left = -220.0
offset_top = 20.0
offset_right = -20.0
offset_bottom = 60.0
grow_horizontal = 0
alignment = 2

=====================================
FILE: ./src/ui/menu_manager/menu_manager.gd
=====================================
# src/ui/menu_manager/menu_manager.gd
## A helper node that manages keyboard navigation and cursor display for a menu.
##
## This is intended to be instanced by a menu scene at runtime. It handles
## focus changes and draws selection cursors next to the focused item.
extends Node

# --- Signals ---
## Emitted when the selection changes via keyboard input.
signal selection_changed

# --- Member Variables ---
var menu_items: Array[Control] = []
var current_selection_index: int = 0

var _cursor_left: ColorRect
var _cursor_right: ColorRect

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	_cursor_left = ColorRect.new()
	_cursor_left.size = Vector2(20, 20)
	_cursor_left.color = Palette.COLOR_UI_ACCENT_PRIMARY
	_cursor_left.visible = false
	add_child(_cursor_left)

	_cursor_right = ColorRect.new()
	_cursor_right.size = Vector2(20, 20)
	_cursor_right.color = Palette.COLOR_UI_ACCENT_PRIMARY
	_cursor_right.visible = false
	add_child(_cursor_right)


func _unhandled_input(event: InputEvent) -> void:
	if menu_items.is_empty():
		return

	if event.is_action_pressed("ui_down"):
		_change_selection(1)
		get_viewport().set_input_as_handled()
	elif event.is_action_pressed("ui_up"):
		_change_selection(-1)
		get_viewport().set_input_as_handled()


# --- Public Methods ---


## Initializes the manager with a list of menu items to control.
func setup_menu(items: Array[Control]) -> void:
	if items.is_empty():
		return
	self.menu_items = items

	for item in menu_items:
		item.focus_entered.connect(_on_item_focused.bind(item))


# --- Private Methods ---


func _change_selection(amount: int) -> void:
	if menu_items.size() <= 1:
		return

	var new_selection = (current_selection_index + amount + menu_items.size()) % menu_items.size()
	menu_items[new_selection].grab_focus()


func _update_cursors(selected_item: Control) -> void:
	await get_tree().process_frame  # Wait for layout to settle

	if not is_instance_valid(selected_item):
		return

	var item_pos = selected_item.global_position
	var item_size = selected_item.size
	var cursor_padding = 40.0

	_cursor_left.global_position.y = item_pos.y + (item_size.y - _cursor_left.size.y) / 2.0
	_cursor_left.global_position.x = item_pos.x - cursor_padding - _cursor_left.size.x

	_cursor_right.global_position.y = item_pos.y + (item_size.y - _cursor_right.size.y) / 2.0
	_cursor_right.global_position.x = item_pos.x + item_size.x + cursor_padding

	_cursor_left.visible = true
	_cursor_right.visible = true


# --- Signal Handlers ---


func _on_item_focused(focused_item: Control) -> void:
	var index = menu_items.find(focused_item)
	if index != -1:
		current_selection_index = index

	_update_cursors(focused_item)
	selection_changed.emit()


=====================================
FILE: ./src/ui/dialogue/dialogue_box.gd
=====================================
# src/ui/dialogue/dialogue_box.gd
## The UI scene responsible for displaying dialogue text.
##
## It receives data from the [DialogueManager] and handles the visual
## presentation, including animated text effects.
class_name DialogueBox
extends Control

signal advance_requested
signal typing_finished

# --- Node References ---
@onready var name_label: Label = %NameLabel
@onready var text_label: RichTextLabel = %TextLabel

# --- Private Member Variables ---
var _typing_tween: Tween
var _is_typing: bool = false
var _typing_speed_chars_per_second: float = 60.0


# --- Godot Lifecycle Methods ---
func _unhandled_input(event: InputEvent) -> void:
	if not visible:
		return
	if event.is_action_pressed("ui_accept"):
		get_viewport().set_input_as_handled()
		_skip_or_advance()


# --- Public Methods ---


## Displays a single line of dialogue.
func display_line(line_data: DialogueLine) -> void:
	name_label.text = line_data.speaker
	text_label.bbcode_enabled = true
	text_label.text = line_data.text

	if is_instance_valid(_typing_tween):
		_typing_tween.kill()

	text_label.visible_ratio = 0.0
	_is_typing = true

	var parsed_text = text_label.get_parsed_text()
	var chars = parsed_text.length()
	var duration = max(0.1, float(chars) / _typing_speed_chars_per_second)

	_typing_tween = create_tween().set_trans(Tween.TRANS_LINEAR).set_ease(Tween.EASE_IN_OUT)
	_typing_tween.tween_property(text_label, "visible_ratio", 1.0, duration)
	_typing_tween.finished.connect(_on_typing_finished, CONNECT_ONE_SHOT)


# --- Private Methods ---
func _skip_or_advance() -> void:
	if _is_typing:
		if is_instance_valid(_typing_tween):
			_typing_tween.kill()
		text_label.visible_ratio = 1.0
		_on_typing_finished()
	else:
		advance_requested.emit()


func _on_typing_finished() -> void:
	_is_typing = false
	_typing_tween = null
	typing_finished.emit()


=====================================
FILE: ./src/ui/dialogue/dialogue_box.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://dialogue_box_tscn"]

[ext_resource type="Script" path="res://src/ui/dialogue/dialogue_box.gd" id="1_dialogue_box_script"]

[node name="DialogueBox" type="Control"]
layout_mode = 3
anchors_preset = 12
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_top = -250.0
grow_horizontal = 2
grow_vertical = 0
script = ExtResource("1_dialogue_box_script")

[node name="Panel" type="Panel" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2

[node name="MarginContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 20
theme_override_constants/margin_top = 20
theme_override_constants/margin_right = 20
theme_override_constants/margin_bottom = 20

[node name="VBoxContainer" type="VBoxContainer" parent="MarginContainer"]
layout_mode = 2

[node name="NameLabel" type="Label" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 32
text = "Character Name"

[node name="TextLabel" type="RichTextLabel" parent="MarginContainer/VBoxContainer"]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3
theme_override_font_sizes/normal_font_size = 28
bbcode_enabled = true
text = "This is where the dialogue text will appear, animating one character at a time..."

=====================================
FILE: ./src/ui/components/mute_button/mute_button.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://d1g2h3i4j5k6l"]

[ext_resource type="Texture2D" uid="uid://dmdfbw1txq0nf" path="res://assets/sprites/ui/icons/icon_ui_sound_off.png" id="1_g0pcd"]
[ext_resource type="Script" uid="uid://cotrj67gsvbw8" path="res://src/ui/components/mute_button/mute_button.gd" id="1_mute_button_script"]

[node name="MuteButton" type="TextureButton"]
focus_mode = 0
texture_normal = ExtResource("1_g0pcd")
script = ExtResource("1_mute_button_script")


=====================================
FILE: ./src/ui/components/mute_button/mute_button.gd
=====================================
# src/ui/components/mute_button/mute_button.gd
@tool
## A reusable UI component for toggling the game's music mute state.
##
## It automatically syncs its icon with the global [Settings] resource.
class_name MuteButton
extends TextureButton

# --- Constants ---
const ICON_SOUND_ON = preload(AssetPaths.ICON_UI_SOUND_ON)
const ICON_SOUND_OFF = preload(AssetPaths.ICON_UI_SOUND_OFF)

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	if not Engine.is_editor_hint():
		# This component is now fully self-managing.
		self.pressed.connect(_on_pressed)
		Settings.audio_settings_changed.connect(_on_audio_settings_changed)
		self.mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
		self.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))
		_on_audio_settings_changed()  # Sync icon on ready


func _exit_tree() -> void:
	if not Engine.is_editor_hint():
		if self.pressed.is_connected(_on_pressed):
			self.pressed.disconnect(_on_pressed)
		if Settings.audio_settings_changed.is_connected(_on_audio_settings_changed):
			Settings.audio_settings_changed.disconnect(_on_audio_settings_changed)
		if self.mouse_entered.is_connected(CursorManager.set_pointer_state.bind(true)):
			self.mouse_entered.disconnect(CursorManager.set_pointer_state.bind(true))
		if self.mouse_exited.is_connected(CursorManager.set_pointer_state.bind(false)):
			self.mouse_exited.disconnect(CursorManager.set_pointer_state.bind(false))


# --- Public Methods ---


## Updates the button's icon based on the current global mute state.
func update_icon() -> void:
	if Settings.music_muted:
		self.texture_normal = ICON_SOUND_OFF
	else:
		self.texture_normal = ICON_SOUND_ON


# --- Signal Handlers ---


func _on_pressed() -> void:
	# When pressed, this button directly modifies the global setting.
	Settings.music_muted = not Settings.music_muted
	# Play sound feedback
	AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)


func _on_audio_settings_changed() -> void:
	update_icon()


=====================================
FILE: ./src/ui/components/control_setting_row/control_setting_row.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://cgt6j1h2w3k4m"]

[ext_resource type="Script" uid="uid://cl6kmmhf3qt04" path="res://src/ui/components/control_setting_row/control_setting_row.gd" id="1_control_row_script"]
[ext_resource type="FontFile" uid="uid://hypwi2d6bj7t" path="res://assets/fonts/font_main_bold.ttf" id="2_font_bold"]
[ext_resource type="FontFile" uid="uid://d3jqjftjdw5hh" path="res://assets/fonts/font_main_regular.ttf" id="3_font_regular"]

[node name="ControlSettingRow" type="HBoxContainer"]
size_flags_horizontal = 4
theme_override_constants/separation = 40
script = ExtResource("1_control_row_script")

[node name="ActionLabel" type="Label" parent="."]
unique_name_in_owner = true
custom_minimum_size = Vector2(400, 0)
layout_mode = 2
theme_override_fonts/font = ExtResource("2_font_bold")
theme_override_font_sizes/font_size = 36
text = "Action"
horizontal_alignment = 2

[node name="KeysLabel" type="Label" parent="."]
unique_name_in_owner = true
custom_minimum_size = Vector2(500, 0)
layout_mode = 2
theme_override_fonts/font = ExtResource("3_font_regular")
theme_override_font_sizes/font_size = 36
text = "Keys"


=====================================
FILE: ./src/ui/components/control_setting_row/control_setting_row.gd
=====================================
# src/ui/components/control_setting_row/control_setting_row.gd
@tool
## A self-contained UI component for a single row in the controls menu.
## Manages its own labels and layout.
class_name ControlSettingRow
extends HBoxContainer

# --- Node References ---
@onready var action_label: Label = %ActionLabel
@onready var keys_label: Label = %KeysLabel

# --- Public Properties ---
@export var action_text: String = "Action":
	set(value):
		action_text = value
		if is_instance_valid(action_label):
			action_label.text = action_text

@export var keys_text: String = "Keys":
	set(value):
		keys_text = value
		if is_instance_valid(keys_label):
			keys_label.text = keys_text


# --- Godot Lifecycle Methods ---
func _ready() -> void:
	if is_instance_valid(action_label):
		action_label.text = action_text
	if is_instance_valid(keys_label):
		keys_label.text = keys_text


=====================================
FILE: ./src/ui/components/styled_menu_item/styled_menu_item.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://cgt63w7k4w5gq"]

[ext_resource type="Script" path="res://src/ui/components/styled_menu_item/styled_menu_item.gd" id="1_menu_item_script"]

[node name="StyledMenuItem" type="Control"]
custom_minimum_size = Vector2(400, 80)
layout_mode = 3
anchors_preset = 0
script = ExtResource("1_menu_item_script")

=====================================
FILE: ./src/ui/components/styled_menu_item/styled_menu_item.gd
=====================================
# src/ui/components/styled_menu_item/styled_menu_item.gd
@tool
## A reusable, procedurally-drawn menu item component.
##
## Handles its own drawing, state changes (hover, press, focus), input,
## and animations for a self-contained, highly configurable button.
class_name StyledMenuItem
extends Control

# --- Signals ---
## Emitted when the menu item is clicked or activated via keyboard.
signal pressed

# --- Editor Properties ---
@export var text: String = "Menu Item":
	set = set_text
@export var font_size: int = 48:
	set = set_font_size
@export var glow_size: float = 0.0:
	set = set_glow_size
@export var glow_alpha: float = 0.0:
	set = set_glow_alpha

# --- Member Variables ---
var is_hovered: bool = false
var is_pressed: bool = false
var is_selected: bool = false

# --- Private Member Variables ---
var _font: Font
var _active_tween: Tween

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	_font = load(AssetPaths.FONT_MAIN_BOLD)
	focus_mode = FOCUS_ALL
	mouse_filter = MOUSE_FILTER_STOP

	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)
	resized.connect(queue_redraw)
	focus_entered.connect(_on_focus_entered)
	focus_exited.connect(_on_focus_exited)


func _gui_input(event: InputEvent) -> void:
	if event.is_action_pressed("ui_accept") and has_focus():
		get_viewport().set_input_as_handled()
		emit_signal("pressed")
		_show_keyboard_press_feedback()
		return

	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		if event.is_pressed():
			is_pressed = true
			queue_redraw()
		elif is_pressed:  # On release
			emit_signal("pressed")
			is_pressed = false
			queue_redraw()


func _draw() -> void:
	var bg_color: Color
	var text_color: Color
	var border_color: Color
	var border_width: float = 3.0

	if is_pressed:
		bg_color = Palette.get_color(2)
		text_color = Palette.COLOR_TEXT_PRIMARY
		border_color = Palette.COLOR_UI_ACCENT_PRIMARY
	elif is_hovered or is_selected:
		bg_color = Palette.COLOR_UI_ACCENT_PRIMARY
		text_color = Palette.COLOR_BACKGROUND
		border_color = Palette.get_color(4)
	else:
		bg_color = Palette.COLOR_UI_PANEL_BG
		text_color = Palette.COLOR_TEXT_PRIMARY
		border_color = Palette.COLOR_UI_ACCENT_PRIMARY

	if (is_hovered or is_selected) and glow_size > 0.0 and glow_alpha > 0.0:
		var glow_base_color = Palette.COLOR_UI_GLOW
		var final_glow_color = Color(
			glow_base_color.r, glow_base_color.g, glow_base_color.b, glow_alpha
		)
		var glow_rect = Rect2(Vector2.ZERO, size).grow(glow_size)
		draw_rect(glow_rect, final_glow_color)

	draw_rect(Rect2(Vector2.ZERO, size), bg_color)
	draw_rect(Rect2(Vector2.ZERO, size), border_color, false, border_width)

	var text_width = _font.get_string_size(text, HORIZONTAL_ALIGNMENT_CENTER, -1, font_size).x
	var text_pos_x = (size.x - text_width) / 2.0
	var text_pos_y = (size.y / 2.0) + (font_size / 3.0)
	draw_string(
		_font,
		Vector2(text_pos_x, text_pos_y),
		text,
		HORIZONTAL_ALIGNMENT_LEFT,
		-1,
		font_size,
		text_color
	)


# --- Public Setters ---


func set_text(new_text: String) -> void:
	if text != new_text:
		text = new_text
		queue_redraw()


func set_font_size(new_size: int) -> void:
	if font_size != new_size:
		font_size = new_size
		queue_redraw()


func set_glow_size(value: float) -> void:
	glow_size = value
	queue_redraw()


func set_glow_alpha(value: float) -> void:
	glow_alpha = value
	queue_redraw()


# --- Private Methods ---


func _show_keyboard_press_feedback() -> void:
	is_pressed = true
	queue_redraw()
	await get_tree().create_timer(0.1).timeout
	if is_instance_valid(self):
		is_pressed = false
		queue_redraw()


func _animate_selection(p_is_selected: bool) -> void:
	if _active_tween and _active_tween.is_valid():
		_active_tween.kill()

	_active_tween = create_tween().set_parallel(true)
	var target_glow_size = 28.0 if p_is_selected else 0.0
	var target_glow_alpha = 0.2 if p_is_selected else 0.0
	var duration = 0.3 if p_is_selected else 0.2

	(
		_active_tween
		. tween_property(self, "glow_size", target_glow_size, duration)
		. set_trans(Tween.TRANS_SINE)
		. set_ease(Tween.EASE_OUT)
	)
	(
		_active_tween
		. tween_property(self, "glow_alpha", target_glow_alpha, duration)
		. set_trans(Tween.TRANS_SINE)
		. set_ease(Tween.EASE_OUT)
	)


# --- Signal Handlers ---


func _on_mouse_entered() -> void:
	is_hovered = true
	grab_focus()


func _on_mouse_exited() -> void:
	is_hovered = false
	if is_pressed:
		is_pressed = false
		queue_redraw()


func _on_focus_entered() -> void:
	is_selected = true
	_animate_selection(true)
	queue_redraw()


func _on_focus_exited() -> void:
	is_selected = false
	_animate_selection(false)
	queue_redraw()


=====================================
FILE: ./src/ui/components/sound_setting_row/sound_setting_row.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://cgt6j1h2w3k4l"]

[ext_resource type="Script" uid="uid://ch4xi7qr5btc" path="res://src/ui/components/sound_setting_row/sound_setting_row.gd" id="1_sound_row_script"]
[ext_resource type="PackedScene" uid="uid://bvyus5a6b7c8d" path="res://src/ui/components/custom_slider/custom_slider.tscn" id="2_custom_slider"]

[node name="SoundSettingRow" type="HBoxContainer"]
theme_override_constants/separation = 20
alignment = 1
script = ExtResource("1_sound_row_script")

[node name="NameLabel" type="Label" parent="."]
unique_name_in_owner = true
custom_minimum_size = Vector2(220, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 48
text = "SETTING"

[node name="ValueSlider" parent="." instance=ExtResource("2_custom_slider")]
unique_name_in_owner = true
layout_mode = 2

[node name="ValueLabel" type="Label" parent="."]
unique_name_in_owner = true
custom_minimum_size = Vector2(120, 0)
layout_mode = 2
theme_override_font_sizes/font_size = 48
text = "100"
horizontal_alignment = 1

[node name="MuteCheckbox" type="TextureButton" parent="."]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 4


=====================================
FILE: ./src/ui/components/sound_setting_row/sound_setting_row.gd
=====================================
# src/ui/components/sound_setting_row/sound_setting_row.gd
@tool
## A self-contained UI component for a single audio setting row.
## Manages its own visuals and emits signals when its values are changed by the user.
class_name SoundSettingRow
extends HBoxContainer

# --- Signals ---
signal value_changed(value: float)
signal mute_toggled(is_muted: bool)

# --- Node References ---
@onready var name_label: Label = %NameLabel
@onready var value_slider: TextureRect = %ValueSlider
@onready var value_label: Label = %ValueLabel
@onready var mute_checkbox: TextureButton = %MuteCheckbox

# --- Public Properties ---
@export var setting_name: String = "SETTING":
	set(value):
		setting_name = value
		if is_instance_valid(name_label):
			name_label.text = setting_name

var is_muted: bool = false

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	if is_instance_valid(name_label):
		name_label.text = setting_name
	if not Engine.is_editor_hint():
		value_slider.value_changed.connect(_on_slider_value_changed)
		mute_checkbox.pressed.connect(_on_mute_button_pressed)


# --- Public Methods ---


## Sets the visual state of the slider without emitting a signal.
func set_slider_value(value: float) -> void:
	if is_instance_valid(value_slider):
		value_slider.set_value(value)
	if is_instance_valid(value_label):
		value_label.text = str(int(value * 100))


## Sets the visual state of the checkbox without emitting a signal.
func set_mute_state(p_is_muted: bool) -> void:
	is_muted = p_is_muted
	var new_texture = (
		load(AssetPaths.SPRITE_CHECKBOX_UNCHECKED)
		if not is_muted
		else load(AssetPaths.SPRITE_CHECKBOX_CHECKED)
	)
	if is_instance_valid(mute_checkbox) and mute_checkbox.texture_normal != new_texture:
		mute_checkbox.texture_normal = new_texture


# --- Signal Handlers ---


func _on_slider_value_changed(value: float) -> void:
	if is_instance_valid(value_label):
		value_label.text = str(int(value * 100))
	value_changed.emit(value)


func _on_mute_button_pressed() -> void:
	is_muted = not is_muted
	set_mute_state(is_muted)
	mute_toggled.emit(is_muted)


=====================================
FILE: ./src/ui/components/custom_slider/custom_slider.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://bvyus5a6b7c8d"]

[ext_resource type="Script" uid="uid://8lrojyn5k5fq" path="res://src/ui/components/custom_slider/custom_slider.gd" id="1_custom_slider_script"]
[ext_resource type="Texture2D" uid="uid://dhh5eeyqf7l6f" path="res://assets/sprites/ui/slider/slider-track.png" id="1_puy0r"]

[node name="CustomSlider" type="TextureRect"]
custom_minimum_size = Vector2(400, 30)
offset_right = 400.0
offset_bottom = 30.0
size_flags_vertical = 4
texture = ExtResource("1_puy0r")
script = ExtResource("1_custom_slider_script")


=====================================
FILE: ./src/ui/components/custom_slider/custom_slider.gd
=====================================
# src/ui/components/custom_slider/custom_slider.gd
@tool
## A self-contained, reusable custom slider component.
extends TextureRect

# --- Signals ---
## Emitted when the slider's value changes.
signal value_changed(value: float)

# --- Member Variables ---
var knob: TextureRect
var is_dragging: bool = false
var min_x_pos: float = 0.0
var max_x_pos: float = 0.0
var drag_offset: float = 0.0
var _initial_value: float = -1.0  # Used to set value before node is ready

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	self.texture = load(AssetPaths.SPRITE_SLIDER_TRACK)

	knob = TextureRect.new()
	knob.texture = load(AssetPaths.SPRITE_SLIDER_KNOB)
	add_child(knob)

	knob.mouse_entered.connect(_on_knob_mouse_entered)
	knob.mouse_exited.connect(_on_knob_mouse_exited)

	# Wait for the next frame to ensure parent containers have arranged children.
	await get_tree().process_frame

	knob.position.y = (size.y - knob.size.y) / 2.0
	min_x_pos = global_position.x
	max_x_pos = global_position.x + size.x - knob.size.x

	if _initial_value >= 0.0:
		var new_x_pos = min_x_pos + (max_x_pos - min_x_pos) * _initial_value
		knob.global_position.x = clamp(new_x_pos, min_x_pos, max_x_pos)


func _process(_delta: float) -> void:
	if is_dragging:
		var global_mouse_pos = get_global_mouse_position()
		knob.global_position.x = clamp(global_mouse_pos.x - drag_offset, min_x_pos, max_x_pos)

		if (max_x_pos - min_x_pos) > 0:
			var current_value = (knob.global_position.x - min_x_pos) / (max_x_pos - min_x_pos)
			emit_signal("value_changed", current_value)


func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		var knob_rect = knob.get_global_rect()

		if event.is_pressed():
			if knob_rect.has_point(event.global_position):
				is_dragging = true
				drag_offset = event.global_position.x - knob.global_position.x
		else:
			is_dragging = false
			if not knob_rect.has_point(get_global_mouse_position()):
				CursorManager.set_pointer_state(false)
			drag_offset = 0.0


# --- Public Methods ---


## Sets the initial value of the slider.
func set_value(initial_value: float) -> void:
	_initial_value = initial_value


# --- Signal Handlers ---


func _on_knob_mouse_entered() -> void:
	CursorManager.set_pointer_state(true)


func _on_knob_mouse_exited() -> void:
	if not is_dragging:
		CursorManager.set_pointer_state(false)


=====================================
FILE: ./src/ui/components/logo_display/logo_display.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://b1c2d3e4f5g6h"]

[ext_resource type="Script" path="res://src/ui/components/logo_display/logo_display.gd" id="1_logo_script"]

[node name="LogoDisplay" type="Control"]
custom_minimum_size = Vector2(200, 200)
layout_mode = 3
anchors_preset = 0
script = ExtResource("1_logo_script")

[node name="TextureRect" type="TextureRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
expand_mode = 1
stretch_mode = 5

=====================================
FILE: ./src/ui/components/logo_display/logo_display.gd
=====================================
# src/ui/components/logo_display/logo_display.gd
@tool
## A reusable UI component for displaying an interactive logo.
##
## Provides visual feedback on hover and emits a signal when pressed.
class_name LogoDisplay
extends Control

# --- Signals ---
## Emitted when the logo is clicked, passing its [member logo_name].
signal pressed(logo_name: String)

# --- Node References ---
@onready var texture_rect: TextureRect = $TextureRect

# --- Editor Properties ---
@export var texture: Texture2D:
	set(value):
		texture = value
		if is_instance_valid(texture_rect):
			texture_rect.texture = texture

@export var logo_name: String = "Logo"
@export var glow_size: float = 0.0:
	set = set_glow_size
@export var glow_alpha: float = 0.0:
	set = set_glow_alpha

# --- Member Variables ---
var is_hovered: bool = false
var is_pressed: bool = false

# --- Private Member Variables ---
var _active_tween: Tween

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	mouse_filter = MOUSE_FILTER_STOP

	if is_instance_valid(texture_rect) and texture:
		texture_rect.texture = texture

	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)


func _gui_input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		if event.is_pressed():
			is_pressed = true
			queue_redraw()
		elif is_pressed:  # On release
			emit_signal("pressed", logo_name)
			is_pressed = false
			queue_redraw()


func _draw() -> void:
	if is_hovered and glow_size > 0.0 and glow_alpha > 0.0:
		var glow_base_color = Palette.COLOR_UI_GLOW
		var final_glow_color = Color(
			glow_base_color.r, glow_base_color.g, glow_base_color.b, glow_alpha
		)
		var glow_rect = Rect2(Vector2.ZERO, size).grow(glow_size)
		draw_rect(glow_rect, final_glow_color)


# --- Public Setters ---


func set_glow_size(value: float) -> void:
	glow_size = value
	queue_redraw()


func set_glow_alpha(value: float) -> void:
	glow_alpha = value
	queue_redraw()


# --- Private Methods ---


func _animate_hover(p_is_hovered: bool) -> void:
	if _active_tween and _active_tween.is_valid():
		_active_tween.kill()

	_active_tween = create_tween().set_parallel(true)
	var target_glow_size = 20.0 if p_is_hovered else 0.0
	var target_glow_alpha = 0.2 if p_is_hovered else 0.0
	var duration = 0.3 if p_is_hovered else 0.2

	(
		_active_tween
		. tween_property(self, "glow_size", target_glow_size, duration)
		. set_trans(Tween.TRANS_SINE)
		. set_ease(Tween.EASE_OUT)
	)
	(
		_active_tween
		. tween_property(self, "glow_alpha", target_glow_alpha, duration)
		. set_trans(Tween.TRANS_SINE)
		. set_ease(Tween.EASE_OUT)
	)


# --- Signal Handlers ---


func _on_mouse_entered() -> void:
	is_hovered = true
	_animate_hover(true)
	if not Engine.is_editor_hint():
		CursorManager.set_pointer_state(true)
		AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE)


func _on_mouse_exited() -> void:
	is_hovered = false
	if is_pressed:
		is_pressed = false
		queue_redraw()
	_animate_hover(false)
	if not Engine.is_editor_hint():
		CursorManager.set_pointer_state(false)


=====================================
FILE: ./src/ui/dev/debug_overlay.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://debug_overlay_scene_id"]

[ext_resource type="Script" path="res://src/ui/dev/debug_overlay.gd" id="1_debug_script"]

[node name="DebugOverlay" type="CanvasLayer"]
layer = 100
script = ExtResource("1_debug_script")

[node name="Panel" type="Panel" parent="."]
unique_name_in_owner = true
layout_mode = 0
offset_left = 10.0
offset_top = 10.0
offset_right = 910.0
offset_bottom = 330.0
mouse_filter = 2

[node name="MarginContainer" type="MarginContainer" parent="Panel"]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/margin_left = 10
theme_override_constants/margin_top = 10
theme_override_constants/margin_right = 10
theme_override_constants/margin_bottom = 10

[node name="Columns" type="HBoxContainer" parent="Panel/MarginContainer"]
layout_mode = 2
theme_override_constants/separation = 20

[node name="EntityInfoColumn" type="VBoxContainer" parent="Panel/MarginContainer/Columns"]
layout_mode = 2
size_flags_horizontal = 3

[node name="StateLabel" type="Label" parent="Panel/MarginContainer/Columns/EntityInfoColumn"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "State:"
autowrap_mode = 2

[node name="VelocityLabel" type="Label" parent="Panel/MarginContainer/Columns/EntityInfoColumn"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Velocity:"

[node name="FlagsLabel" type="Label" parent="Panel/MarginContainer/Columns/EntityInfoColumn"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "Flags:"
autowrap_mode = 2

[node name="StateHistoryLabel" type="Label" parent="Panel/MarginContainer/Columns/EntityInfoColumn"]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3
theme_override_font_sizes/font_size = 20
text = "History:"
autowrap_mode = 2

[node name="InputBufferLabel" type="Label" parent="Panel/MarginContainer/Columns/EntityInfoColumn"]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3
theme_override_font_sizes/font_size = 20
text = "Input:"
autowrap_mode = 2

[node name="VSeparator" type="VSeparator" parent="Panel/MarginContainer/Columns"]
layout_mode = 2

[node name="GlobalInfoColumn" type="VBoxContainer" parent="Panel/MarginContainer/Columns"]
layout_mode = 2
size_flags_horizontal = 3

[node name="FPSLabel" type="Label" parent="Panel/MarginContainer/Columns/GlobalInfoColumn"]
unique_name_in_owner = true
layout_mode = 2
theme_override_font_sizes/font_size = 20
text = "FPS:"

[node name="PoolsLabel" type="Label" parent="Panel/MarginContainer/Columns/GlobalInfoColumn"]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3
theme_override_font_sizes/font_size = 20
text = "Pools:"
autowrap_mode = 2

[node name="FXLabel" type="Label" parent="Panel/MarginContainer/Columns/GlobalInfoColumn"]
unique_name_in_owner = true
layout_mode = 2
size_flags_vertical = 3
theme_override_font_sizes/font_size = 20
text = "FX:"
autowrap_mode = 2

=====================================
FILE: ./src/ui/dev/debug_overlay.gd
=====================================
# src/ui/dev/debug_overlay.gd
## A toggleable overlay for displaying real-time developer debug information.
extends CanvasLayer

# --- Node References ---
@onready var fps_label: Label = %FPSLabel
@onready var state_label: Label = %StateLabel
@onready var velocity_label: Label = %VelocityLabel
@onready var flags_label: Label = %FlagsLabel
@onready var state_history_label: Label = %StateHistoryLabel
@onready var input_buffer_label: Label = %InputBufferLabel
@onready var pools_label: Label = %PoolsLabel
@onready var fx_label: Label = %FXLabel
@onready var panel: Panel = %Panel

# --- Private Member Variables ---
var _target_entity: Node = null
var _services: ServiceLocator

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	var panel_style = StyleBoxFlat.new()
	panel_style.bg_color = Color(0, 0, 0, 0.6)
	panel_style.border_width_left = 2
	panel_style.border_width_top = 2
	panel_style.border_width_right = 2
	panel_style.border_width_bottom = 2
	panel_style.border_color = Palette.COLOR_UI_ACCENT_PRIMARY
	panel.add_theme_stylebox_override("panel", panel_style)


func _process(_delta: float) -> void:
	var fps_text = "FPS: %d" % Engine.get_frames_per_second()
	fps_label.text = fps_text

	if not is_instance_valid(_target_entity) or not _target_entity.has_method("get_component"):
		state_label.text = "State: NO TARGET"
		velocity_label.text = "Velocity:"
		flags_label.text = "Flags:"
		state_history_label.text = "History:"
		input_buffer_label.text = "Input:"
	else:
		velocity_label.text = "Target: %s" % _target_entity.name

		var state_machine: BaseStateMachine = _target_entity.get_component(BaseStateMachine)
		var current_state_name = "N/A"
		if is_instance_valid(state_machine) and is_instance_valid(state_machine.current_state):
			current_state_name = state_machine.current_state.get_script().resource_path.get_file()
		state_label.text = "State: %s" % current_state_name

		var health_comp: HealthComponent = _target_entity.get_component(HealthComponent)
		var is_invincible_str = (
			str(health_comp.is_invincible()) if is_instance_valid(health_comp) else "N/A"
		)
		var on_floor_str = (
			str(_target_entity.is_on_floor()) if _target_entity is CharacterBody2D else "N/A"
		)

		var flags_text = "Flags: OnFloor(%s) Invincible(%s)" % [on_floor_str, is_invincible_str]
		if _target_entity is Player:
			flags_text += " CanDash(%s)" % _target_entity.entity_data.can_dash
			if is_instance_valid(state_machine):
				state_history_label.text = "History: " + ", ".join(state_machine.state_history)
			_update_player_input_buffer()
		else:
			state_history_label.text = "History:"
			input_buffer_label.text = "Input:"

		flags_label.text = flags_text

	if is_instance_valid(_services):
		var pool_stats: Dictionary = _services.object_pool.get_pool_stats()
		var pool_text_parts: Array[String] = []
		for pool_name in pool_stats:
			var stats = pool_stats[pool_name]
			pool_text_parts.append("%s [%d/%d]" % [pool_name, stats.active, stats.total])
		pools_label.text = "Pools:\n" + "\n".join(pool_text_parts)

		var fx_stats = _services.fx_manager.get_debug_stats()
		fx_label.text = "FX:\nShaders[%d] VFX[%d]" % [fx_stats.active_shaders, fx_stats.active_vfx]


# --- Public Methods ---
func set_target(entity: Node) -> void:
	_target_entity = entity

func inject_dependencies(p_services: ServiceLocator) -> void:
	_services = p_services


# --- Private Methods ---
func _update_player_input_buffer() -> void:
	var input_comp: InputComponent = _target_entity.get_component(InputComponent)
	if not is_instance_valid(input_comp):
		input_buffer_label.text = "Input: N/A"
		return

	var input_buffer: Dictionary = input_comp.buffer
	var input_text_parts: Array[String] = []
	for key in input_buffer:
		var value = input_buffer[key]
		var should_display = false
		if value is bool and value == true:
			should_display = true
		elif value is float and not is_zero_approx(value):
			should_display = true

		if should_display:
			input_text_parts.append("%s: %s" % [key, value])

	input_buffer_label.text = "Input: " + ", ".join(input_text_parts)


=====================================
FILE: ./src/scenes/loading/loading_screen.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://loading_screen_scene_id"]

[ext_resource type="Script" path="res://src/scenes/loading/loading_screen.gd" id="1_loading_script"]

[node name="LoadingScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_loading_script")

[node name="ColorRect" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="Label" type="Label" parent="."]
layout_mode = 1
anchors_preset = 8
anchor_left = 0.5
anchor_top = 0.5
anchor_right = 0.5
anchor_bottom = 0.5
offset_left = -75.0
offset_top = -16.5
offset_right = 75.0
offset_bottom = 16.5
grow_horizontal = 2
grow_vertical = 2
theme_override_font_sizes/font_size = 30
text = "Loading..."
horizontal_alignment = 1
vertical_alignment = 1

[node name="ShaderPrewarmViewport" type="SubViewportContainer" parent="."]
custom_minimum_size = Vector2(1, 1)
layout_mode = 0
offset_left = -10.0
offset_top = -10.0
offset_right = -9.0
offset_bottom = -9.0
stretch = true

[node name="SubViewport" type="SubViewport" parent="ShaderPrewarmViewport"]
handle_input_locally = false
size = Vector2i(1, 1)
render_target_update_mode = 4

=====================================
FILE: ./src/scenes/loading/loading_screen.gd
=====================================
# src/scenes/loading/loading_screen.gd
## Handles asynchronous level building and shader pre-warming.
##
## This scene acts as an intermediary to prevent stuttering. It first builds
## the level in batches, then pre-instantiates key entities in an off-screen
## viewport to force shader compilation before transitioning to the game scene.
extends Control

# --- Constants ---
const SHADER_PREWARM_SCENES = [
	AssetPaths.SCENE_PLAYER,
	AssetPaths.SCENE_BASE_BOSS,
	AssetPaths.SCENE_PLAYER_SHOT,
	AssetPaths.SCENE_BOSS_SHOT,
	# THE FIX: Use the new SCENE_MINION_SHOT constant.
	AssetPaths.SCENE_MINION_SHOT,
	AssetPaths.SCENE_HOMING_BOSS_SHOT,
]

# --- Node References ---
@onready var prewarm_viewport: SubViewport = $ShaderPrewarmViewport/SubViewport

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	if GameManager.state.current_encounter_path.is_empty():
		print("ERROR: No encounter script specified in GameManager. Returning to title.")
		SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)
		return

	_load_level()


# --- Private Methods ---


## The main loading and pre-warming sequence.
func _load_level() -> void:
	await get_tree().process_frame

	await _prewarm_shaders()

	var effects_to_prewarm: Array[ShaderEffect] = [
		load("res://src/data/effects/entity_hit_flash_effect.tres"),
		load("res://src/core/data/effects/dissolve_effect.tres"),
	]
	await FXManager.prewarm_shaders_async(effects_to_prewarm, prewarm_viewport)

	GameManager.state.prebuilt_level = await ArenaBuilder.build_level_async()

	await get_tree().process_frame

	SceneManager.go_to_scene(AssetPaths.SCENE_ENCOUNTER)


## Instantiates scenes off-screen to compile their shaders.
func _prewarm_shaders() -> void:
	print("Starting shader pre-warming...")
	for scene_path in SHADER_PREWARM_SCENES:
		if not FileAccess.file_exists(scene_path):
			continue
		var instance = load(scene_path).instantiate()

		if instance.has_method("inject_dependencies"):
			# THE FIX: Pass the ServiceLocator singleton directly.
			instance.inject_dependencies(ServiceLocator)

		prewarm_viewport.add_child(instance)

		if instance is Player:
			instance.velocity.x = 100
			var sm: BaseStateMachine = instance.get_component(BaseStateMachine)
			if is_instance_valid(sm) and sm.has_method("change_state"):
				sm.change_state(Identifiers.PlayerStates.ATTACK)
		elif instance is BaseBoss:
			instance.velocity.x = 100

		await get_tree().process_frame
		instance.queue_free()
	print("Shader pre-warming complete.")


=====================================
FILE: ./src/scenes/game/encounter_scene.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://game_scene_unique_id"]

[ext_resource type="Script" path="res://src/scenes/game/encounter_scene.gd" id="1_game_script"]

[node name="EncounterScene" type="Node"]
script = ExtResource("1_game_script")

[node name="Camera2D" type="Camera2D" parent="."]

=====================================
FILE: ./src/scenes/game/encounter_scene.gd
=====================================
# src/scenes/game/encounter_scene.gd
## The main game scene controller.
##
## Responsible for asynchronously building the level, spawning entities,
## managing the game camera, and handling victory/defeat sequences.
## It also manages the developer debug overlay and target inspection.
class_name EncounterScene
extends ISceneController

# --- Node References ---
@onready var camera: Camera2D = $Camera2D

# --- Private Member Variables ---
var _level_container: Node = null
var _debug_overlay: CanvasLayer = null
var _boss_died_token: int = 0
var _death_sequence_handle: SequenceHandle
var _camera_shaker: CameraShaker = null
const TestConversation = preload("res://src/data/dialogue/test_conversation.tres")

# --- Debug Inspector ---
var _inspectable_entities: Array[Node] = []
var _current_inspect_index: int = 0

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	_boss_died_token = EventBus.on(EventCatalog.BOSS_DIED, _on_boss_died)

	if is_instance_valid(GameManager.state.prebuilt_level):
		_level_container = GameManager.state.prebuilt_level
		GameManager.state.prebuilt_level = null
	else:
		_level_container = await ArenaBuilder.build_level_async()

	if is_instance_valid(_level_container):
		add_child(_level_container)
		await get_tree().process_frame

		var build_data: LevelBuildData = _level_container.get_meta("build_data")
		if build_data:
			CameraManager.center_camera_on_arena(camera, build_data.dimensions_tiles)
			await get_tree().process_frame
			var terrain_builder := TerrainBuilder.new()
			terrain_builder.fill_viewport(_level_container, build_data, camera, ServiceLocator)

	_initialize_camera_shaker()
	_initialize_debug_inspector()

	var player_node: Node = get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)
	if is_instance_valid(player_node):
		player_node.died.connect(_on_player_died)


func _unhandled_input(_event: InputEvent) -> void:
	if Input.is_action_just_pressed("debug_toggle_overlay"):
		if is_instance_valid(_debug_overlay):
			_debug_overlay.visible = not _debug_overlay.visible

	if Input.is_action_just_pressed("debug_dialogue"):
		if DialogueManager.is_conversation_active():
			DialogueManager.end_conversation()
		else:
			DialogueManager.start_conversation(TestConversation)

	if Input.is_action_just_pressed("debug_cycle_target"):
		if is_instance_valid(_debug_overlay) and _debug_overlay.visible:
			_cycle_debug_target()


func _exit_tree() -> void:
	# This is the safety net that catches exits not handled by SceneManager.
	_cleanup_entities()

	EventBus.off(_boss_died_token)
	FXManager.unregister_camera_shaker()
	if is_instance_valid(_death_sequence_handle):
		_death_sequence_handle.cancel()
	if is_instance_valid(camera):
		camera.offset = Vector2.ZERO
	get_tree().paused = false


# --- Public Methods (ISceneController Contract) ---


func scene_exiting() -> void:
	_cleanup_entities()


# --- Private Methods ---


func _cleanup_entities() -> void:
	# This centralized function ensures all entities are properly torn down.
	var player_node: Node = get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)
	if is_instance_valid(player_node) and player_node.has_method("teardown"):
		player_node.teardown()

	var enemy_nodes: Array[Node] = get_tree().get_nodes_in_group(Identifiers.Groups.ENEMY)
	for enemy in enemy_nodes:
		if is_instance_valid(enemy) and enemy.has_method("teardown"):
			enemy.teardown()


func _initialize_camera_shaker() -> void:
	var shaker_scene: PackedScene = load("res://src/core/systems/camera_shaker.tscn")
	if shaker_scene:
		_camera_shaker = shaker_scene.instantiate() as CameraShaker
		add_child(_camera_shaker)
		_camera_shaker.target_camera = camera
		FXManager.register_camera_shaker(_camera_shaker)


func _initialize_debug_inspector() -> void:
	_debug_overlay = load(AssetPaths.SCENE_DEBUG_OVERLAY).instantiate()
	_debug_overlay.inject_dependencies(ServiceLocator)
	add_child(_debug_overlay)
	_debug_overlay.visible = false

	_inspectable_entities.append_array(get_tree().get_nodes_in_group(Identifiers.Groups.PLAYER))
	_inspectable_entities.append_array(get_tree().get_nodes_in_group(Identifiers.Groups.ENEMY))

	if not _inspectable_entities.is_empty():
		_debug_overlay.set_target(_inspectable_entities[0])


func _cycle_debug_target() -> void:
	_inspectable_entities = _inspectable_entities.filter(func(e): return is_instance_valid(e))

	if _inspectable_entities.is_empty():
		_debug_overlay.set_target(null)
		return

	_current_inspect_index = (_current_inspect_index + 1) % _inspectable_entities.size()
	var new_target: Node = _inspectable_entities[_current_inspect_index]
	_debug_overlay.set_target(new_target)


func _deactivate_all_minions() -> void:
	var minions: Array[Node] = get_tree().get_nodes_in_group(Identifiers.Groups.ENEMY)
	for minion in minions:
		if minion.has_method("deactivate"):
			minion.deactivate()


# --- Signal Handlers ---


func _on_player_died() -> void:
	SceneManager.go_to_game_over()


func _on_boss_died(payload: Dictionary) -> void:
	var player_node: Node = get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)
	if is_instance_valid(player_node):
		player_node.set_physics_process(false)
	var boss_node: Node = payload.get("boss_node")

	_deactivate_all_minions()

	var wait_step := WaitStep.new()
	wait_step.duration = 2.0
	var death_sequence: Array[SequenceStep] = [wait_step]

	_death_sequence_handle = Sequencer.run_sequence(death_sequence)
	await _death_sequence_handle.finished

	if is_instance_valid(boss_node):
		boss_node.queue_free()

	if is_instance_valid(_death_sequence_handle):
		SceneManager.go_to_victory()


=====================================
FILE: ./src/scenes/menus/options_screen.tscn
=====================================
[gd_scene load_steps=5 format=3 uid="uid://cuiywha4vccw"]

[ext_resource type="Script" uid="uid://c7ggk7djqvf53" path="res://src/scenes/menus/options_screen.gd" id="1_options_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="4_mute_button"]

[node name="OptionsScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_options_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "OPTIONS"
horizontal_alignment = 1

[node name="TitleMenuSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 60)
layout_mode = 2

[node name="MenuItemsVBox" type="VBoxContainer" parent="MainVBox"]
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 40
alignment = 1

[node name="SoundButton" parent="MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="ControlsButton" parent="MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="CreditsButton" parent="MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="ExpandSpacer" type="Control" parent="MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" parent="MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
font_size = 64

[node name="BottomSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 350

[node name="MuteButton" parent="MuteButtonContainer" instance=ExtResource("4_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0


=====================================
FILE: ./src/scenes/menus/title_screen.tscn
=====================================
[gd_scene load_steps=9 format=3 uid="uid://beattfyix2423"]

[ext_resource type="Script" uid="uid://d0pxln7nldjne" path="res://src/scenes/menus/title_screen.gd" id="1_title_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="PackedScene" uid="uid://b1c2d3e4f5g6h" path="res://src/ui/components/logo_display/logo_display.tscn" id="3_logo_display"]
[ext_resource type="Texture2D" uid="uid://t2u26wkw02xm" path="res://assets/sprites/ui/logos/newgrounds_logo.png" id="4_logo_ng"]
[ext_resource type="Texture2D" uid="uid://2gqa4m05wd20" path="res://assets/sprites/ui/logos/godot_logo.png" id="5_logo_godot"]
[ext_resource type="Texture2D" uid="uid://d0fuu548hoouq" path="res://assets/sprites/ui/logos/itch_logo.png" id="6_logo_itch"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="7_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="8_mute_button"]

[node name="TitleScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_title_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("7_font_black")
theme_override_font_sizes/font_size = 128
text = "BOX BATTLE"
horizontal_alignment = 1

[node name="TitleMenuSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 30)
layout_mode = 2

; --- Menu Items ---
[node name="MenuItemsVBox" type="VBoxContainer" parent="MainVBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 40
alignment = 1

[node name="StartButton" parent="MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="OptionsButton" parent="MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="ExitButton" parent="MainVBox/MenuItemsVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
focus_mode = 2
font_size = 64

[node name="ExpandSpacer" type="Control" parent="MainVBox"]
layout_mode = 2
size_flags_vertical = 3

; --- Footer Logos ---
[node name="FooterHBox" type="HBoxContainer" parent="MainVBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 50
alignment = 1

[node name="NewgroundsLogo" parent="MainVBox/FooterHBox" instance=ExtResource("3_logo_display")]
unique_name_in_owner = true
layout_mode = 2
texture = ExtResource("4_logo_ng")
logo_name = "Newgrounds"

[node name="GodotLogo" parent="MainVBox/FooterHBox" instance=ExtResource("3_logo_display")]
unique_name_in_owner = true
layout_mode = 2
texture = ExtResource("5_logo_godot")
logo_name = "Godot"

[node name="ItchLogo" parent="MainVBox/FooterHBox" instance=ExtResource("3_logo_display")]
unique_name_in_owner = true
layout_mode = 2
texture = ExtResource("6_logo_itch")
logo_name = "Itch"

[node name="BottomSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 50)
layout_mode = 2

; --- Global UI ---
[node name="MuteButtonContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 350

[node name="MuteButton" parent="MuteButtonContainer" instance=ExtResource("8_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0

=====================================
FILE: ./src/scenes/menus/title_screen.gd
=====================================
# src/scenes/menus/title_screen.gd
## The controller for the main title screen scene.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# --- Node References ---
@onready var background_color: ColorRect = $BackgroundColor
@onready var start_button: StyledMenuItem = %StartButton
@onready var options_button: StyledMenuItem = %OptionsButton
@onready var exit_button: StyledMenuItem = %ExitButton
@onready var newgrounds_logo: LogoDisplay = %NewgroundsLogo
@onready var godot_logo: LogoDisplay = %GodotLogo
@onready var itch_logo: LogoDisplay = %ItchLogo
@onready var mute_button: MuteButton = $MuteButtonContainer/MuteButton

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	background_color.color = Palette.COLOR_BACKGROUND

	start_button.text = "START GAME"
	options_button.text = "OPTIONS"
	exit_button.text = "EXIT"

	if not Engine.is_editor_hint():
		# --- Connect Action Signals ---
		start_button.pressed.connect(_on_start_button_pressed)
		options_button.pressed.connect(_on_options_button_pressed)
		exit_button.pressed.connect(_on_exit_button_pressed)
		newgrounds_logo.pressed.connect(_on_logo_pressed)
		godot_logo.pressed.connect(_on_logo_pressed)
		itch_logo.pressed.connect(_on_logo_pressed)

		# --- Connect All Items to Generic Feedback Handlers ---
		var all_interactive_items: Array[Control] = [
			start_button,
			options_button,
			exit_button,
			newgrounds_logo,
			godot_logo,
			itch_logo,
		]
		for item in all_interactive_items:
			item.pressed.connect(_on_any_item_pressed)

		var focusable_items: Array[StyledMenuItem] = [start_button, options_button, exit_button]
		for item in focusable_items:
			item.focus_entered.connect(_on_any_item_focused)
			item.mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
			item.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))

		# --- Initialize Menu Manager ---
		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		var menu_items: Array[Control] = [start_button, options_button, exit_button]
		menu_manager.setup_menu(menu_items)
		menu_manager.selection_changed.connect(_on_any_item_focused)

		await get_tree().process_frame
		start_button.grab_focus()


# --- Signal Handlers ---


func _on_any_item_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)


func _on_any_item_focused() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE)


func _on_start_button_pressed() -> void:
	SceneManager.start_game(AssetPaths.ENCOUNTER_00)


func _on_options_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_OPTIONS_SCREEN)


func _on_exit_button_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_BACK)
	await get_tree().create_timer(0.2).timeout
	get_tree().quit()


func _on_logo_pressed(logo_name: String) -> void:
	print("%s Pressed" % logo_name)


=====================================
FILE: ./src/scenes/menus/credits_screen.gd
=====================================
# src/scenes/menus/credits_screen.gd
## The controller for the credits screen.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)
const CREDITS_BBCODE = """
[center]A Game By Steven Casteel[/center]
[center][url=https://www.stevencasteel.com/]www.stevencasteel.com[/url][/center]

[center]Built with the [url=https://godotengine.org/]Godot Engine[/url][/center]
[center]AI-Assisted by [url=https://gemini.google.com/]Gemini[/url][/center]

[center]Find me on [url=https://www.youtube.com/@stevencasteel]YouTube[/url] and [url=http://github.com/stevencasteel]GitHub[/url][/center]
"""

# --- Node References ---
@onready var credits_label_container: Control = %CreditsLabelContainer
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	for c in credits_label_container.get_children():
		c.queue_free()

	var credits_label = RichTextLabel.new()
	credits_label.set_anchors_preset(Control.PRESET_FULL_RECT)
	credits_label.bbcode_enabled = true
	credits_label.mouse_filter = MOUSE_FILTER_PASS
	credits_label.add_theme_font_override("normal_font", load(AssetPaths.FONT_MAIN_REGULAR))
	credits_label.add_theme_font_size_override("normal_font_size", 38)
	credits_label.add_theme_color_override("default_color", Color.WHITE)
	credits_label.text = CREDITS_BBCODE
	credits_label_container.add_child(credits_label)

	back_button.text = "BACK"

	if not Engine.is_editor_hint():
		back_button.pressed.connect(_on_back_button_pressed)
		credits_label.meta_clicked.connect(_on_meta_clicked)
		credits_label.meta_hover_started.connect(func(_meta): CursorManager.set_pointer_state(true))
		credits_label.meta_hover_ended.connect(func(_meta): CursorManager.set_pointer_state(false))

		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		menu_manager.setup_menu([back_button])

		# --- Connect Feedback Handlers ---
		menu_manager.selection_changed.connect(_on_any_item_focused)
		back_button.mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
		back_button.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))

		await get_tree().process_frame
		back_button.grab_focus()


# --- Signal Handlers ---


func _on_any_item_focused() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE)


func _on_meta_clicked(meta) -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)
	OS.shell_open(str(meta))


func _on_back_button_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_BACK)
	SceneManager.go_to_scene(AssetPaths.SCENE_OPTIONS_SCREEN)


=====================================
FILE: ./src/scenes/menus/sound_screen.tscn
=====================================
[gd_scene load_steps=6 format=3 uid="uid://dsvv7o1v1j8t1"]

[ext_resource type="Script" uid="uid://451xh65eo2eo" path="res://src/scenes/menus/sound_screen.gd" id="1_sound_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="4_mute_button"]
[ext_resource type="PackedScene" uid="uid://cgt6j1h2w3k4l" path="res://src/ui/components/sound_setting_row/sound_setting_row.tscn" id="5_sound_row"]

[node name="SoundScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_sound_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "SOUND"
horizontal_alignment = 1

[node name="TitleMenuSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 90)
layout_mode = 2

[node name="MenuItemsVBox" type="VBoxContainer" parent="MainVBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 40
alignment = 1

[node name="MasterRow" parent="MainVBox/MenuItemsVBox" instance=ExtResource("5_sound_row")]
unique_name_in_owner = true
layout_mode = 2
setting_name = "MASTER"

[node name="MusicRow" parent="MainVBox/MenuItemsVBox" instance=ExtResource("5_sound_row")]
unique_name_in_owner = true
layout_mode = 2
setting_name = "MUSIC"

[node name="SfxRow" parent="MainVBox/MenuItemsVBox" instance=ExtResource("5_sound_row")]
unique_name_in_owner = true
layout_mode = 2
setting_name = "SFX"

[node name="ExpandSpacer" type="Control" parent="MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" parent="MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64

[node name="BottomSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 350

[node name="MuteButton" parent="MuteButtonContainer" instance=ExtResource("4_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0


=====================================
FILE: ./src/scenes/menus/credits_screen.tscn
=====================================
[gd_scene load_steps=5 format=3 uid="uid://c5v6x7y81aa0b"]

[ext_resource type="Script" uid="uid://b5n30r8nhclsb" path="res://src/scenes/menus/credits_screen.gd" id="1_credits_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="4_mute_button"]

[node name="CreditsScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_credits_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "CREDITS"
horizontal_alignment = 1

[node name="CreditsLabelContainer" type="Control" parent="MainVBox"]
unique_name_in_owner = true
custom_minimum_size = Vector2(0, 450)
layout_mode = 2

[node name="ExpandSpacer" type="Control" parent="MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" parent="MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64

[node name="BottomSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 350

[node name="MuteButton" parent="MuteButtonContainer" instance=ExtResource("4_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0

=====================================
FILE: ./src/scenes/menus/options_screen.gd
=====================================
# src/scenes/menus/options_screen.gd
## The controller for the main options menu scene.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# --- Node References ---
@onready var sound_button: StyledMenuItem = %SoundButton
@onready var controls_button: StyledMenuItem = %ControlsButton
@onready var credits_button: StyledMenuItem = %CreditsButton
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	sound_button.text = "SOUND"
	controls_button.text = "CONTROLS"
	credits_button.text = "CREDITS"
	back_button.text = "BACK"

	if not Engine.is_editor_hint():
		# --- Connect Signals ---
		sound_button.pressed.connect(_on_sound_button_pressed)
		controls_button.pressed.connect(_on_controls_button_pressed)
		credits_button.pressed.connect(_on_credits_button_pressed)
		back_button.pressed.connect(_on_back_button_pressed)

		# --- Initialize Menu Manager ---
		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		var menu_items: Array[Control] = [
			sound_button, controls_button, credits_button, back_button
		]
		menu_manager.setup_menu(menu_items)

		# --- Connect Feedback Handlers ---
		menu_manager.selection_changed.connect(_on_any_item_focused)
		var generic_menu_items = [sound_button, controls_button, credits_button]
		for item in generic_menu_items:
			item.pressed.connect(_on_any_item_pressed)
			item.mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
			item.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))

		# Connect feedback for the back button separately
		back_button.mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
		back_button.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))

		await get_tree().process_frame
		sound_button.grab_focus()


# --- Signal Handlers ---


func _on_any_item_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_SELECT)


func _on_any_item_focused() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE)


func _on_sound_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_SOUND_SCREEN)


func _on_controls_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_CONTROLS_SCREEN)


func _on_credits_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_CREDITS_SCREEN)


func _on_back_button_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_BACK)
	SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)


=====================================
FILE: ./src/scenes/menus/sound_screen.gd
=====================================
# src/scenes/menus/sound_screen.gd
## The controller for the sound options menu.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# --- Node References ---
@onready var master_row: SoundSettingRow = %MasterRow
@onready var music_row: SoundSettingRow = %MusicRow
@onready var sfx_row: SoundSettingRow = %SfxRow
@onready var back_button: StyledMenuItem = %BackButton
@onready var mute_button: MuteButton = $MuteButtonContainer/MuteButton

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	back_button.text = "BACK"

	if not Engine.is_editor_hint():
		# Connect component signals to the Settings singleton
		master_row.value_changed.connect(func(val): Settings.master_volume = val)
		master_row.mute_toggled.connect(func(val): Settings.master_muted = val)
		music_row.value_changed.connect(func(val): Settings.music_volume = val)
		music_row.mute_toggled.connect(func(val): Settings.music_muted = val)
		sfx_row.value_changed.connect(func(val): Settings.sfx_volume = val)
		sfx_row.mute_toggled.connect(func(val): Settings.sfx_muted = val)

		# Connect this screen to the Settings singleton to update visuals
		Settings.audio_settings_changed.connect(_update_ui_from_settings)
		_update_ui_from_settings()  # Set initial state

		back_button.pressed.connect(_on_back_button_pressed)

		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		# NOTE: For now, only the back button is focusable with keyboard/controller.
		menu_manager.setup_menu([back_button])

		# --- Connect Feedback Handlers ---
		menu_manager.selection_changed.connect(_on_any_item_focused)
		var interactive_items: Array[Control] = [back_button, mute_button]
		for item in interactive_items:
			item.mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
			item.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))

		await get_tree().process_frame
		back_button.grab_focus()


func _exit_tree() -> void:
	if not Engine.is_editor_hint():
		if Settings.audio_settings_changed.is_connected(_update_ui_from_settings):
			Settings.audio_settings_changed.disconnect(_update_ui_from_settings)


# --- Private Methods ---


func _update_ui_from_settings() -> void:
	# This function now only tells the rows to update themselves.
	# It doesn't know *how* they update.
	if is_instance_valid(master_row):
		master_row.set_slider_value(Settings.master_volume)
		master_row.set_mute_state(Settings.master_muted)
	if is_instance_valid(music_row):
		music_row.set_slider_value(Settings.music_volume)
		music_row.set_mute_state(Settings.music_muted)
	if is_instance_valid(sfx_row):
		sfx_row.set_slider_value(Settings.sfx_volume)
		sfx_row.set_mute_state(Settings.sfx_muted)


# --- Signal Handlers ---


func _on_any_item_focused() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE)


func _on_back_button_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_BACK)
	SceneManager.go_to_scene(AssetPaths.SCENE_OPTIONS_SCREEN)


=====================================
FILE: ./src/scenes/menus/controls_screen.gd
=====================================
# src/scenes/menus/controls_screen.gd
## The controller for the controls display screen.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# --- Node References ---
@onready var back_button: StyledMenuItem = %BackButton


# --- Godot Lifecycle Methods ---
func _ready() -> void:
	back_button.text = "BACK"

	if not Engine.is_editor_hint():
		back_button.pressed.connect(_on_back_button_pressed)

		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		menu_manager.setup_menu([back_button])

		# --- Connect Feedback Handlers ---
		menu_manager.selection_changed.connect(_on_any_item_focused)
		back_button.mouse_entered.connect(CursorManager.set_pointer_state.bind(true))
		back_button.mouse_exited.connect(CursorManager.set_pointer_state.bind(false))

		await get_tree().process_frame
		back_button.grab_focus()


# --- Signal Handlers ---
func _on_any_item_focused() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_MOVE)


func _on_back_button_pressed() -> void:
	AudioManager.play_sfx(AssetPaths.SFX_UI_BACK)
	SceneManager.go_to_scene(AssetPaths.SCENE_OPTIONS_SCREEN)


=====================================
FILE: ./src/scenes/menus/controls_screen.tscn
=====================================
[gd_scene load_steps=6 format=3 uid="uid://df5wylg5n16f"]

[ext_resource type="Script" uid="uid://bm6noor4pxywc" path="res://src/scenes/menus/controls_screen.gd" id="1_controls_script"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]
[ext_resource type="PackedScene" uid="uid://d1g2h3i4j5k6l" path="res://src/ui/components/mute_button/mute_button.tscn" id="4_mute_button"]
[ext_resource type="PackedScene" uid="uid://cgt6j1h2w3k4m" path="res://src/ui/components/control_setting_row/control_setting_row.tscn" id="5_control_row"]

[node name="ControlsScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_controls_script")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 0
alignment = 1

[node name="TopSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 100)
layout_mode = 2

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.972549, 0.972549, 0.972549, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "CONTROLS"
horizontal_alignment = 1

[node name="TitleMenuSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 14.1)
layout_mode = 2

[node name="ControlsVBox" type="VBoxContainer" parent="MainVBox"]
unique_name_in_owner = true
layout_mode = 2
size_flags_horizontal = 4
theme_override_constants/separation = 20
alignment = 1

[node name="ControlSettingRow" parent="MainVBox/ControlsVBox" instance=ExtResource("5_control_row")]
layout_mode = 2
action_text = "Movement"
keys_text = "Arrow Keys / WASD / Mouse"

[node name="ControlSettingRow2" parent="MainVBox/ControlsVBox" instance=ExtResource("5_control_row")]
layout_mode = 2
action_text = "Primary Action"
keys_text = "X / . / Space / Left-Click"

[node name="ControlSettingRow3" parent="MainVBox/ControlsVBox" instance=ExtResource("5_control_row")]
layout_mode = 2
action_text = "Secondary Action"
keys_text = "C / , / Shift / Right-Click"

[node name="ControlSettingRow4" parent="MainVBox/ControlsVBox" instance=ExtResource("5_control_row")]
layout_mode = 2
action_text = "Tertiary Action"
keys_text = "Z / / / Ctrl / Middle-Click"

[node name="ControlSettingRow5" parent="MainVBox/ControlsVBox" instance=ExtResource("5_control_row")]
layout_mode = 2
action_text = "Heal"
keys_text = "Down + Jump"

[node name="ControlSettingRow6" parent="MainVBox/ControlsVBox" instance=ExtResource("5_control_row")]
layout_mode = 2
action_text = "Pause / Menu"
keys_text = "Enter / P / Escape"

[node name="ControlSettingRow7" parent="MainVBox/ControlsVBox" instance=ExtResource("5_control_row")]
layout_mode = 2
action_text = "Back / Cancel"
keys_text = "Escape / Backspace"

[node name="ExpandSpacer" type="Control" parent="MainVBox"]
layout_mode = 2
size_flags_vertical = 3

[node name="BackButton" parent="MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64

[node name="BottomSpacer" type="Control" parent="MainVBox"]
custom_minimum_size = Vector2(0, 80)
layout_mode = 2

[node name="MuteButtonContainer" type="MarginContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
mouse_filter = 2
theme_override_constants/margin_top = 40
theme_override_constants/margin_right = 350

[node name="MuteButton" parent="MuteButtonContainer" instance=ExtResource("4_mute_button")]
layout_mode = 2
size_flags_horizontal = 8
size_flags_vertical = 0


=====================================
FILE: ./src/scenes/game_over/game_over_screen.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://dnlf14n0wfxm1"]

[ext_resource type="Script" uid="uid://dnkj277olbn3c" path="res://src/scenes/game_over/game_over_screen.gd" id="1_goscr"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]

[node name="GameOverScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_goscr")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 100
alignment = 1

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.8, 0.2, 0.2, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "GAME OVER"
horizontal_alignment = 1

[node name="BackButton" parent="MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64


=====================================
FILE: ./src/scenes/game_over/game_over_screen.gd
=====================================
# src/scenes/game_over/game_over_screen.gd
## The controller for the "Game Over" screen.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# --- Node References ---
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	back_button.text = "BACK TO TITLE"

	if not Engine.is_editor_hint():
		back_button.pressed.connect(_on_back_button_pressed)

		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		menu_manager.setup_menu([back_button])

		await get_tree().process_frame
		back_button.grab_focus()


# --- Signal Handlers ---


func _on_back_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)


=====================================
FILE: ./src/scenes/main/main.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://bt1c5p8wphc4a"]

[ext_resource type="Script" uid="uid://cu5lshffdfr4h" path="res://src/scenes/main/main.gd" id="1_main_script"]

[node name="Main" type="Node"]
script = ExtResource("1_main_script")


=====================================
FILE: ./src/scenes/main/main.gd
=====================================
# src/scenes/main/main.gd
## The main entry point for the entire application.
extends Node


func _ready() -> void:
	if OS.is_debug_build():
		AssetPaths.validate_all_paths()

	# THE FIX: Call the static method directly on the global class name.
	# This removes the need for a local constant and resolves the warning.
	BootManager.initialize_systems()

	AudioManager.play_music(AssetPaths.MUSIC_MENU_LOOP)

	SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)


=====================================
FILE: ./src/scenes/victory/victory_screen.tscn
=====================================
[gd_scene load_steps=4 format=3 uid="uid://cx6i2wt2j05y4"]

[ext_resource type="Script" uid="uid://d030qowpraecr" path="res://src/scenes/victory/victory_screen.gd" id="1_vsscr"]
[ext_resource type="PackedScene" uid="uid://cgt63w7k4w5gq" path="res://src/ui/components/styled_menu_item/styled_menu_item.tscn" id="2_styled_menu_item"]
[ext_resource type="FontFile" uid="uid://b41cqy3luy6se" path="res://assets/fonts/font_main_black.ttf" id="3_font_black"]

[node name="VictoryScreen" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_vsscr")

[node name="BackgroundColor" type="ColorRect" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
color = Color(0, 0, 0, 1)

[node name="MainVBox" type="VBoxContainer" parent="."]
layout_mode = 1
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
theme_override_constants/separation = 100
alignment = 1

[node name="TitleLabel" type="Label" parent="MainVBox"]
layout_mode = 2
theme_override_colors/font_color = Color(0.2, 0.8, 0.2, 1)
theme_override_fonts/font = ExtResource("3_font_black")
theme_override_font_sizes/font_size = 128
text = "VICTORY"
horizontal_alignment = 1

[node name="BackButton" parent="MainVBox" instance=ExtResource("2_styled_menu_item")]
unique_name_in_owner = true
custom_minimum_size = Vector2(700, 100)
layout_mode = 2
size_flags_horizontal = 4
focus_mode = 2
text = "BACK"
font_size = 64


=====================================
FILE: ./src/scenes/victory/victory_screen.gd
=====================================
# src/scenes/victory/victory_screen.gd
## The controller for the "Victory" screen.
@tool
extends Control

# --- Constants ---
const MenuManagerScript = preload(AssetPaths.SCRIPT_MENU_MANAGER)

# --- Node References ---
@onready var back_button: StyledMenuItem = %BackButton

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	back_button.text = "BACK TO TITLE"

	if not Engine.is_editor_hint():
		back_button.pressed.connect(_on_back_button_pressed)

		var menu_manager = MenuManagerScript.new()
		add_child(menu_manager)
		menu_manager.setup_menu([back_button])

		await get_tree().process_frame
		back_button.grab_focus()


# --- Signal Handlers ---


func _on_back_button_pressed() -> void:
	SceneManager.go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)


=====================================
FILE: ./src/core/sequencing/sequence_step.gd
=====================================
# src/core/sequencing/sequence_step.gd
@tool
## The abstract base class for all steps in a sequence.
##
## It defines the contract that all steps must follow: an `execute` method.
class_name SequenceStep
extends Resource

# --- Virtual Methods ---


## This method is implemented by all concrete step classes. It contains the
## logic for what the step does. It can return a [Signal] or [Coroutine]
## to make the [Sequencer] pause execution.
func execute(_sequencer_node: Node) -> Variant:
	return null


=====================================
FILE: ./src/core/sequencing/sequence_handle.gd
=====================================
# src/core/sequencing/sequence_handle.gd
## A handle representing a running sequence.
##
## Allows for safe cancellation and emits a signal when the sequence is
## completed or cancelled.
class_name SequenceHandle
extends RefCounted

# --- Signals ---
## Emitted when the sequence finishes or is cancelled.
signal finished

# --- Member Variables ---
var is_running: bool = true

# --- Public Methods ---


## Cancels the execution of the associated sequence.
func cancel() -> void:
	if is_running:
		is_running = false
		finished.emit()


=====================================
FILE: ./src/core/sequencing/sequencer.gd
=====================================
# src/core/sequencing/sequencer.gd
## An autoloaded singleton that runs linear sequences of timed events.
##
## It is used for cinematic moments like boss intros. It tracks all active
## sequences and can safely cancel them, preventing errors during scene transitions.
extends Node

# --- Private Member Variables ---
var _active_handles: Array[SequenceHandle] = []

# --- Public Methods ---


## Executes a series of [SequenceStep] resources and returns a handle.
func run_sequence(steps: Array[SequenceStep]) -> SequenceHandle:
	var handle = SequenceHandle.new()
	_active_handles.append(handle)
	handle.finished.connect(_on_sequence_finished.bind(handle))

	_execute_sequence(steps, handle)
	return handle


## Immediately cancels all running sequences.
func cancel_all() -> void:
	# Iterate over a copy, as cancelling a handle modifies the original array.
	for handle in _active_handles.duplicate():
		handle.cancel()


# --- Private Methods ---


## The core async function that executes the sequence steps.
func _execute_sequence(steps: Array[SequenceStep], handle: SequenceHandle) -> void:
	if steps.is_empty():
		if handle.is_running:
			handle.is_running = false
			handle.finished.emit()
		return

	for step in steps:
		if not handle.is_running:
			return  # Stop if cancelled

		if not step is SequenceStep:
			push_warning("Sequencer: Invalid step found. Skipping.")
			continue

		var awaitable = await step.execute(self)
		if awaitable:
			await awaitable

	if handle.is_running:
		handle.is_running = false
		handle.finished.emit()


# --- Signal Handlers ---


## Cleans up a finished or cancelled sequence from the tracking array.
func _on_sequence_finished(handle_to_remove: SequenceHandle) -> void:
	var index = _active_handles.find(handle_to_remove)
	if index != -1:
		_active_handles.remove_at(index)


=====================================
FILE: ./src/core/sequencing/steps/emit_step.gd
=====================================
# src/core/sequencing/steps/emit_step.gd
@tool
## A sequence step that emits an event on the global [EventBus].
class_name EmitStep
extends SequenceStep

# --- Editor Properties ---
@export var event_name: StringName = &""
@export var payload: Variant = null

# --- Virtual Methods ---


func execute(_sequencer_node: Node) -> Variant:
	if event_name == &"":
		push_warning("EmitStep: 'event_name' is not set.")
		return null
	EventBus.emit(event_name, payload)
	return null


=====================================
FILE: ./src/core/sequencing/steps/callable_step.gd
=====================================
# src/core/sequencing/steps/callable_step.gd
@tool
## A sequence step that executes a [Callable].
class_name CallableStep
extends SequenceStep

# --- Editor Properties ---
@export var callable: Callable

# --- Virtual Methods ---


func execute(_sequencer_node: Node) -> Variant:
	if callable.is_valid():
		# Await the result of the call. If the function is async, this will
		# pause the sequence until it completes.
		var result = await callable.call()
		# If the function itself returns ANOTHER awaitable (like a Signal),
		# return it to the sequencer to be awaited as well.
		if result is Signal or (typeof(result) == TYPE_OBJECT and result.has_method("is_valid")):
			return result
	else:
		push_warning("CallableStep: 'callable' is not set or is invalid.")

	return null


=====================================
FILE: ./src/core/sequencing/steps/wait_step.gd
=====================================
# src/core/sequencing/steps/wait_step.gd
@tool
## A sequence step that pauses execution for a set duration.
class_name WaitStep
extends SequenceStep

# --- Editor Properties ---
@export var duration: float = 1.0

# --- Virtual Methods ---


func execute(sequencer_node: Node) -> Variant:
	if duration > 0.0:
		# Return the timer's 'timeout' signal for the sequencer to await.
		return sequencer_node.get_tree().create_timer(duration).timeout
	return null


=====================================
FILE: ./src/core/boot/boot_manager.gd
=====================================
# src/core/boot/boot_manager.gd
## A stateless utility responsible for orchestrating the initialization of
## core game systems in a predictable order.
class_name BootManager
extends RefCounted

## Finds all necessary autoloads and calls their initialization methods.
static func initialize_systems() -> void:
	var scene_tree: SceneTree = Engine.get_main_loop() as SceneTree
	if not is_instance_valid(scene_tree):
		push_error("BootManager: Could not get valid SceneTree.")
		return

	var root_node: Node = scene_tree.root
	if not is_instance_valid(root_node):
		push_error("BootManager: Could not get SceneTree's root node.")
		return

	# Tell the ObjectPool to create all its initial instances.
	var object_pool: Node = root_node.get_node("/root/ObjectPool")
	if is_instance_valid(object_pool) and object_pool.has_method("initialize"):
		object_pool.initialize()

	# TODO: Add other systems here as needed (e.g., pre-caching assets).


=====================================
FILE: ./src/core/util/combat_utils.gd
=====================================
# src/core/util/combat_utils.gd
## An autoloaded singleton containing static helper functions for combat logic.
extends Node

## Traverses up the scene tree from a given node to find its root BaseEntity.
func find_entity_root(from_node: Node) -> BaseEntity:
	if not is_instance_valid(from_node):
		return null
	
	var current_node = from_node
	while is_instance_valid(current_node):
		if current_node is BaseEntity:
			return current_node
		current_node = current_node.get_parent()
		
	return null

## Finds the IDamageable component on a target node by first finding the
## target's entity root, then asking for the component.
func find_damageable(from_node: Node) -> IDamageable:
	var entity: BaseEntity = find_entity_root(from_node)
	if is_instance_valid(entity):
		return entity.get_component(IDamageable)
	
	# Fallback for non-entity damageable nodes (e.g., a simple damageable prop)
	if from_node is IDamageable:
		return from_node
		
	return null

=====================================
FILE: ./src/core/util/service_locator.gd
=====================================
# src/core/util/service_locator.gd
## A central, autoloaded singleton that provides clean, type-safe access
## to all other core systems (services). This avoids passing around messy
## dictionaries for dependency injection.
extends Node

# --- Constants ---
const COMBAT_CONFIG = preload("res://src/data/combat_config.tres")

# --- Service References ---
@onready var fx_manager: IFXManager = get_node("/root/FXManagerAdapter")
@onready var object_pool: IObjectPool = get_node("/root/ObjectPoolAdapter")
@onready var event_bus: EventBus = get_node("/root/EventBus")
@onready var sequencer: Sequencer = get_node("/root/Sequencer")
@onready var combat_utils: CombatUtils = get_node("/root/CombatUtils")
@onready var grid_utils: GridUtils = get_node("/root/GridUtils")

# --- Public Properties ---
var combat_config: CombatConfig = COMBAT_CONFIG


=====================================
FILE: ./src/core/util/grid_utils.gd
=====================================
# src/core/util/grid_utils.gd
## An autoloaded singleton providing a single source of truth for all conversions
## between the logical tile grid and world-space pixel coordinates.
extends Node

## Converts a grid coordinate (e.g., [Vector2i(2, 3)]) to a world position.
func grid_to_world(tile_pos: Vector2i, tile_size: int = Constants.TILE_SIZE) -> Vector2:
	var half_tile = tile_size / 2.0
	return Vector2(tile_pos.x * tile_size + half_tile, tile_pos.y * tile_size + half_tile)


## Converts a world position (in pixels) to its corresponding grid coordinate.
func world_to_grid(world_pos: Vector2, tile_size: int = Constants.TILE_SIZE) -> Vector2i:
	return Vector2i(floor(world_pos.x / tile_size), floor(world_pos.y / tile_size))

=====================================
FILE: ./src/core/util/dependency_validator.gd
=====================================
# src/core/util/dependency_validator.gd
## A stateless utility for validating component dependencies at runtime.
class_name DependencyValidator
extends RefCounted

## Validates that a dictionary of dependencies contains a set of required keys.
## If a key is missing, it pushes a descriptive error.
## Returns 'true' if validation passes, 'false' otherwise.
static func validate(component: IComponent, dependencies: Dictionary, required_keys: Array[String]) -> bool:
	var component_script_path = component.get_script().resource_path
	var component_name = component_script_path.get_file()

	for key in required_keys:
		if not dependencies.has(key):
			var error_msg = "Component '%s' is missing required dependency: '%s'" % [component_name, key]
			push_error(error_msg)
			return false
	return true


=====================================
FILE: ./src/core/util/physics_layers.gd
=====================================
# src/core/util/physics_layers.gd
## An autoloaded singleton that provides named constants for the 2D physics
## layers defined in the project settings.
##
## This prevents the use of "magic numbers" for collision layers and masks.
extends Node

# --- Layer Constants ---
const PLAYER = 1  # Layer 1
const PLATFORMS = 2  # Layer 2
const ENEMY = 4  # Layer 3
const HAZARD = 8  # Layer 4
const ENEMY_PROJECTILE = 16  # Layer 5
const PLAYER_HITBOX = 32  # Layer 6
const PLAYER_HURTBOX = 64  # Layer 7
const SOLID_WORLD = 128  # Layer 8


=====================================
FILE: ./src/core/util/scene_validator.gd
=====================================
# src/core/util/scene_validator.gd
@tool
## A central utility for validating scene configurations in the editor.
##
## Its functions are static, allowing them to be called from any @tool script
## to provide configuration warnings in the Godot editor.
class_name SceneValidator
extends Object

# --- Static Validation Functions ---


## Validates a node to ensure it meets the BaseBoss contract.
static func validate_boss_scene(node: Node) -> PackedStringArray:
	var warnings = PackedStringArray()

	if not node.has_node("HealthComponent"):
		warnings.append("A HealthComponent node is required.")
	if not node.has_node("StateMachine"):
		warnings.append("A StateMachine node is required.")
	if not node.has_node("ArmorComponent"):
		warnings.append("An ArmorComponent node is required.")

	if node.get("phase_1_patterns") == null or node.get("phase_1_patterns").is_empty():
		warnings.append(
			"Phase 1 has no attack patterns assigned. The boss will be unable to attack."
		)

	return warnings


=====================================
FILE: ./src/core/util/palette.gd
=====================================
# src/core/util/palette.gd
## An autoloaded singleton that holds the project's master color palette.
##
## It establishes a single source of truth for all visual elements, ensuring a
## cohesive aesthetic based on a 32-step grayscale value scale.
extends Node

# --- Private Member Variables ---
const _palette: Array[Color] = [
	Color("#000000"),
	Color("#080808"),
	Color("#101010"),
	Color("#191919"),
	Color("#212121"),
	Color("#292929"),
	Color("#313131"),
	Color("#3a3a3a"),
	Color("#424242"),
	Color("#4a4a4a"),
	Color("#525252"),
	Color("#5a5a5a"),
	Color("#636363"),
	Color("#6b6b6b"),
	Color("#737373"),
	Color("#7b7b7b"),
	Color("#848484"),
	Color("#8c8c8c"),
	Color("#949494"),
	Color("#9c9c9c"),
	Color("#a5a5a5"),
	Color("#adadad"),
	Color("#b5b5b5"),
	Color("#bdbdbd"),
	Color("#c5c5c5"),
	Color("#cecece"),
	Color("#d6d6d6"),
	Color("#dedede"),
	Color("#e6e6e6"),
	Color("#efefef"),
	Color("#f7f7f7"),
	Color("#ffffff")
]

# --- Semantic Constants ---
# Use these constants in code, not raw palette indices.
# This makes the code readable and easy to theme.

# Gameplay
const COLOR_PLAYER: Color = _palette[31]
const COLOR_BOSS_PRIMARY: Color = _palette[30]
const COLOR_PLAYER_PROJECTILE: Color = _palette[29]
const COLOR_HAZARD_PRIMARY: Color = _palette[28]  # Also Enemy Projectiles

# Environment
const COLOR_BACKGROUND: Color = _palette[0]
const COLOR_GRID: Color = _palette[2]
const COLOR_TERRAIN_PRIMARY: Color = _palette[4]
const COLOR_TERRAIN_SECONDARY: Color = _palette[6]

# UI/UX
const COLOR_TEXT_HEADER: Color = _palette[30]
const COLOR_UI_ACCENT_PRIMARY: Color = _palette[28]
const COLOR_TEXT_PRIMARY: Color = _palette[26]
const COLOR_TEXT_DISABLED: Color = _palette[16]
const COLOR_UI_GLOW: Color = _palette[20]
const COLOR_UI_PANEL_BG: Color = _palette[8]


# --- Public Methods ---
## Provides a safe way to get a color by its raw index if needed.
func get_color(index: int) -> Color:
	if index >= 0 and index < _palette.size():
		return _palette[index]
	push_warning("Palette: Invalid color index requested: %d" % index)
	return Color.MAGENTA  # Return a highly visible error color


=====================================
FILE: ./src/core/util/identifiers.gd
=====================================
# src/core/util/identifiers.gd
## An autoloaded singleton that provides a central authority for all string-based
## identifiers used in the project, such as group names and pool keys.
##
## Using these constants prevents bugs caused by typos in raw strings.
extends Node


## A container for all physics group names.
## Usage: Identifiers.Groups.PLAYER
class Groups:
	const PLAYER = "player"
	const ENEMY = "enemy"
	const WORLD = "world"
	const HAZARD = "hazard"
	const ONEWAY_PLATFORMS = "oneway_platforms"
	const PLAYER_PROJECTILE = "player_projectile"
	const ENEMY_PROJECTILE = "enemy_projectile"


## A container for all ObjectPool keys.
## Usage: Identifiers.Pools.PLAYER_SHOTS
class Pools:
	const PLAYER_SHOTS = &"player_shots"
	const BOSS_SHOTS = &"boss_shots"
	const TURRET_SHOTS = &"turret_shots"
	const HOMING_BOSS_SHOTS = &"homing_boss_shots"
	const HIT_SPARKS = &"hit_sparks"


## Container for all Player state keys.
class PlayerStates:
	const MOVE = &"move"
	const JUMP = &"jump"
	const FALL = &"fall"
	const DASH = &"dash"
	const WALL_SLIDE = &"wall_slide"
	const ATTACK = &"attack"
	const HURT = &"hurt"
	const HEAL = &"heal"
	const POGO = &"pogo"


## Container for all Boss state keys.
class BossStates:
	const IDLE = &"idle"
	const ATTACK = &"attack"
	const COOLDOWN = &"cooldown"
	const PATROL = &"patrol"
	const LUNGE = &"lunge"


## Container for all Minion state keys.
class MinionStates:
	const IDLE = &"idle"
	const ATTACK = &"attack"

=====================================
FILE: ./src/core/util/asset_paths.gd
=====================================
# src/core/util/asset_paths.gd
## An autoloaded singleton containing verified, static paths to all critical assets.
##
## Using these constants prevents runtime errors from typos in string paths and
## provides a central place to manage asset locations. Includes a validation
## system to check for missing files at startup in debug builds.
extends Node

# --- CORE SYSTEMS ---
const SCRIPT_COMBAT_UTILS = "res://src/core/util/combat_utils.gd"
const SCENE_MAIN = "res://src/scenes/main/main.tscn"
const SCENE_ENCOUNTER = "res://src/scenes/game/encounter_scene.tscn"
const SCENE_LOADING_SCREEN = "res://src/scenes/loading/loading_screen.tscn"
const SCRIPT_MENU_MANAGER = "res://src/ui/menu_manager/menu_manager.gd"
const SCRIPT_CUSTOM_SLIDER = "res://src/ui/components/custom_slider/custom_slider.gd"

# --- DATA ---
const ENCOUNTER_00 = "res://src/data/encounters/encounter_00.tres"

# --- PLAYER & RELATED ---
const SCENE_PLAYER = "res://src/entities/player/player.tscn"
const SCENE_PLAYER_SHOT = "res://src/projectiles/player_shot.tscn"

# --- BOSS, MINIONS & RELATED ---
const SCENE_BASE_BOSS = "res://src/entities/boss/base_boss.tscn"
const SCENE_BOSS_SHOT = "res://src/projectiles/boss_shot.tscn"
const SCENE_HOMING_BOSS_SHOT = "res://src/projectiles/homing_boss_shot.tscn"
const SCENE_TELEGRAPH_COMPONENT = "res://src/entities/components/telegraph_component.tscn"
const SCENE_MINION = "res://src/entities/minions/minion.tscn"
const SCENE_MINION_SHOT = "res://src/projectiles/turret_shot.tscn" # This path is still correct

# --- UI & SCENES ---
const SCENE_GAME_HUD = "res://src/ui/game_hud/game_hud.tscn"
const SCENE_GAME_OVER_SCREEN = "res://src/scenes/game_over/game_over_screen.tscn"
const SCENE_VICTORY_SCREEN = "res://src/scenes/victory/victory_screen.tscn"
const SCENE_TITLE_SCREEN = "res://src/scenes/menus/title_screen.tscn"
const SCENE_OPTIONS_SCREEN = "res://src/scenes/menus/options_screen.tscn"
const SCENE_SOUND_SCREEN = "res://src/scenes/menus/sound_screen.tscn"
const SCENE_CONTROLS_SCREEN = "res://src/scenes/menus/controls_screen.tscn"
const SCENE_CREDITS_SCREEN = "res://src/scenes/menus/credits_screen.tscn"

# --- UI COMPONENTS ---
const SCENE_STYLED_MENU_ITEM = "res://src/ui/components/styled_menu_item/styled_menu_item.tscn"
const SCENE_LOGO_DISPLAY = "res://src/ui/components/logo_display/logo_display.tscn"
const SCENE_MUTE_BUTTON = "res://src/ui/components/mute_button/mute_button.tscn"
const SCENE_CONTROL_SETTING_ROW = "res://src/ui/components/control_setting_row/control_setting_row.tscn"

# --- DEV TOOLS ---
const SCENE_DEBUG_OVERLAY = "res://src/ui/dev/debug_overlay.tscn"

# --- VFX ---
const SCENE_HIT_SPARK = "res://src/vfx/hit_spark.tscn"

# --- SPRITES & ICONS ---
const SPRITE_CURSOR_DEFAULT = "res://assets/sprites/ui/cursors/sprite_cursor_default.png"
const SPRITE_CURSOR_POINTER = "res://assets/sprites/ui/cursors/sprite_cursor_pointer.png"
const SPRITE_SLIDER_TRACK = "res://assets/sprites/ui/slider/slider-track.png"
const SPRITE_SLIDER_KNOB = "res://assets/sprites/ui/slider/slider-knob.png"
const SPRITE_CHECKBOX_CHECKED = "res://assets/sprites/ui/checkbox/checkbox-checked.png"
const SPRITE_CHECKBOX_UNCHECKED = "res://assets/sprites/ui/checkbox/checkbox-unchecked.png"
const ICON_UI_SOUND_ON = "res://assets/sprites/ui/icons/icon_ui_sound_on.png"
const ICON_UI_SOUND_OFF = "res://assets/sprites/ui/icons/icon_ui_sound_off.png"

# --- FONTS ---
const FONT_MAIN_BLACK = "res://assets/fonts/font_main_black.ttf"
const FONT_MAIN_BOLD = "res://assets/fonts/font_main_bold.ttf"
const FONT_MAIN_REGULAR = "res://assets/fonts/font_main_regular.ttf"

# --- AUDIO ---
const MUSIC_MENU_LOOP = "res://assets/audio/music/music_menu_loop.mp3"
const SFX_UI_BACK = "res://assets/audio/sfx/sfx_ui_back.mp3"
const SFX_UI_ERROR = "res://assets/audio/sfx/sfx_ui_error.mp3"
const SFX_UI_MOVE = "res://assets/audio/sfx/sfx_ui_move.mp3"
const SFX_UI_SELECT = "res://assets/audio/sfx/sfx_ui_select.mp3"
const SFX_GAME_START = "res://assets/audio/sfx/sfx_game_start.mp3"


# --- Validation System ---
## Checks all defined paths to ensure the files exist on disk.
func validate_all_paths() -> void:
	print("AssetPaths: Validating all asset paths...")
	var constants = get_script().get_script_constant_map()
	var missing_assets = false

	for key in constants:
		var value = constants[key]
		if value is String and value.begins_with("res://"):
			if not FileAccess.file_exists(value):
				push_error(
					"Asset path validation failed! File not found for '%s': %s" % [key, value]
				)
				missing_assets = true

	if not missing_assets:
		print("AssetPaths: All paths validated successfully.")


=====================================
FILE: ./src/core/util/constants.gd
=====================================
# src/core/util/constants.gd
## An autoloaded singleton for true global constants that define the
## project's foundational architecture or core system limits.
##
## GUIDELINE: Only add values here that are fundamental and unlikely to
## ever change. Gameplay tuning values belong in [CombatConfig].
extends Node

# --- Audio ---
## The number of simultaneous sound effects that can be played at once.
const NUM_SFX_PLAYERS = 8

# --- Arena Design ---
## The universal size (width and height) of a single grid tile in pixels.
const TILE_SIZE = 50


=====================================
FILE: ./src/core/README.md
=====================================
# Core Subsystem

This directory contains all of the project's global systems, singletons, and core logic that is not specific to a single entity or scene.

## Subdirectories

-   **/building**: Contains the classes responsible for procedural level generation (`ArenaBuilder`, `LevelParser`, etc.).
-   **/data**: Manages game data, including the new `Resource`-based configurations.
-   **/events**: Contains the global `EventBus` and all typed event definitions.
-   **/sequencing**: Manages the `Sequencer` for creating scripted, timed events.
-   **/systems**: Contains the primary global managers (`AudioManager`, `GameManager`, etc.).
-   **/util**: A collection of stateless utility singletons like `AssetPaths` and `Palette`.

## Autoloaded Singletons (Global Access)

The following scripts are registered as autoloads in `project.godot` and can be accessed globally:

-   `Settings`: Manages persistent game settings.
-   `AudioManager`: Controls all audio playback.
-   `CursorManager`: Manages the custom mouse cursor.
-   `Constants`: Holds engine-level constants.
-   `AssetPaths`: Provides safe, static paths to all project assets.
-   `GlobalHud`: The persistent UI layer for global elements.
-   `GameManager`: Manages game state and scene flow.
-   `ArenaBuilder`: The main entry point for level construction.
-   `EventBus`: The global event dispatcher.
-   `Sequencer`: Manages timed event sequences.
-   `Config`: Handles loading data from `Resource`-based configs.
-   `Palette`: Defines the global color scheme.
-   `ObjectPool`: Manages reusable nodes to improve performance.
-   `PhysicsLayers`: Provides named constants for physics collision layers.

## Public API

The primary public API for inter-system communication is the `EventBus`. Systems should emit events to signal state changes and listen for events to react to them, rather than calling each other directly.

=====================================
FILE: ./src/core/events/event_bus.gd
=====================================
# src/core/events/event_bus.gd
## An autoloaded singleton that provides a global event dispatch system.
##
## This allows for loosely-coupled communication between disparate parts of the
## codebase, such as between gameplay systems and the UI.
extends Node

# --- Private Member Variables ---
var _subscribers: Dictionary = {}
var _by_id: Dictionary = {}
var _next_id: int = 1

# --- Godot Lifecycle Methods ---


func _exit_tree() -> void:
	# Clear all subscriptions to break potential cyclic references on exit.
	_subscribers.clear()
	_by_id.clear()


# --- Public Methods ---


## Subscribes a callback to a specific event. Returns a token ID for unsubscribing.
func on(event_name: StringName, callback: Callable) -> int:
	assert(callback.is_valid(), "EventBus.on: callback must be a valid Callable")

	var subs: Array = _subscribers.get(event_name, [])
	var owner_node = callback.get_object()
	var weak_ref = weakref(owner_node) if owner_node is Node else null

	var entry := {
		"id": _next_id,
		"callback": callback,
		"owner_weak": weak_ref,
	}
	subs.append(entry)
	_subscribers[event_name] = subs

	_by_id[_next_id] = event_name  # Map the token ID back to the event name
	_next_id += 1
	return entry.id


## Unsubscribes from an event using the token returned by on().
func off(token: int) -> void:
	if not _by_id.has(token):
		return

	var event_name: StringName = _by_id[token]
	if _subscribers.has(event_name):
		var subs = _subscribers[event_name]
		for i in range(subs.size() - 1, -1, -1):
			if subs[i].id == token:
				subs.remove_at(i)
				break
		if subs.is_empty():
			_subscribers.erase(event_name)

	_by_id.erase(token)


## Emits an event to all subscribers.
func emit(event_name: StringName, payload = null) -> void:
	if not _subscribers.has(event_name):
		return

	var subs: Array = _subscribers[event_name]
	# Iterate backwards to safely remove dead references during the loop.
	for i in range(subs.size() - 1, -1, -1):
		var sub = subs[i]

		# Auto-prune subscriptions whose owner nodes have been freed.
		if sub.owner_weak and not sub.owner_weak.get_ref():
			_by_id.erase(sub.id)
			subs.remove_at(i)
			continue

		sub.callback.call(payload)

	if subs.is_empty():
		_subscribers.erase(event_name)


=====================================
FILE: ./src/core/events/typed_events/boss_health_changed_event.gd
=====================================
# src/core/events/typed_events/boss_health_changed_event.gd
## A typed payload for the [constant EventCatalog.BOSS_HEALTH_CHANGED] event.
class_name BossHealthChangedEvent
extends Resource

@export var current_health: int = 0
@export var max_health: int = 0


=====================================
FILE: ./src/core/events/typed_events/player_health_changed_event.gd
=====================================
# src/core/events/typed_events/player_health_changed_event.gd
## A typed payload for the [constant EventCatalog.PLAYER_HEALTH_CHANGED] event.
class_name PlayerHealthChangedEvent
extends Resource

@export var current_health: int = 0
@export var max_health: int = 0


=====================================
FILE: ./src/core/events/typed_events/player_healing_charges_changed_event.gd
=====================================
# src/core/events/typed_events/player_healing_charges_changed_event.gd
## A typed payload for the [constant EventCatalog.PLAYER_HEALING_CHARGES_CHANGED] event.
class_name PlayerHealingChargesChangedEvent
extends Resource

@export var current_charges: int = 0


=====================================
FILE: ./src/core/events/event_catalog.gd
=====================================
# src/core/events/event_catalog.gd
## A central, canonical list of all event names in the project.
##
## By using these constants instead of raw strings (e.g., [code]EventBus.emit(EventCatalog.PLAYER_DIED)[/code]),
## we gain IDE autocompletion and prevent typos that lead to silent runtime failures.
class_name EventCatalog
extends Object

# --- Player Events ---
const PLAYER_HEALTH_CHANGED = "player.health_changed"
const PLAYER_HEALING_CHARGES_CHANGED = "player.healing_charges_changed"

# --- Boss / Entity Events ---
const BOSS_HEALTH_CHANGED = "boss.health_changed"
const BOSS_DIED = "boss.died"
const BOSS_PHASE_CHANGED = "boss.phase_changed"

# --- Game State Events ---
const SCENE_TRANSITION_STARTED = "scene.transition_started"

# --- UI State Events ---
const MENU_OPENED = "ui.menu_opened"
const MENU_CLOSED = "ui.menu_closed"


=====================================
FILE: ./src/core/systems/camera_shaker.gd
=====================================
# src/core/systems/camera_shaker.gd
## A self-contained component that applies a procedural shake to a target Camera2D.
##
## It uses Perlin noise to generate a smooth, decaying shake effect by manipulating
## the target camera's `offset` property.
class_name CameraShaker
extends Node

# --- Public Member Variables ---
## A reference to the Camera2D node this shaker will control.
var target_camera: Camera2D = null

# --- Private Member Variables ---
var _noise := FastNoiseLite.new()
var _noise_y_offset: float = 0.0  # Use a different seed for the y-axis
var _shake_duration: float = 0.0
var _shake_timer: float = 0.0
var _shake_amplitude: float = 0.0
var _shake_frequency: float = 0.0

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	_noise.noise_type = FastNoiseLite.TYPE_PERLIN
	_noise.seed = randi()
	_noise_y_offset = randf() * 1000.0


func _process(delta: float) -> void:
	if not is_instance_valid(target_camera):
		return

	if _shake_timer > 0:
		_shake_timer -= delta
		if _shake_timer <= 0:
			target_camera.offset = Vector2.ZERO
		else:
			var decay_progress: float = 1.0 - (_shake_timer / _shake_duration)
			var current_amplitude: float = _shake_amplitude * (1.0 - decay_progress)

			var time: float = Time.get_ticks_msec() * (_shake_frequency / 1000.0)
			var noise_x: float = _noise.get_noise_2d(time, 0)
			var noise_y: float = _noise.get_noise_2d(time, _noise_y_offset)

			target_camera.offset.x = noise_x * current_amplitude
			target_camera.offset.y = noise_y * current_amplitude
	else:
		target_camera.offset = Vector2.ZERO


# --- Public API ---


func start_shake(effect: ScreenShakeEffect) -> void:
	if not is_instance_valid(effect):
		push_error("CameraShaker: Invalid ScreenShakeEffect resource provided.")
		return

	_shake_amplitude = effect.amplitude
	_shake_frequency = effect.frequency
	_shake_duration = effect.duration
	_shake_timer = _shake_duration


=====================================
FILE: ./src/core/systems/camera_manager.gd
=====================================
# src/core/systems/camera_manager.gd
## An autoloaded singleton responsible for all camera logic.
extends Node

# --- Public Methods ---


## Centers the camera on the arena for a pixel-perfect setup.
func center_camera_on_arena(camera: Camera2D, arena_size_tiles: Vector2i) -> void:
	if not is_instance_valid(camera):
		push_error("CameraManager: Invalid Camera2D provided.")
		return

	var arena_pixel_size = Vector2(arena_size_tiles) * Constants.TILE_SIZE
	camera.position = arena_pixel_size / 2.0


=====================================
FILE: ./src/core/systems/pool_bindings/object_pool_adapter.gd
=====================================
# src/core/systems/pool_bindings/object_pool_adapter.gd
## An adapter that implements the IObjectPool interface by delegating calls
## to the real ObjectPool autoload singleton.
extends IObjectPool

# --- Private Member Variables ---
var _real_object_pool: Node

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	_real_object_pool = get_node("/root/ObjectPool")
	assert(is_instance_valid(_real_object_pool), "ObjectPoolAdapter could not find /root/ObjectPool")

# --- IObjectPool Implementation ---

func get_instance(pool_name: StringName) -> Node:
	return _real_object_pool.get_instance(pool_name)

func return_instance(instance: Node) -> void:
	_real_object_pool.return_instance(instance)

func reset() -> void:
	_real_object_pool.reset()

func get_pool_stats() -> Dictionary:
	return _real_object_pool.get_pool_stats()

=====================================
FILE: ./src/core/systems/dialogue_manager.gd
=====================================
# src/core/systems/dialogue_manager.gd
## An autoloaded singleton for managing and displaying dialogue.
##
## It is responsible for loading [DialogueData] resources and commanding
## a UI scene to display the conversation line by line.
extends Node

signal conversation_started(dialogue_data)
signal line_shown(line_index, line: DialogueLine)
signal conversation_ended

const DialogueBoxScene = preload("res://src/ui/dialogue/dialogue_box.tscn")

var _current_data: DialogueData
var _current_index: int = -1
var _dialogue_box_instance: DialogueBox
var _ui_layer: CanvasLayer
var _scene_transition_token: int


func _ready() -> void:
	_ui_layer = CanvasLayer.new()
	_ui_layer.layer = 10
	_ui_layer.name = "DialogueUILayer"

	_dialogue_box_instance = DialogueBoxScene.instantiate()
	_dialogue_box_instance.visible = false

	_ui_layer.add_child.call_deferred(_dialogue_box_instance)
	get_tree().get_root().add_child.call_deferred(_ui_layer)

	_dialogue_box_instance.advance_requested.connect(_on_dialogue_box_advance_requested)
	_dialogue_box_instance.typing_finished.connect(_on_typing_finished)

	_scene_transition_token = EventBus.on(
		EventCatalog.SCENE_TRANSITION_STARTED, func(_payload): end_conversation()
	)


func _exit_tree() -> void:
	# Ensure we unsubscribe from the global event bus when the game closes.
	EventBus.off(_scene_transition_token)


## Checks if a conversation is currently active.
func is_conversation_active() -> bool:
	return is_instance_valid(_current_data)


## Starts a conversation using the data from a [DialogueData] resource.
func start_conversation(data: DialogueData) -> void:
	if not is_instance_valid(data) or data.lines.is_empty():
		push_error("DialogueManager: Attempted to start conversation with invalid or empty data.")
		return

	end_conversation()

	_current_data = data
	_current_index = 0

	_dialogue_box_instance.visible = true
	conversation_started.emit(data)
	_show_current_line()


## Ends the current conversation and hides the UI.
func end_conversation() -> void:
	if not is_instance_valid(_current_data):
		return

	_dialogue_box_instance.visible = false
	_current_data = null
	_current_index = -1
	conversation_ended.emit()


# --- Private Methods ---


func _show_current_line() -> void:
	if (
		not is_instance_valid(_current_data)
		or _current_index < 0
		or _current_index >= _current_data.lines.size()
	):
		end_conversation()
		return

	var line = _current_data.lines[_current_index]
	_dialogue_box_instance.display_line(line)
	line_shown.emit(_current_index, line)


func _advance_to_next_line() -> void:
	_current_index += 1
	if _current_index >= _current_data.lines.size():
		end_conversation()
	else:
		_show_current_line()


# --- Signal Handlers ---


func _on_dialogue_box_advance_requested() -> void:
	_advance_to_next_line()


func _on_typing_finished() -> void:
	# THE FIX: Add a guard clause to prevent crash during scene transitions.
	if not is_instance_valid(_current_data):
		return

	var line = _current_data.lines[_current_index]
	if line.wait_after > 0.0:
		await get_tree().create_timer(line.wait_after).timeout


=====================================
FILE: ./src/core/systems/game_manager.gd
=====================================
# src/core/systems/game_manager.gd
## An autoloaded singleton that manages the state of the game session.
##
## It holds a reference to a [GameStateData] resource, which acts as the
## single source of truth for all runtime session data.
extends Node

# --- Constants ---
const GameStateDataScript = preload("res://src/core/data/game_state_data.gd")

# --- Public Member Variables ---
## The active [GameStateData] resource for the current session.
var state: GameStateData = null

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	# Create a new, clean instance of the game state every time the
	# GameManager is initialized at game startup.
	state = GameStateDataScript.new()


func _exit_tree() -> void:
	# Manually release our reference to the state resource. This allows
	# Godot's garbage collector to free it, preventing memory leaks on exit.
	if is_instance_valid(state):
		state = null


=====================================
FILE: ./src/core/systems/scene_manager.gd
=====================================
# src/core/systems/scene_manager.gd
## A centralized singleton for handling all scene transitions.
##
## This provides a robust, single API for navigation and ensures that
## necessary cleanup (like resetting the ObjectPool) happens automatically.
extends Node

# --- Public API ---


## Generic method to transition to any scene by its path.
func go_to_scene(path: String) -> void:
	_switch_to_scene(path)


## Transitions to the main title screen.
func go_to_title_screen() -> void:
	go_to_scene(AssetPaths.SCENE_TITLE_SCREEN)


## Starts a new game with a specific encounter.
func start_game(encounter_path: String) -> void:
	GameManager.state.current_encounter_path = encounter_path
	go_to_scene(AssetPaths.SCENE_LOADING_SCREEN)


## Transitions to the game over screen.
func go_to_game_over() -> void:
	go_to_scene(AssetPaths.SCENE_GAME_OVER_SCREEN)


## Transitions to the victory screen.
func go_to_victory() -> void:
	go_to_scene(AssetPaths.SCENE_VICTORY_SCREEN)


# --- Private Methods ---


## The core scene-switching logic.
func _switch_to_scene(path: String) -> void:
	# --- Announce Pre-Transition Cleanup ---
	EventBus.emit(EventCatalog.SCENE_TRANSITION_STARTED)

	# 1. Call the formal teardown method on the current scene controller if it exists.
	var current_scene = get_tree().current_scene
	if is_instance_valid(current_scene) and current_scene.has_method("scene_exiting"):
		await current_scene.scene_exiting()

	# 2. Reset global systems.
	ObjectPool.reset() # THE FIX: Call the global singleton directly for this core task.
	Sequencer.cancel_all()

	# 3. Change the scene.
	get_tree().call_deferred("change_scene_to_file", path)

=====================================
FILE: ./src/core/systems/object_pool.gd
=====================================
# src/core/systems/object_pool.gd
## An autoloaded singleton that manages pools of reusable nodes.
##
## This system prevents performance degradation (stutter) from frequent
## instantiation and deletion of nodes like projectiles and visual effects.
extends Node

# --- Private Member Variables ---
var _pools: Dictionary = {}
var _is_initialized: bool = false

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	# Per SRP, _ready() should be lightweight. Heavy lifting is moved to initialize().
	pass


func _exit_tree() -> void:
	for i in range(get_child_count() - 1, -1, -1):
		var child: Node = get_child(i)
		for j in range(child.get_child_count() - 1, -1, -1):
			child.get_child(j).free()
		child.free()
	_pools.clear()


# --- Public Methods ---


## THE FIX: This new method contains the heavy initialization logic.
## It is now called explicitly by the BootManager.
func initialize() -> void:
	if _is_initialized:
		return
	_create_pool_from_path(Identifiers.Pools.PLAYER_SHOTS, AssetPaths.SCENE_PLAYER_SHOT, 15)
	_create_pool_from_path(Identifiers.Pools.BOSS_SHOTS, AssetPaths.SCENE_BOSS_SHOT, 30)
	# THE FIX: Use the new SCENE_MINION_SHOT constant.
	_create_pool_from_path(Identifiers.Pools.TURRET_SHOTS, AssetPaths.SCENE_MINION_SHOT, 20)
	_create_pool_from_path(Identifiers.Pools.HOMING_BOSS_SHOTS, AssetPaths.SCENE_HOMING_BOSS_SHOT, 40)
	_create_pool_from_path(Identifiers.Pools.HIT_SPARKS, AssetPaths.SCENE_HIT_SPARK, 25)
	_is_initialized = true


func get_pool_stats() -> Dictionary:
	var stats: Dictionary = {}
	for pool_name in _pools:
		var pool: Dictionary = _pools[pool_name]
		var total_count: int = pool.container.get_child_count()
		var inactive_count: int = pool.inactive.size()
		stats[pool_name] = {"active": total_count - inactive_count, "total": total_count}
	return stats


func reset() -> void:
	for pool_name in _pools:
		var pool: Dictionary = _pools[pool_name]
		var active_nodes_to_return: Array[Node] = []
		for child in pool.container.get_children():
			if not pool.inactive.has(child):
				active_nodes_to_return.append(child)

		for node in active_nodes_to_return:
			return_instance.call_deferred(node)


func get_instance(p_pool_name: StringName) -> Node:
	if not _pools.has(p_pool_name):
		push_error("ObjectPool: Attempted to get instance from a non-existent pool: '%s'" % p_pool_name)
		return null

	var pool: Dictionary = _pools[p_pool_name]
	var instance: Node

	if not pool.inactive.is_empty():
		instance = pool.inactive.pop_front()
	else:
		instance = pool.scene.instantiate()
		instance.set_meta("pool_name", p_pool_name)
		pool.container.add_child(instance)

	return instance


func return_instance(p_instance: Node) -> void:
	if not is_instance_valid(p_instance):
		return

	var pool_name: StringName = p_instance.get_meta("pool_name", "")
	if pool_name == "" or not _pools.has(pool_name):
		p_instance.queue_free()
		return

	var pool: Dictionary = _pools[pool_name]
	if not pool.inactive.has(p_instance):
		pool.inactive.push_front(p_instance)

	if p_instance.has_method("deactivate"):
		p_instance.deactivate()


# --- Private Methods ---

func _create_pool_from_path(p_pool_name: StringName, p_scene_path: String, p_initial_size: int) -> void:
	var scene: PackedScene = load(p_scene_path)

	if not is_instance_valid(scene):
		push_error("ObjectPool: Failed to load scene for pool '%s' at path: %s" % [p_pool_name, p_scene_path])
		return

	_create_pool_for_scene(p_pool_name, scene, p_initial_size)


func _create_pool_for_scene(
	p_pool_name: StringName, p_scene: PackedScene, p_initial_size: int
) -> void:
	if _pools.has(p_pool_name):
		return

	var pool_container := Node.new()
	pool_container.name = str(p_pool_name)
	add_child(pool_container)

	_pools[p_pool_name] = {"scene": p_scene, "inactive": [], "container": pool_container}

	for i in range(p_initial_size):
		var instance: Node = p_scene.instantiate()
		instance.set_meta("pool_name", p_pool_name)
		pool_container.add_child(instance)
		if instance.has_method("deactivate"):
			instance.deactivate()
		_pools[p_pool_name].inactive.append(instance)


=====================================
FILE: ./src/core/systems/audio_manager.gd
=====================================
# src/core/systems/audio_manager.gd
## An autoloaded singleton responsible for all audio playback.
##
## Manages separate channels for music and sound effects, and responds
## dynamically to changes in the global [Settings] resource. It includes
## robust cleanup handlers to prevent memory leaks on game exit.
extends Node

# --- Private Member Variables ---
var _sfx_players: Array[AudioStreamPlayer] = []
var _sfx_player_index: int = 0
var _music_player: AudioStreamPlayer

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	# --- Create SFX Players ---
	for i in range(Constants.NUM_SFX_PLAYERS):
		var player = AudioStreamPlayer.new()
		player.name = "SFXPlayer_%d" % i
		player.bus = "SFX"
		add_child(player)
		_sfx_players.append(player)

	# --- Create Music Player ---
	_music_player = AudioStreamPlayer.new()
	_music_player.name = "MusicPlayer"
	_music_player.bus = "Music"
	add_child(_music_player)

	# --- Connect to Settings ---
	Settings.audio_settings_changed.connect(_on_audio_settings_changed)
	_on_audio_settings_changed()  # Apply initial settings


func _notification(what: int) -> void:
	# A robust, system-level notification for cleaning up before the app quits.
	if what == NOTIFICATION_WM_CLOSE_REQUEST:
		if is_instance_valid(_music_player):
			_music_player.stop()
			_music_player.stream = null


func _exit_tree() -> void:
	# Disconnect from the signal to be a good citizen.
	if Settings.audio_settings_changed.is_connected(_on_audio_settings_changed):
		Settings.audio_settings_changed.disconnect(_on_audio_settings_changed)

	# Secondary cleanup method for when the node is removed from the tree.
	if is_instance_valid(_music_player):
		_music_player.stop()
		_music_player.stream = null


# --- Public Methods ---


## Plays a one-shot sound effect.
func play_sfx(sound_path: String) -> void:
	var player = _sfx_players[_sfx_player_index]
	player.stream = load(sound_path)
	player.play()
	_sfx_player_index = (_sfx_player_index + 1) % Constants.NUM_SFX_PLAYERS


## Plays a looping music track.
func play_music(music_path: String) -> void:
	if (
		_music_player.stream
		and _music_player.stream.resource_path == music_path
		and _music_player.playing
	):
		return

	_music_player.stream = load(music_path)
	_music_player.play()


## Stops the current music track.
func stop_music() -> void:
	_music_player.stop()


# --- Signal Handlers ---


func _on_audio_settings_changed() -> void:
	AudioServer.set_bus_volume_db(
		AudioServer.get_bus_index("Master"), linear_to_db(Settings.master_volume)
	)
	AudioServer.set_bus_mute(AudioServer.get_bus_index("Master"), Settings.master_muted)

	AudioServer.set_bus_volume_db(
		AudioServer.get_bus_index("Music"), linear_to_db(Settings.music_volume)
	)
	AudioServer.set_bus_mute(AudioServer.get_bus_index("Music"), Settings.music_muted)

	AudioServer.set_bus_volume_db(
		AudioServer.get_bus_index("SFX"), linear_to_db(Settings.sfx_volume)
	)
	AudioServer.set_bus_mute(AudioServer.get_bus_index("SFX"), Settings.sfx_muted)


=====================================
FILE: ./src/core/systems/fx_bindings/fx_manager_adapter.gd
=====================================
# src/core/systems/fx_bindings/fx_manager_adapter.gd
## An adapter that implements the IFXManager interface by delegating calls
## to the real FXManager autoload singleton. This script is registered as an
## autoload itself and should NOT have a matching class_name.
extends IFXManager

# --- Private Member Variables ---
var _real_fx_manager: Node

# --- Godot Lifecycle Methods ---
func _ready() -> void:
	# Find the actual autoloaded singleton in the scene tree.
	_real_fx_manager = get_node("/root/FXManager")
	assert(is_instance_valid(_real_fx_manager), "FXManagerAdapter could not find /root/FXManager")

# --- IFXManager Implementation ---

func register_camera_shaker(shaker: CameraShaker) -> void:
	_real_fx_manager.register_camera_shaker(shaker)

func unregister_camera_shaker() -> void:
	_real_fx_manager.unregister_camera_shaker()

func is_camera_shaker_registered() -> bool:
	return _real_fx_manager.is_camera_shaker_registered()

func request_screen_shake(shake_effect: ScreenShakeEffect) -> void:
	_real_fx_manager.request_screen_shake(shake_effect)

func play_vfx(effect: VFXEffect, global_position: Vector2, direction: Vector2 = Vector2.ZERO) -> void:
	_real_fx_manager.play_vfx(effect, global_position, direction)

func request_hit_stop(duration: float) -> void:
	_real_fx_manager.request_hit_stop(duration)

func prewarm_shaders_async(effects: Array[ShaderEffect], prewarm_viewport: SubViewport) -> void:
	await _real_fx_manager.prewarm_shaders_async(effects, prewarm_viewport)

func get_debug_stats() -> Dictionary:
	return _real_fx_manager.get_debug_stats()

func increment_shader_count() -> void:
	_real_fx_manager.increment_shader_count()

func decrement_shader_count() -> void:
	_real_fx_manager.decrement_shader_count()

func apply_shader_effect(
	target_node: CanvasItem, effect: ShaderEffect, overrides: Dictionary, opts: Dictionary
) -> Tween:
	return _real_fx_manager.apply_shader_effect(target_node, effect, overrides, opts)

func cancel_effect_on_node(target_node: CanvasItem) -> void:
	_real_fx_manager.cancel_effect_on_node(target_node)


=====================================
FILE: ./src/core/systems/camera_shaker.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://camera_shaker_scene_id"]

[ext_resource type="Script" path="res://src/core/systems/camera_shaker.gd" id="1_shaker_script"]

[node name="CameraShaker" type="Node"]
script = ExtResource("1_shaker_script")

=====================================
FILE: ./src/core/systems/cursor_manager.gd
=====================================
# src/core/systems/cursor_manager.gd
## An autoloaded singleton that manages the game's custom "fake" cursor.
##
## This provides full control over the cursor's appearance and ensures it
## renders above all other UI and game elements.
extends CanvasLayer

# --- Constants ---
const CURSOR_DEFAULT = preload(AssetPaths.SPRITE_CURSOR_DEFAULT)
const CURSOR_POINTER = preload(AssetPaths.SPRITE_CURSOR_POINTER)

# --- Private Member Variables ---
var _cursor_sprite: TextureRect

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	# A high layer number ensures the cursor renders above everything else.
	layer = 10
	Input.set_mouse_mode(Input.MOUSE_MODE_HIDDEN)

	_cursor_sprite = TextureRect.new()
	_cursor_sprite.texture = CURSOR_DEFAULT
	# CRITICAL: This makes the cursor "click-through," so it never blocks
	# mouse events intended for UI elements underneath it.
	_cursor_sprite.mouse_filter = Control.MOUSE_FILTER_IGNORE
	add_child(_cursor_sprite)


func _process(_delta: float) -> void:
	# Sync the custom cursor's position to the real mouse position every frame.
	_cursor_sprite.position = get_viewport().get_mouse_position()


# --- Public Methods ---


## Sets the cursor's appearance (e.g., when hovering a button).
func set_pointer_state(is_pointing: bool) -> void:
	if is_pointing:
		_cursor_sprite.texture = CURSOR_POINTER
	else:
		_cursor_sprite.texture = CURSOR_DEFAULT


=====================================
FILE: ./src/core/systems/fx_manager.gd
=====================================
# src/core/systems/fx_manager.gd
## An autoloaded singleton to handle purely aesthetic "game feel" effects.
##
## This separates feedback like hit-stop and screen shake from core gameplay
## logic, improving modularity and adhering to SRP.
extends Node

# --- Private Member Variables ---
var _is_hit_stop_active: bool = false
var _camera_shaker: CameraShaker = null
var _services: ServiceLocator
var _managed_effects: Dictionary = {}

var _active_shader_effects: int = 0


# --- Public Methods ---


func apply_shader_effect(
	target_node: CanvasItem, effect: ShaderEffect, overrides: Dictionary, opts: Dictionary
) -> Tween:
	if not is_instance_valid(target_node) or not is_instance_valid(effect):
		return null

	var target_id: int = target_node.get_instance_id()
	cancel_effect_on_node(target_node)

	var material_instance := effect.material.duplicate(true) as ShaderMaterial
	if not is_instance_valid(material_instance):
		push_error("FXManager: effect.material is not a ShaderMaterial.")
		return null

	if not overrides.is_empty():
		for param_name in overrides:
			material_instance.set_shader_parameter(param_name, overrides[param_name])

	_managed_effects[target_id] = {
		"original_material": target_node.material,
		"effect_material": material_instance
	}
	target_node.material = material_instance

	increment_shader_count()

	var tween: Tween = create_tween().set_parallel(false)
	tween.tween_property(
		material_instance, "shader_parameter/fx_progress", 1.0, effect.duration
	)

	var preserve_final_state: bool = opts.get("preserve_final_state", false)
	tween.tween_callback(_on_shader_effect_finished.bind(target_node, preserve_final_state))
	_managed_effects[target_id]["active_tween"] = tween

	return tween


func cancel_effect_on_node(target_node: CanvasItem) -> void:
	if not is_instance_valid(target_node):
		return
	var target_id: int = target_node.get_instance_id()
	if _managed_effects.has(target_id):
		var effect_data: Dictionary = _managed_effects[target_id]
		if is_instance_valid(effect_data.active_tween):
			effect_data.active_tween.kill()
		_on_shader_effect_finished(target_node, false)


func increment_shader_count() -> void:
	_active_shader_effects += 1


func decrement_shader_count() -> void:
	_active_shader_effects -= 1


func register_camera_shaker(shaker: CameraShaker) -> void:
	_camera_shaker = shaker


func unregister_camera_shaker() -> void:
	_camera_shaker = null


func is_camera_shaker_registered() -> bool:
	return is_instance_valid(_camera_shaker)


func request_screen_shake(shake_effect: ScreenShakeEffect) -> void:
	if is_instance_valid(_camera_shaker):
		_camera_shaker.start_shake(shake_effect)
	else:
		push_warning("FXManager: request_screen_shake called, but no CameraShaker is registered.")


func play_vfx(
	effect: VFXEffect, global_position: Vector2, direction: Vector2 = Vector2.ZERO
) -> void:
	if not is_instance_valid(effect):
		push_warning("FXManager: play_vfx called with an invalid VFXEffect resource.")
		return

	if effect.pool_key == &"":
		push_warning("FXManager: VFXEffect resource is missing a 'pool_key'.")
		return

	var services: ServiceLocator = _get_services()
	var vfx_instance: Node = services.object_pool.get_instance(effect.pool_key)
	if not is_instance_valid(vfx_instance):
		push_error("FXManager: Failed to get instance for pool key '%s'." % effect.pool_key)
		return

	vfx_instance.global_position = global_position

	if vfx_instance.has_method("activate"):
		var dependencies: Dictionary = {"services": services, "direction": direction}
		vfx_instance.call("activate", dependencies)


func request_hit_stop(duration: float) -> void:
	if _is_hit_stop_active:
		return

	_is_hit_stop_active = true

	var affected_nodes: Array[Node]
	affected_nodes.append_array(get_tree().get_nodes_in_group(Identifiers.Groups.PLAYER))
	affected_nodes.append_array(get_tree().get_nodes_in_group(Identifiers.Groups.ENEMY))

	for node in affected_nodes:
		if is_instance_valid(node):
			node.set_deferred("process_mode", Node.PROCESS_MODE_DISABLED)

	var timer: SceneTreeTimer = get_tree().create_timer(duration, true, false, true)
	await timer.timeout

	if not get_tree():
		return

	for node in affected_nodes:
		if is_instance_valid(node):
			node.set_deferred("process_mode", Node.PROCESS_MODE_INHERIT)

	_is_hit_stop_active = false


func prewarm_shaders_async(effects: Array[ShaderEffect], prewarm_viewport: SubViewport) -> void:
	if not is_instance_valid(prewarm_viewport):
		push_error("FXManager: prewarm_shaders_async requires a valid SubViewport.")
		return

	print("FXManager: Starting shader pre-warm...")
	for effect in effects:
		if not is_instance_valid(effect) or not is_instance_valid(effect.material):
			continue

		var temp_rect := ColorRect.new()
		temp_rect.material = effect.material.duplicate(true)
		prewarm_viewport.add_child(temp_rect)

		await get_tree().process_frame

		temp_rect.queue_free()
	print("FXManager: Shader pre-warm complete.")


func get_debug_stats() -> Dictionary:
	var services: ServiceLocator = _get_services()
	var pool_stats: Dictionary = services.object_pool.get_pool_stats()
	var vfx_count: int = 0

	if pool_stats.has(Identifiers.Pools.HIT_SPARKS):
		vfx_count += pool_stats[Identifiers.Pools.HIT_SPARKS].active

	return {
		"active_vfx": vfx_count,
		"active_shaders": _active_shader_effects,
	}


# --- Private Methods ---


func _get_services() -> ServiceLocator:
	if not is_instance_valid(_services):
		_services = get_node("/root/ServiceLocator")
	return _services


func _on_shader_effect_finished(target_node: CanvasItem, preserve_final_state: bool) -> void:
	decrement_shader_count()

	if not is_instance_valid(target_node):
		return

	var target_id: int = target_node.get_instance_id()
	if not _managed_effects.has(target_id):
		return

	var effect_data: Dictionary = _managed_effects[target_id]
	var should_restore: bool = not target_node.is_queued_for_deletion() and not preserve_final_state

	if should_restore:
		target_node.material = effect_data.original_material

	_managed_effects.erase(target_id)


=====================================
FILE: ./src/core/data/config/settings.gd
=====================================
# src/core/data/config/settings.gd
## An autoloaded singleton that manages persistent game settings.
##
## This script uses property setters to automatically emit the
## [signal audio_settings_changed] signal whenever a value is modified,
## allowing other systems to react dynamically.
extends Node

# --- Signals ---
## Emitted whenever any audio-related setting is changed.
signal audio_settings_changed

# --- Audio Settings ---
@export var master_volume: float = 1.0:
	set(value):
		var clamped_value = clampf(value, 0.0, 1.0)
		if not is_equal_approx(master_volume, clamped_value):
			master_volume = clamped_value
			audio_settings_changed.emit()

@export var music_volume: float = 1.0:
	set(value):
		var clamped_value = clampf(value, 0.0, 1.0)
		if not is_equal_approx(music_volume, clamped_value):
			music_volume = clamped_value
			audio_settings_changed.emit()

@export var sfx_volume: float = 1.0:
	set(value):
		var clamped_value = clampf(value, 0.0, 1.0)
		if not is_equal_approx(sfx_volume, clamped_value):
			sfx_volume = clamped_value
			audio_settings_changed.emit()

@export var master_muted: bool = false:
	set(value):
		if master_muted != value:
			master_muted = value
			audio_settings_changed.emit()

@export var music_muted: bool = true:
	set(value):
		if music_muted != value:
			music_muted = value
			audio_settings_changed.emit()

@export var sfx_muted: bool = false:
	set(value):
		if sfx_muted != value:
			sfx_muted = value
			audio_settings_changed.emit()


=====================================
FILE: ./src/core/data/config/combat_config.gd
=====================================
# src/core/data/config/combat_config.gd
@tool
## A single, flat Resource that exposes all gameplay tuning values.
##
## This allows designers to balance the game directly in the Godot Inspector
## using organized, range-limited sliders.
class_name CombatConfig
extends Resource

@export_group("Player - Health & Resources")
@export_range(1, 20, 1) var player_max_health: int = 5
@export_range(1, 10, 1) var player_max_healing_charges: int = 1
@export_range(0.1, 5.0, 0.1) var player_heal_duration: float = 2.0
@export_range(1, 100, 1) var player_determination_per_charge: int = 10
@export_range(0.1, 5.0, 0.1) var player_invincibility_duration: float = 1.5

@export_group("Player - Movement & Physics")
@export_range(100, 1000, 5) var player_speed: float = 450.0
@export_range(200, 1500, 10) var player_jump_force: float = 680.0
@export_range(0.1, 1.0, 0.05) var player_jump_release_dampener: float = 0.4
@export_range(0.0, 0.5, 0.01) var player_coyote_time: float = 0.1
@export_range(0.0, 0.5, 0.01) var player_jump_buffer: float = 0.1
@export_range(1.0, 3.0, 0.1) var player_fast_fall_gravity_multiplier: float = 1.4
@export var player_max_air_jumps: int = 1

@export_group("Player - Wall Interaction")
@export_range(50, 500, 5) var player_wall_slide_speed: float = 120.0
@export_range(0.0, 0.5, 0.01) var player_wall_coyote_time: float = 0.05
@export_range(500, 2500, 50) var player_wall_jump_force_x: float = 1650.0
@export_range(200, 1500, 10) var player_wall_jump_force_y: float = 680.0

@export_group("Player - Dash")
@export_range(500, 2500, 50) var player_dash_speed: float = 1400.0
@export_range(0.05, 0.5, 0.01) var player_dash_duration: float = 0.15
@export_range(0.1, 2.0, 0.05) var player_dash_cooldown: float = 0.5

@export_group("Player - Combat")
@export var player_forward_attack_shape: Shape2D
@export var player_upward_attack_shape: Shape2D
@export_range(0.05, 1.0, 0.01) var player_attack_cooldown: float = 0.12
@export_range(0.05, 0.5, 0.01) var player_attack_duration: float = 0.1
@export_range(100, 5000, 100) var player_attack_friction: float = 2000.0
@export_range(0.1, 1.0, 0.01) var player_charge_time: float = 0.35
@export_range(200, 1000, 10) var player_pogo_force: float = 450.0
@export_range(100, 1500, 25) var player_knockback_speed: float = 400.0
@export_range(0.05, 0.5, 0.01) var player_knockback_duration: float = 0.1
@export_range(100, 1500, 25) var player_hazard_knockback_speed: float = 400.0
@export_range(10, 200, 5) var player_close_range_threshold: float = 75.0

@export_group("Boss - General")
@export_range(10, 500, 5) var boss_health: int = 30
@export_range(50, 500, 5) var boss_patrol_speed: float = 100.0
@export_range(0.0, 2.0, 0.01) var boss_invincibility_duration: float = 0.1

@export_group("Boss - Lunge Attack")
@export_range(500, 3000, 50) var boss_lunge_speed: float = 1200.0

@export_group("Projectiles")
@export_range(1, 20, 1) var homing_shot_damage: int = 1
@export_range(100, 1000, 10) var homing_shot_speed: float = 250.0
@export_range(1.0, 20.0, 0.5) var homing_shot_lifespan: float = 10.0

@export_group("Global - Physics")
@export_range(500, 3000, 10) var gravity: float = 1200.0

@export_group("Global - Juice & Feedback (Hit-Stop)")
@export_range(0.0, 0.5, 0.01) var player_melee_close_range_hit_stop_duration: float = 0.025
@export_range(0.0, 0.5, 0.01) var player_damage_taken_hit_stop_duration: float = 0.04
@export_range(0.0, 1.0, 0.01) var boss_phase_change_hit_stop_duration: float = 0.1
@export_range(0.0, 1.0, 0.01) var boss_death_hit_stop_duration: float = 0.2

=====================================
FILE: ./src/core/data/game_state_data.gd
=====================================
# src/core/data/game_state_data.gd
## A Resource that holds all shared runtime state for the game session.
class_name GameStateData
extends Resource

# --- Member Variables ---
## The full 'res://' path to the [EncounterData] resource for the current level.
var current_encounter_path: String = ""
## A reference to the fully constructed, but currently hidden, level node.
var prebuilt_level: Node = null


=====================================
FILE: ./src/core/data/effects/player_damage_shake.tres
=====================================
[gd_resource type="Resource" script_class="ScreenShakeEffect" load_steps=2 format=3 uid="uid://player_damage_shake_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/screen_shake_effect.gd" id="1_shake_effect"]

[resource]
script = ExtResource("1_shake_effect")
amplitude = 12.0
frequency = 35.0
duration = 0.3

=====================================
FILE: ./src/core/data/effects/dissolve_effect.tres
=====================================
[gd_resource type="Resource" script_class="ShaderEffect" load_steps=3 format=3 uid="uid://bps1fb52qcel8"]

[ext_resource type="Script" uid="uid://dci8r65dt2cj0" path="res://src/core/data/effects/shader_effect.gd" id="1_script"]
[ext_resource type="Material" uid="uid://bkiertsatpb34" path="res://materials/dissolve_material.tres" id="2_material"]

[resource]
script = ExtResource("1_script")
material = ExtResource("2_material")
duration = 0.7
priority = 10
target_scope = 0
params = {
"border_color": Color(1, 1, 1, 1),
"border_width": 0.02
}


=====================================
FILE: ./src/core/data/effects/boss_death_shake.tres
=====================================
[gd_resource type="Resource" script_class="ScreenShakeEffect" load_steps=2 format=3 uid="uid://boss_death_shake_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/screen_shake_effect.gd" id="1_shake_effect"]

[resource]
script = ExtResource("1_shake_effect")
amplitude = 40.0
frequency = 10.0
duration = 1.2

=====================================
FILE: ./src/core/data/effects/player_hit_spark_effect.tres
=====================================
[gd_resource type="Resource" script_class="VFXEffect" load_steps=3 format=3 uid="uid://player_hit_spark_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/vfx_effect.gd" id="1_vfx_effect"]
[ext_resource type="PackedScene" uid="uid://c8g7f6e5d4b3a" path="res://src/vfx/hit_spark.tscn" id="2_hit_spark_scene"]

[resource]
script = ExtResource("1_vfx_effect")

; --- Configuration ---
scene = ExtResource("2_hit_spark_scene")
pool_key = &"hit_sparks"

=====================================
FILE: ./src/core/data/effects/boss_phase_change_shake.tres
=====================================
[gd_resource type="Resource" script_class="ScreenShakeEffect" load_steps=2 format=3 uid="uid://boss_phase_change_shake_tres"]

[ext_resource type="Script" path="res://src/core/data/effects/screen_shake_effect.gd" id="1_shake_effect"]

[resource]
script = ExtResource("1_shake_effect")
amplitude = 25.0
frequency = 12.0
duration = 0.8

=====================================
FILE: ./src/core/data/effects/screen_shake_effect.gd
=====================================
# src/core/data/effects/screen_shake_effect.gd
@tool
## A data resource that defines the properties of a screen shake effect.
##
## This allows for the creation of reusable, designer-tunable shake assets.
class_name ScreenShakeEffect
extends Resource

## The maximum offset in pixels. Higher values create a more intense shake.
@export_range(0.0, 100.0, 1.0) var amplitude: float = 10.0

## The speed of the shake. Higher values create a more frantic shake.
@export_range(0.1, 50.0, 0.1) var frequency: float = 15.0

## The total duration of the shake effect in seconds.
@export_range(0.1, 5.0, 0.05) var duration: float = 0.5


=====================================
FILE: ./src/core/data/effects/shader_effect.gd
=====================================
# src/core/data/effects/shader_effect.gd
@tool
## A data resource that defines a "recipe" for a shader-based visual effect.
##
## This allows the FXManager to treat shaders as reusable, configurable assets,
## just like particle effects or screen shakes.
class_name ShaderEffect
extends Resource

# --- Editor Properties ---
@export_group("Configuration")
## The actual ShaderMaterial resource to be applied.
@export var material: ShaderMaterial

## The duration of the effect in seconds. A value of 0 means it runs indefinitely
## until manually stopped.
@export_range(0.0, 5.0, 0.01) var duration: float = 0.15

## A dictionary of uniform parameters to be passed to the shader.
## Example: { "intensity": 1.0, "tint_color": Color.RED }
@export var params: Dictionary = {}

@export_group("Behavior")
## A priority level to resolve conflicts if multiple effects are triggered at once.
## Higher numbers have higher priority.
@export var priority: int = 0

@export_group("Performance")
## Minimum time in seconds before this effect can be triggered again on the same target.
## A value of 0 disables coalescing.
@export_range(0.0, 1.0, 0.01) var coalesce_window: float = 0.1

=====================================
FILE: ./src/core/data/effects/vfx_effect.gd
=====================================
# src/core/data/effects/vfx_effect.gd
@tool
## A data resource that defines a "recipe" for a visual effect.
##
## It tells the FXManager which scene to retrieve from which ObjectPool.
## This allows for the creation of reusable, data-driven visual effects.
class_name VFXEffect
extends Resource

## The PackedScene of the visual effect to be instanced from the pool.
@export var scene: PackedScene

## The StringName key for the ObjectPool where this VFX scene is stored.
@export var pool_key: StringName = &""


=====================================
FILE: ./src/core/DEPRECATION.md
=====================================
# Core Subsystem Deprecation Map

This document tracks file renames and moves specifically within `src/core`.

| Old Path | New Path | Reason | Date | Migration Note |
|---|---|---|---|---|
| `res://src/core/data/Config.gd` | `res://src/core/data/config/config.gd` | Naming convention and grouping. | 2025-08-10 | Autoload path was updated in `project.godot`. |
| `res://src/core/data/settings.gd` | `res://src/core/data/config/settings.gd` | Grouped with other data configs. | 2025-08-10 | Autoload path was updated in `project.godot`. |

=====================================
FILE: ./src/core/building/level_parser.gd
=====================================
# src/core/building/level_parser.gd
@tool
## Parses an [EncounterData] resource into a [LevelBuildData] object.
##
## This class is responsible for translating the character-based layout
## into structured data that the builders can use.
class_name LevelParser
extends RefCounted

# --- Public Methods ---


## Parses the provided [EncounterData] and returns a populated [LevelBuildData].
func parse_level_data(encounter_data: EncounterData, services: ServiceLocator) -> LevelBuildData:
	var data = LevelBuildData.new()
	if not is_instance_valid(encounter_data):
		push_error("LevelParser: Invalid EncounterData provided.")
		return data

	var layout: LevelLayout = encounter_data.level_layout
	if not is_instance_valid(layout):
		push_error("LevelParser: EncounterData is missing a valid LevelLayout.")
		return data

	var terrain_data_array: PackedStringArray = layout.terrain_data
	var grid_height: int = terrain_data_array.size()
	var grid_width: int = 0
	if grid_height > 0:
		grid_width = terrain_data_array[0].length()
	data.dimensions_tiles = Vector2i(grid_width, grid_height)

	var player_marker: String = encounter_data.player_spawn_marker
	var boss_marker: String = encounter_data.boss_spawn_marker
	var minion_spawn_dict: Dictionary = encounter_data.minion_spawns

	for y in range(grid_height):
		var row_string: String = terrain_data_array[y]
		for x in range(row_string.length()):
			var tile_char: String = row_string[x]
			var tile_grid_pos = Vector2i(x, y)
			var tile_world_pos = services.grid_utils.grid_to_world(tile_grid_pos)

			match tile_char:
				"#":
					data.terrain_tiles.append(tile_world_pos)
				"-":
					data.oneway_platforms.append(tile_world_pos)
				"^":
					data.hazard_tiles.append(tile_world_pos)
				".":
					data.background_tiles.append(tile_grid_pos)
				_:
					data.background_tiles.append(tile_grid_pos)
					if tile_char == player_marker:
						data.player_spawn_pos = tile_world_pos
					elif tile_char == boss_marker:
						data.boss_spawn_pos = tile_world_pos
					elif minion_spawn_dict.has(tile_char):
						var scene_to_spawn: PackedScene = minion_spawn_dict[tile_char]
						var spawn_data = LevelBuildData.MinionSpawnData.new(
							scene_to_spawn, tile_world_pos
						)
						data.minion_spawns.append(spawn_data)
	return data


=====================================
FILE: ./src/core/building/terrain_builder.gd
=====================================
# src/core/building/terrain_builder.gd
@tool
## Responsible for creating all static level geometry nodes.
##
## This includes solid walls, one-way platforms, hazards, and background tiles.
## It uses [Polygon2D] for in-game visuals to prevent conflicts with debug drawing.
class_name TerrainBuilder
extends Node

# --- Public Methods ---


## Asynchronously creates all terrain nodes defined in the [LevelBuildData].
func build_terrain_async(
	parent_node: Node, build_data: LevelBuildData, tree: SceneTree, services: ServiceLocator
) -> void:
	const BATCH_SIZE = 20

	for i in range(build_data.terrain_tiles.size()):
		_create_solid_tile(parent_node, build_data.terrain_tiles[i], services)
		if i % BATCH_SIZE == 0:
			await tree.process_frame

	for i in range(build_data.oneway_platforms.size()):
		_create_oneway_platform(parent_node, build_data.oneway_platforms[i], services)
		if i % BATCH_SIZE == 0:
			await tree.process_frame

	for i in range(build_data.hazard_tiles.size()):
		_create_hazard_tile(parent_node, build_data.hazard_tiles[i], services)
		if i % BATCH_SIZE == 0:
			await tree.process_frame

	await tree.process_frame


## Procedurally fills the camera's viewport with background grid tiles.
func fill_viewport(
	parent_node: Node, build_data: LevelBuildData, camera: Camera2D, services: ServiceLocator
) -> void:
	var view_transform = camera.get_viewport().get_canvas_transform().affine_inverse()
	var world_top_left = view_transform.origin
	var world_bottom_right = (
		world_top_left + camera.get_viewport_rect().size * view_transform.get_scale()
	)

	var grid_top_left: Vector2i = services.grid_utils.world_to_grid(world_top_left)
	var grid_bottom_right: Vector2i = services.grid_utils.world_to_grid(world_bottom_right)

	var existing_bg_tiles = {}
	for pos in build_data.background_tiles:
		existing_bg_tiles[pos] = true

	for y in range(grid_top_left.y, grid_bottom_right.y + 1):
		for x in range(grid_top_left.x, grid_bottom_right.x + 1):
			var grid_pos = Vector2i(x, y)
			if not existing_bg_tiles.has(grid_pos):
				_create_background_tile(parent_node, grid_pos)


# --- Private Methods ---


func _create_background_tile(parent_node: Node, grid_pos: Vector2i) -> void:
	var visual_rect = ColorRect.new()
	visual_rect.color = Palette.COLOR_GRID
	visual_rect.size = Vector2(Constants.TILE_SIZE, Constants.TILE_SIZE)
	visual_rect.position = Vector2(grid_pos) * Constants.TILE_SIZE
	parent_node.add_child(visual_rect)
	parent_node.move_child(visual_rect, 0)


func _create_solid_tile(parent_node: Node, pos: Vector2, _services: ServiceLocator) -> void:
	var static_body := StaticBody2D.new()
	static_body.position = pos
	static_body.collision_layer = PhysicsLayers.SOLID_WORLD
	static_body.add_to_group(Identifiers.Groups.WORLD)

	var collision_shape := CollisionShape2D.new()
	var rectangle_shape := RectangleShape2D.new()
	rectangle_shape.size = Vector2(Constants.TILE_SIZE, Constants.TILE_SIZE)
	collision_shape.shape = rectangle_shape
	static_body.add_child(collision_shape)

	var visual_poly := Polygon2D.new()
	var half_size = Constants.TILE_SIZE / 2.0
	visual_poly.polygon = PackedVector2Array(
		[
			Vector2(-half_size, -half_size),
			Vector2(half_size, -half_size),
			Vector2(half_size, half_size),
			Vector2(-half_size, half_size)
		]
	)
	visual_poly.color = Palette.COLOR_TERRAIN_PRIMARY
	static_body.add_child(visual_poly)

	parent_node.add_child(static_body)


func _create_oneway_platform(parent_node: Node, pos: Vector2, _services: ServiceLocator) -> void:
	var static_body := StaticBody2D.new()
	static_body.position = pos
	static_body.collision_layer = PhysicsLayers.PLATFORMS
	static_body.add_to_group(Identifiers.Groups.WORLD)
	static_body.add_to_group(Identifiers.Groups.ONEWAY_PLATFORMS)

	var collision_shape := CollisionShape2D.new()
	collision_shape.one_way_collision = true
	var rectangle_shape := RectangleShape2D.new()
	var platform_height = 10.0
	rectangle_shape.size = Vector2(Constants.TILE_SIZE, platform_height)
	collision_shape.shape = rectangle_shape
	collision_shape.position.y = -(Constants.TILE_SIZE / 2.0) + (rectangle_shape.size.y / 2.0)
	static_body.add_child(collision_shape)

	var visual_poly := Polygon2D.new()
	var half_width = Constants.TILE_SIZE / 2.0
	var half_height = platform_height / 2.0
	visual_poly.position = collision_shape.position
	visual_poly.polygon = PackedVector2Array(
		[
			Vector2(-half_width, -half_height),
			Vector2(half_width, -half_height),
			Vector2(half_width, half_height),
			Vector2(-half_width, half_height)
		]
	)
	visual_poly.color = Palette.COLOR_TERRAIN_SECONDARY
	static_body.add_child(visual_poly)

	parent_node.add_child(static_body)


func _create_hazard_tile(parent_node: Node, pos: Vector2, _services: ServiceLocator) -> void:
	var static_body := StaticBody2D.new()
	static_body.position = pos
	static_body.collision_layer = PhysicsLayers.HAZARD | PhysicsLayers.SOLID_WORLD
	static_body.add_to_group(Identifiers.Groups.WORLD)
	static_body.add_to_group(Identifiers.Groups.HAZARD)

	var collision_shape := CollisionShape2D.new()
	var rectangle_shape := RectangleShape2D.new()
	rectangle_shape.size = Vector2(Constants.TILE_SIZE, Constants.TILE_SIZE)
	collision_shape.shape = rectangle_shape
	static_body.add_child(collision_shape)

	var visual_poly := Polygon2D.new()
	var half_size = Constants.TILE_SIZE / 2.0
	visual_poly.polygon = PackedVector2Array(
		[
			Vector2(-half_size, -half_size),
			Vector2(half_size, -half_size),
			Vector2(half_size, half_size),
			Vector2(-half_size, half_size)
		]
	)
	visual_poly.color = Palette.COLOR_HAZARD_PRIMARY
	static_body.add_child(visual_poly)

	parent_node.add_child(static_body)


=====================================
FILE: ./src/core/building/level_build_data.gd
=====================================
# src/core/building/level_build_data.gd
@tool
## A custom Resource that acts as a data container for a parsed level.
##
## It holds all the necessary information for the [ArenaBuilder] to construct
## the level, including tile positions and entity spawn points.
class_name LevelBuildData
extends Resource


# --- Inner Classes ---
## A simple data container for a single minion spawn.
class MinionSpawnData:
	extends RefCounted
	var scene: PackedScene
	var position: Vector2

	func _init(p_scene: PackedScene, p_pos: Vector2) -> void:
		scene = p_scene
		position = p_pos


# --- Member Variables ---
var terrain_tiles: Array[Vector2] = []
var oneway_platforms: Array[Vector2] = []
var hazard_tiles: Array[Vector2] = []
var background_tiles: Array[Vector2i] = []
var player_spawn_pos: Vector2 = Vector2.ZERO
var boss_spawn_pos: Vector2 = Vector2.ZERO
var encounter_data_resource: EncounterData = null
var dimensions_tiles: Vector2i = Vector2i.ZERO
var minion_spawns: Array[MinionSpawnData] = []


=====================================
FILE: ./src/core/building/arena_builder.gd
=====================================
# src/core/building/arena_builder.gd
## An autoload that procedurally constructs the entire level scene.
##
## It parses data from [EncounterData] and [LevelLayout] resources, then uses
## builder sub-systems to spawn the terrain, entities, and UI.
extends Node

# --- Private Member Variables ---
var _current_build_data: LevelBuildData
var _current_level_container: Node
var _intro_sequence_handle: SequenceHandle
var _minion_spawn_counts: Dictionary = {}

# --- Public Methods ---


## Asynchronously builds the entire level and returns the root node.
func build_level_async() -> Node:
	if is_instance_valid(_intro_sequence_handle):
		_intro_sequence_handle.cancel()
	_intro_sequence_handle = null
	_minion_spawn_counts.clear()

	_current_level_container = Node.new()
	_current_level_container.name = "LevelContainer"

	var encounter_path: String = GameManager.state.current_encounter_path
	if encounter_path.is_empty():
		return _current_level_container

	var encounter_data: EncounterData = load(encounter_path)
	if not is_instance_valid(encounter_data):
		push_error("ArenaBuilder: Failed to load EncounterData at path: %s" % encounter_path)
		return _current_level_container

	var parser = LevelParser.new()
	_current_build_data = parser.parse_level_data(encounter_data, ServiceLocator)
	_current_build_data.encounter_data_resource = encounter_data
	_current_level_container.set_meta("build_data", _current_build_data)

	await get_tree().process_frame

	var terrain_builder = TerrainBuilder.new()
	await terrain_builder.build_terrain_async(
		_current_level_container, _current_build_data, get_tree(), ServiceLocator
	)

	await _spawn_player_async()
	await _spawn_hud_async()
	await _spawn_minions_async()

	_intro_sequence_handle = _run_intro_sequence()
	if is_instance_valid(_intro_sequence_handle):
		await _intro_sequence_handle.finished

	await get_tree().process_frame

	return _current_level_container


# --- Private Methods ---


func _spawn_player_async() -> void:
	var instance = load(AssetPaths.SCENE_PLAYER).instantiate()
	instance.global_position = _current_build_data.player_spawn_pos
	# THE FIX: Explicitly inject dependencies before adding to the scene tree.
	instance.inject_dependencies(ServiceLocator)
	_current_level_container.add_child(instance)
	await get_tree().process_frame


func _spawn_boss_async() -> Node:
	var boss_scene: PackedScene = _current_build_data.encounter_data_resource.boss_scene
	if not boss_scene:
		return null
	var instance = boss_scene.instantiate()
	instance.global_position = _current_build_data.boss_spawn_pos
	# THE FIX: Explicitly inject dependencies before adding to the scene tree.
	instance.inject_dependencies(ServiceLocator)
	_current_level_container.add_child(instance)
	await get_tree().process_frame
	return instance


func _spawn_hud_async() -> void:
	var instance = load(AssetPaths.SCENE_GAME_HUD).instantiate()
	_current_level_container.add_child(instance)
	await get_tree().process_frame


func _spawn_minions_async() -> void:
	for spawn_data in _current_build_data.minion_spawns:
		var instance = spawn_data.scene.instantiate()

		var base_name = instance.name
		var current_count = _minion_spawn_counts.get(base_name, 0) + 1
		_minion_spawn_counts[base_name] = current_count
		instance.name = "%s_%d" % [base_name, current_count]

		instance.global_position = spawn_data.position
		# THE FIX: Explicitly inject dependencies before adding to the scene tree.
		instance.inject_dependencies(ServiceLocator)
		_current_level_container.add_child(instance)
		await get_tree().process_frame


func _run_intro_sequence() -> SequenceHandle:
	var wait_step = WaitStep.new()
	wait_step.duration = 0.5
	var spawn_boss_step = CallableStep.new()
	spawn_boss_step.callable = Callable(self, "_spawn_boss_async")
	var intro_steps: Array[SequenceStep] = [wait_step, spawn_boss_step]
	return Sequencer.run_sequence(intro_steps)


=====================================
FILE: ./src/tests/unit/test_input_component.gd
=====================================
# src/tests/unit/test_input_component.gd
extends GutTest

# --- Constants ---
const InputComponent = preload("res://src/entities/components/input_component.gd")
const PlayerStateData = preload("res://src/entities/player/data/player_state_data.gd")
const CombatConfig = preload("res://src/data/combat_config.tres")
const GutInputSender = preload("res://addons/gut/input_sender.gd")

# --- Test Internals ---
var _input_component: InputComponent
var _input_sender: GutInputSender
var _mock_owner: CharacterBody2D

# --- Test Lifecycle ---
func before_all() -> void:
	# Create a single input sender that targets the global Input singleton.
	_input_sender = GutInputSender.new(Input)

func before_each():
	_mock_owner = CharacterBody2D.new()
	add_child_autofree(_mock_owner)

	_input_component = InputComponent.new()
	_mock_owner.add_child(_input_component)

	var dependencies = {
		"data_resource": PlayerStateData.new(),
		"config": CombatConfig
	}
	_input_component.setup(_mock_owner, dependencies)

func after_each() -> void:
	# Per GUT docs, always release held actions to prevent state leaking between tests.
	_input_sender.release_all()
	_input_sender.clear()
	await get_tree().process_frame

# --- The Tests ---
func test_move_axis_is_buffered_correctly() -> void:
	_input_sender.action_down("ui_right").wait_frames(1)
	await _input_sender.idle
	_input_component._physics_process(0.016)
	assert_eq(_input_component.buffer.get("move_axis"), 1.0, "Move axis should be 1.0 for 'ui_right'.")

	_input_sender.action_up("ui_right").action_down("ui_left").wait_frames(1)
	await _input_sender.idle
	_input_component._physics_process(0.016)
	assert_eq(_input_component.buffer.get("move_axis"), -1.0, "Move axis should be -1.0 for 'ui_left'.")

	_input_sender.action_up("ui_left").wait_frames(1)
	await _input_sender.idle
	_input_component._physics_process(0.016)
	assert_eq(_input_component.buffer.get("move_axis"), 0.0, "Move axis should be 0.0 when no key is pressed.")

func test_action_just_pressed_is_buffered_for_one_frame() -> void:
	_input_sender.action_down("ui_jump").wait_frames(1)
	await _input_sender.idle
	_input_component._physics_process(0.016)
	assert_true(_input_component.buffer.get("jump_just_pressed"), "'jump_just_pressed' should be true on the frame it is pressed.")

	# Advance one physics frame so the "just_pressed" condition expires.
	await wait_physics_frames(1)
	# note: physics frame will call _physics_process automatically, so no manual call needed
	assert_false(_input_component.buffer.get("jump_just_pressed", false), "'jump_just_pressed' should be false on subsequent frames.")

func test_action_released_is_buffered_for_one_frame() -> void:
	_input_sender.action_down("ui_attack").wait_frames(1)
	await _input_sender.idle
	_input_component._physics_process(0.016)

	_input_sender.action_up("ui_attack").wait_frames(1)
	await _input_sender.idle
	_input_component._physics_process(0.016)
	assert_true(_input_component.buffer.get("attack_released"), "'attack_released' should be true on the frame it is released.")

	# Advance one physics frame so the "attack_released" condition expires.
	await wait_physics_frames(1)
	assert_false(_input_component.buffer.get("attack_released", false), "'attack_released' should be false on subsequent frames.")

func test_action_held_persists_across_frames() -> void:
	_input_sender.action_down("ui_jump").wait_frames(1)
	await _input_sender.idle
	_input_component._physics_process(0.016)
	assert_true(_input_component.buffer.get("jump_held"), "'jump_held' should be true on the first frame.")

	_input_component._physics_process(0.016)
	assert_true(_input_component.buffer.get("jump_held"), "'jump_held' should remain true on subsequent frames.")

	_input_sender.action_up("ui_jump").wait_frames(1)
	await _input_sender.idle
	_input_component._physics_process(0.016)
	assert_false(_input_component.buffer.get("jump_held", false), "'jump_held' should be false after being released.")

=====================================
FILE: ./src/tests/unit/test_player_resource_component.gd
=====================================
# src/tests/unit/test_player_resource_component.gd
extends GutTest

# --- Constants ---
const PlayerResourceComponent = preload("res://src/entities/player/components/player_resource_component.gd")
const PlayerStateData = preload("res://src/entities/player/data/player_state_data.gd")
const CombatConfig = preload("res://src/data/combat_config.tres")
const EventCatalog = preload("res://src/core/events/event_catalog.gd")

# --- Test Internals ---
var _resource_component: PlayerResourceComponent
var _player_data: PlayerStateData
var _fake_event_bus # Will be created at runtime

# --- Test Lifecycle ---
func before_each():
	# 1. Instantiate fakes
	var FakeEventBusScript = load("res://src/tests/fakes/fake_event_bus.gd")
	_fake_event_bus = FakeEventBusScript.new()
	add_child_autofree(_fake_event_bus)

	var FakeServiceLocatorScript = load("res://src/tests/fakes/fake_service_locator.gd")
	var fake_services = FakeServiceLocatorScript.new()

	fake_services.mock_event_bus = _fake_event_bus
	add_child_autofree(fake_services)

	# 2. Setup test subject and its data
	var mock_owner = Node.new()
	add_child_autofree(mock_owner)
	_player_data = PlayerStateData.new()
	_player_data.config = CombatConfig
	# THE FIX: Explicitly set max charges for clarity in tests
	_player_data.max_healing_charges = 3

	_resource_component = PlayerResourceComponent.new()
	mock_owner.add_child(_resource_component)

	# 3. Inject dependencies
	var dependencies = {"data_resource": _player_data, "services": fake_services}
	_resource_component.setup(mock_owner, dependencies)

# --- The Tests ---
func test_on_damage_dealt_increments_determination():
	_player_data.determination_counter = 0
	_resource_component.on_damage_dealt()
	assert_eq(_player_data.determination_counter, 1, "Determination should increment by 1.")
	assert_false(_fake_event_bus.was_event_emitted(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED))

func test_healing_charge_gained_at_threshold():
	_player_data.healing_charges = 0
	_player_data.determination_counter = CombatConfig.player_determination_per_charge - 1

	_resource_component.on_damage_dealt()

	assert_eq(_player_data.healing_charges, 1, "Should gain 1 healing charge at the threshold.")
	assert_eq(_player_data.determination_counter, 0, "Determination should reset to 0.")
	assert_true(_fake_event_bus.was_event_emitted(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED))
	var payload = _fake_event_bus.get_payload_for_event(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED)
	assert_eq(payload.current_charges, 1, "Event payload should contain the new charge count.")

func test_healing_charges_are_capped():
	_player_data.healing_charges = _player_data.max_healing_charges
	_player_data.determination_counter = CombatConfig.player_determination_per_charge - 1
	_resource_component.on_damage_dealt()

	assert_eq(_player_data.healing_charges, _player_data.max_healing_charges, "Charges should not exceed max.")
	assert_eq(
		_player_data.determination_counter,
		CombatConfig.player_determination_per_charge - 1,
		"Determination should not increment if charges are max."
	)
	assert_false(_fake_event_bus.was_event_emitted(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED))

func test_consume_charge_decrements_and_emits_event():
	# THE FIX: Start with a valid number of charges (at max) and consume one.
	_player_data.healing_charges = _player_data.max_healing_charges # Starts at 3
	_resource_component.consume_healing_charge()
	assert_eq(_player_data.healing_charges, 2, "Healing charges should decrement by 1.")
	assert_true(_fake_event_bus.was_event_emitted(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED))
	var payload = _fake_event_bus.get_payload_for_event(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED)
	assert_eq(payload.current_charges, 2, "Event payload should contain the correct new charge count.")

func test_consume_charge_does_nothing_at_zero():
	_player_data.healing_charges = 0
	_resource_component.consume_healing_charge()
	assert_eq(_player_data.healing_charges, 0, "Healing charges should remain 0.")
	assert_false(_fake_event_bus.was_event_emitted(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED))

=====================================
FILE: ./src/tests/unit/test_health_component.gd
=====================================
# src/tests/unit/test_health_component.gd
extends GutTest

# --- Constants ---
const HealthComponent = preload("res://src/entities/components/health_component.gd")
const PlayerStateData = preload("res://src/entities/player/data/player_state_data.gd")
const DamageInfo = preload("res://src/api/combat/damage_info.gd")
const CombatConfig = preload("res://src/data/combat_config.tres")
const VFXEffect = preload("res://src/core/data/effects/vfx_effect.gd")
const FakeServiceLocator = preload("res://src/tests/fakes/fake_service_locator.gd")
const IFXManager = preload("res://src/api/interfaces/IFXManager.gd")

# --- Test Internals ---
var _health_component: HealthComponent
var _player_data: PlayerStateData
var _mock_owner: CharacterBody2D
var _died_signal_was_emitted: bool
var _took_damage_signal_was_emitted: bool
var _fake_services: FakeServiceLocator
var _fx_manager_double

func before_each() -> void:
	_died_signal_was_emitted = false
	_took_damage_signal_was_emitted = false

	# 1. Create a double for the FXManager interface
	_fx_manager_double = double(IFXManager).new()
	stub(_fx_manager_double, "play_vfx").to_do_nothing()
	add_child_autofree(_fx_manager_double)

	# 2. Create our robust FakeServiceLocator and inject the double
	_fake_services = FakeServiceLocator.new()
	_fake_services.mock_fx_manager = _fx_manager_double
	add_child_autofree(_fake_services)

	# 3. Setup test subject
	_mock_owner = CharacterBody2D.new()
	add_child_autofree(_mock_owner)

	_player_data = PlayerStateData.new()
	_player_data.config = CombatConfig
	_player_data.max_health = 10
	_player_data.health = 10

	_health_component = HealthComponent.new()
	_mock_owner.add_child(_health_component)

	var vfx = VFXEffect.new()
	vfx.pool_key = "test_hit_spark"

	var dependencies = {
		"data_resource": _player_data,
		"config": CombatConfig,
		"services": _fake_services,
		"hit_spark_effect": vfx
	}
	_health_component.setup(_mock_owner, dependencies)

	_health_component.died.connect(func(): _died_signal_was_emitted = true)
	_health_component.took_damage.connect(func(_d, _r): _took_damage_signal_was_emitted = true)


# --- The Tests ---
func test_initial_health_is_max_health():
	assert_eq(_player_data.health, 10, "Health should be max health at start.")

func test_apply_damage_reduces_health_and_emits_signal():
	var damage_info = DamageInfo.new()
	damage_info.amount = 3
	var result = _health_component.apply_damage(damage_info)

	assert_true(result.was_damaged, "Result object should indicate damage was taken.")
	assert_eq(_player_data.health, 7, "Health should be reduced by 3.")
	assert_true(_took_damage_signal_was_emitted, "'took_damage' signal should have been emitted.")

func test_cannot_take_damage_when_invincible():
	var damage_info = DamageInfo.new()
	damage_info.amount = 1
	_health_component.apply_damage(damage_info)

	assert_true(_health_component.is_invincible(), "Component should be invincible after first hit.")

	_took_damage_signal_was_emitted = false
	var result = _health_component.apply_damage(damage_info)

	assert_false(result.was_damaged, "Should not be able to take damage while invincible.")
	assert_eq(_player_data.health, 9, "Health should not have changed on second hit.")
	assert_false(_took_damage_signal_was_emitted, "'took_damage' should not be emitted when invincible.")

func test_died_signal_emitted_at_zero_health():
	var damage_info = DamageInfo.new()
	damage_info.amount = 10
	_health_component.apply_damage(damage_info)

	assert_true(_died_signal_was_emitted, "The 'died' signal should have been emitted.")
	assert_eq(_player_data.health, 0, "Health should be 0 after lethal damage.")

=====================================
FILE: ./src/tests/unit/test_idamageable_contract.gd
=====================================
# src/tests/unit/test_idamageable_contract.gd
extends GutTest

# --- Constants & Preloads ---
const HealthComponent = preload("res://src/entities/components/health_component.gd")
const FakeDamageable = preload("res://src/tests/fakes/fake_damageable.gd")
const PlayerStateData = preload("res://src/entities/player/data/player_state_data.gd")
const DamageInfo = preload("res://src/api/combat/damage_info.gd")
const FakeServiceLocator = preload("res://src/tests/fakes/fake_service_locator.gd")

# --- Test Internals ---
var _mock_owner: CharacterBody2D # THE FIX: Changed type from Node
var _fake_services: FakeServiceLocator

# --- Test Lifecycle ---
func before_each():
	_mock_owner = CharacterBody2D.new() # THE FIX: Instantiate the correct type
	add_child_autofree(_mock_owner)
	
	_fake_services = FakeServiceLocator.new()
	add_child_autofree(_fake_services)

# --- The Contract Test Suite ---

func _run_contract_tests(damageable: IDamageable, name: String) -> void:
	# Contract Rule 1: It must return a valid DamageResult object.
	var result = damageable.apply_damage(DamageInfo.new())
	assert_is(result, DamageResult, "Contract Failure (%s): apply_damage must return a DamageResult." % name)
	
	# Contract Rule 2: It must not crash when given a null DamageInfo.
	var null_result = damageable.apply_damage(null)
	assert_is(null_result, DamageResult, "Contract Failure (%s): Must handle null DamageInfo gracefully." % name)


# --- The Tests ---

func test_health_component_fulfills_contract():
	var health_comp = HealthComponent.new()
	_mock_owner.add_child(health_comp)
	
	var data = PlayerStateData.new()
	data.max_health = 10
	var deps = {
		"data_resource": data,
		"config": preload("res://src/data/combat_config.tres"),
		"services": _fake_services,
		"hit_spark_effect": preload("res://src/core/data/effects/player_hit_spark_effect.tres")
	}
	# THE FIX: Pass the correctly typed owner node
	health_comp.setup(_mock_owner, deps)
	
	_run_contract_tests(health_comp, "HealthComponent")


func test_fake_damageable_fulfills_contract():
	var fake_damageable = FakeDamageable.new()
	_mock_owner.add_child(fake_damageable)
	
	_run_contract_tests(fake_damageable, "FakeDamageable")

=====================================
FILE: ./src/tests/unit/test_combat_utils.gd
=====================================
# src/tests/unit/test_combat_utils.gd
extends GutTest

# --- Constants ---
const BaseEntity = preload("res://src/entities/base_entity.gd")
const HealthComponent = preload("res://src/entities/components/health_component.gd")
const IDamageable = preload("res://src/api/interfaces/IDamageable.gd")
const EntityArchetype = preload("res://src/entities/archetypes/entity_archetype.gd")

# --- Test Internals ---
var _combat_utils
var _mock_entity: BaseEntity
var _health_component: HealthComponent
var _non_damageable_child: Node

# --- Test Lifecycle ---

func before_all():
	_combat_utils = get_node("/root/CombatUtils")


func before_each():
	# Create a scene tree: MockEntity -> HealthComponent
	#                                -> NonDamageableChild
	_mock_entity = BaseEntity.new()
	# THE FIX: Provide a dummy archetype to prevent errors in _ready().
	_mock_entity.archetype = EntityArchetype.new()
	add_child_autofree(_mock_entity)

	_health_component = HealthComponent.new()
	_mock_entity.add_child(_health_component)
	_mock_entity._cache_components_by_type()

	_non_damageable_child = Node2D.new()
	_mock_entity.add_child(_non_damageable_child)


# --- The Tests ---

func test_find_damageable_returns_component_when_starting_from_entity():
	var result = _combat_utils.find_damageable(_mock_entity)
	assert_same(
		result,
		_health_component,
		"Should find the IDamageable component when starting from the entity root."
	)


func test_find_damageable_returns_component_when_starting_from_child():
	var result = _combat_utils.find_damageable(_non_damageable_child)
	assert_same(
		result,
		_health_component,
		"Should traverse up to the entity root and find the component when starting from a child."
	)


func test_find_damageable_returns_null_if_no_entity_ancestor_exists():
	var standalone_node = Node2D.new()
	add_child_autofree(standalone_node)
	var result = _combat_utils.find_damageable(standalone_node)
	assert_null(result, "Should return null when no BaseEntity ancestor is found.")

=====================================
FILE: ./src/tests/fakes/fake_event_bus.gd
=====================================
# src/tests/fakes/fake_event_bus.gd
## A test-double (fake) that inherits from EventBus to satisfy type checks,
## but provides custom recording logic for use in unit tests.
class_name FakeEventBus
extends "res://src/core/events/event_bus.gd"

var _emitted_events: Array[Dictionary] = []

func _ready() -> void:
	# Override parent's _ready to be a no-op in a test environment.
	pass

## Records an emitted event for later inspection instead of dispatching it.
func emit(event_name: StringName, payload = null) -> void:
	_emitted_events.append({"name": event_name, "payload": payload})

## Clears all recorded events.
func clear() -> void:
	_emitted_events.clear()

## Checks if a specific event was emitted.
func was_event_emitted(event_name: StringName) -> bool:
	for event in _emitted_events:
		if event.name == event_name:
			return true
	return false

## Returns the payload of the first event found with the given name.
func get_payload_for_event(event_name: StringName) -> Variant:
	for event in _emitted_events:
		if event.name == event_name:
			return event.payload
	return null

=====================================
FILE: ./src/tests/fakes/fake_service_locator.gd
=====================================
# src/tests/fakes/fake_service_locator.gd
## A test-double for the ServiceLocator singleton.
## It inherits from the real ServiceLocator to satisfy type checks but overrides
## _ready() to prevent it from looking for other singletons and to allow
## injecting fakes over the real @onready properties.
class_name FakeServiceLocator
extends "res://src/core/util/service_locator.gd"

# --- Fake Service Properties ---
var mock_event_bus: Node
var mock_fx_manager: Node
var mock_object_pool: Node
var mock_combat_utils: Node


func _ready() -> void:
	# This _ready function is crucial. It overrides the parent's _ready,
	# preventing it from failing.
	
	# After the parent's @onready vars have been populated with real singletons,
	# we now overwrite them with our mocks for the test.
	if is_instance_valid(mock_event_bus):
		self.event_bus = mock_event_bus
	if is_instance_valid(mock_fx_manager):
		self.fx_manager = mock_fx_manager
	if is_instance_valid(mock_object_pool):
		self.object_pool = mock_object_pool
	if is_instance_valid(mock_combat_utils):
		self.combat_utils = mock_combat_utils

=====================================
FILE: ./src/tests/fakes/fake_damageable.gd
=====================================
# src/tests/fakes/fake_damageable.gd
## A test-double (fake) that implements the IDamageable interface for use in unit tests.
## It records damage events and allows tests to inspect what happened.
class_name FakeDamageable
extends IDamageable

# --- Test Seams & Recorders ---
var was_damage_applied: bool = false
var last_damage_info: DamageInfo = null
var return_result: DamageResult = DamageResult.new() # Pre-configured result to return


func setup(_p_owner: Node, _p_dependencies: Dictionary = {}) -> void:
	# IComponent contract requires this method.
	pass


func teardown() -> void:
	# IComponent contract requires this method.
	pass


func apply_damage(damage_info: DamageInfo) -> DamageResult:
	was_damage_applied = true
	last_damage_info = damage_info
	return return_result


## Resets the state of the fake for the next test.
func reset() -> void:
	was_damage_applied = false
	last_damage_info = null
	return_result = DamageResult.new()


=====================================
FILE: ./src/vfx/hit_spark.gd
=====================================
# src/vfx/hit_spark.gd
## A self-cleaning, poolable particle effect for hit sparks.
class_name HitSpark
extends GPUParticles2D

var _services: ServiceLocator


# --- Godot Lifecycle Methods ---


func _ready() -> void:
	self.finished.connect(_on_finished)


# --- Public Methods (IPoolable Contract) ---


## Activates the particle effect.
func activate(dependencies: Dictionary) -> void:
	_services = dependencies.get("services")
	assert(is_instance_valid(_services), "HitSpark requires a ServiceLocator dependency.")
	var direction = dependencies.get("direction", Vector2.RIGHT)

	process_mode = PROCESS_MODE_INHERIT
	visible = true
	self.rotation = direction.angle()
	restart()


## Deactivates the particle effect.
func deactivate() -> void:
	process_mode = PROCESS_MODE_DISABLED
	visible = false
	_services = null


# --- Signal Handlers ---


func _on_finished() -> void:
	if not is_instance_valid(_services):
		# This might happen if deactivated during a scene transition.
		return

	_services.object_pool.return_instance(self)

=====================================
FILE: ./src/vfx/hit_spark.tscn
=====================================
[gd_scene load_steps=9 format=3 uid="uid://c8g7f6e5d4b3a"]

[ext_resource type="Script" path="res://src/vfx/hit_spark.gd" id="1_hit_spark_script"]

[sub_resource type="Gradient" id="Gradient_1"]
offsets = PackedFloat32Array(0, 0.5, 1)
colors = PackedColorArray(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_1"]
gradient = SubResource("Gradient_1")

[sub_resource type="Curve" id="Curve_1"]
_data = [Vector2(0, 1), 0.0, 0.0, 0, 0, Vector2(1, 0), 0.0, 0.0, 0, 0]
point_count = 2

[sub_resource type="CurveTexture" id="CurveTexture_1"]
curve = SubResource("Curve_1")

[sub_resource type="Gradient" id="Gradient_2"]
colors = PackedColorArray(1, 0.898039, 0.4, 1, 1, 1, 1, 1)

[sub_resource type="GradientTexture1D" id="GradientTexture1D_2"]
gradient = SubResource("Gradient_2")

[sub_resource type="ParticleProcessMaterial" id="ParticleProcessMaterial_1"]
particle_flag_disable_z = true
emission_shape = 1
emission_sphere_radius = 1.0
direction = Vector3(1, 0, 0)
spread = 90.0
initial_velocity_min = 150.0
initial_velocity_max = 400.0
gravity = Vector3(0, 0, 0)
damping_min = 200.0
damping_max = 300.0
scale_min = 1.5
scale_max = 2.5
scale_curve = SubResource("CurveTexture_1")
color_ramp = SubResource("GradientTexture1D_1")
color_initial_ramp = SubResource("GradientTexture1D_2")

[node name="HitSpark" type="GPUParticles2D"]
emitting = false
amount = 30
process_material = SubResource("ParticleProcessMaterial_1")
lifetime = 0.35
one_shot = true
explosiveness = 1.0
local_coords = true
fixed_fps = 60
script = ExtResource("1_hit_spark_script")
metadata/pool_name = &"hit_sparks"

=====================================
FILE: ./src/api/combat/damage_info.gd
=====================================
# src/api/combat/damage_info.gd
## A typed Resource that defines a complete damage event.
class_name DamageInfo
extends Resource

# --- Editor Properties ---
@export var amount: int = 1
@export var bypass_invincibility: bool = false

# --- Member Variables ---
## A reference to the node that was the source of the damage.
var source_node: Node = null
## The global position where the impact occurred.
var impact_position: Vector2 = Vector2.ZERO
## The normal vector of the surface that was hit, used for directing VFX.
var impact_normal: Vector2 = Vector2.ZERO


=====================================
FILE: ./src/api/combat/damage_result.gd
=====================================
# src/api/combat/damage_result.gd
## A typed Resource for the return value of an `apply_damage` call.
class_name DamageResult
extends Resource

# --- Member Variables ---
## True if damage was successfully applied.
var was_damaged: bool = false
## The calculated knockback velocity that should be applied to the target.
var knockback_velocity: Vector2 = Vector2.ZERO


=====================================
FILE: ./src/api/global_preloader.gd
=====================================
# src/api/global_preloader.gd
## A central autoload script whose sole purpose is to preload all interface
## and critical base class scripts in the project. This ensures their 'class_name'
## is registered with Godot's ScriptServer before any other script tries to use them,
## resolving parse order errors.
extends Node


func _ready() -> void:
	# Preload all interfaces and critical base classes to register them globally.
	preload("res://src/api/interfaces/IComponent.gd")
	# IDamageable now extends IComponent, so we preload it after.
	preload("res://src/api/interfaces/IDamageable.gd")
	preload("res://src/api/interfaces/IPoolable.gd")
	preload("res://src/api/interfaces/ISceneController.gd")
	preload("res://src/api/interfaces/IFXManager.gd")
	preload("res://src/api/interfaces/IObjectPool.gd")
	preload("res://src/entities/base_entity.gd")

=====================================
FILE: ./src/api/interfaces/IFXManager.gd
=====================================
# src/api/interfaces/IFXManager.gd
## The "interface" contract for a system that manages visual and feedback effects.
## This script defines the public API, abstracting components from the concrete
## implementation (e.g., the global FXManager autoload).
class_name IFXManager
extends Node

# --- Virtual Methods (The Contract) ---

func register_camera_shaker(_shaker: CameraShaker) -> void: pass
func unregister_camera_shaker() -> void: pass
func is_camera_shaker_registered() -> bool: return false
func request_screen_shake(_shake_effect: ScreenShakeEffect) -> void: pass
func play_vfx(_effect: VFXEffect, _global_position: Vector2, _direction: Vector2 = Vector2.ZERO) -> void: pass
func request_hit_stop(_duration: float) -> void: pass
func prewarm_shaders_async(_effects: Array[ShaderEffect], _prewarm_viewport: SubViewport) -> void: pass
func get_debug_stats() -> Dictionary: return {}
func increment_shader_count() -> void: pass
func decrement_shader_count() -> void: pass

## Applies a shader effect directly to a target CanvasItem.
func apply_shader_effect(
	_target_node: CanvasItem, _effect: ShaderEffect, _overrides: Dictionary, _opts: Dictionary
) -> Tween:
	return null

## Cancels any active shader effect on a specific node.
func cancel_effect_on_node(_target_node: CanvasItem) -> void: pass

=====================================
FILE: ./src/api/interfaces/IPoolable.gd
=====================================
# src/api/interfaces/IPoolable.gd
## The "interface" contract for any scene that can be managed by the [ObjectPool].
class_name IPoolable
extends Node

# --- The Contract ---


## Prepares the node for use after being retrieved from the pool.
## Receives a dictionary of dependencies, which should include the ServiceLocator.
func activate(_dependencies: Dictionary = {}) -> void:
	pass


## Prepares the node to be returned to the pool's inactive list.
##
## CONTRACT: Any implementation of this method MUST release all external
## references it holds, especially references to services obtained from the
## ServiceLocator. This is critical for preventing memory leaks and crashes
## during scene transitions.
func deactivate() -> void:
	pass


=====================================
FILE: ./src/api/interfaces/IObjectPool.gd
=====================================
# src/api/interfaces/IObjectPool.gd
## The "interface" contract for a system that manages pools of reusable nodes.
## This decouples systems from the concrete ObjectPool autoload, enabling
## substitution with fakes or mocks during testing.
class_name IObjectPool
extends Node

# --- Virtual Methods (The Contract) ---

## Retrieves an inactive instance from the specified pool.
func get_instance(_pool_name: StringName) -> Node:
	return null

## Returns an active instance to its pool.
func return_instance(_instance: Node) -> void:
	pass

## Returns all active instances in all pools to their inactive state.
func reset() -> void:
	pass

## Returns a dictionary containing the active/total counts for each pool.
func get_pool_stats() -> Dictionary:
	return {}

=====================================
FILE: ./src/api/interfaces/ISceneController.gd
=====================================
# src/api/interfaces/ISceneController.gd
## The conceptual "interface" for all main scene controller scripts.
##
## This defines a formal contract for scenes that require explicit cleanup
## logic to be run by the SceneManager before the scene is changed.
class_name ISceneController
extends Node

# --- Virtual Methods ---


## Called by the SceneManager immediately before it changes the scene.
## This function can be async to allow for cleanup animations or sequences.
func scene_exiting() -> void:
	pass

=====================================
FILE: ./src/api/interfaces/IDamageable.gd
=====================================
# src/api/interfaces/IDamageable.gd
## The "interface" contract for any component that can take damage.
## By extending IComponent, it ensures that any damageable object
## also respects the standard component lifecycle (setup, teardown).
class_name IDamageable
extends IComponent

# --- The Contract (Virtual Method) ---

## Applies damage to the object.
## [param damage_info]: A [DamageInfo] resource detailing the damage event.
## [return]: A [DamageResult] resource indicating the outcome.
func apply_damage(_damage_info: DamageInfo) -> DamageResult:
	push_warning("IDamageable.apply_damage() was called but not overridden by the implementer.")
	return DamageResult.new()


=====================================
FILE: ./src/api/interfaces/IComponent.gd
=====================================
# src/api/interfaces/IComponent.gd
## The conceptual "interface" for all entity components.
##
## This script defines the formal contract that components like [HealthComponent]
## and [CombatComponent] adhere to. It is not meant to be instanced directly.
class_name IComponent
extends Node

# --- Virtual Methods ---


## Initializes the component and injects its dependencies.
##
## [param p_owner]: A reference to the node that owns this component.
## [param p_dependencies]: A dictionary of any other required nodes or resources.
func setup(_p_owner: Node, _p_dependencies: Dictionary = {}) -> void:
	pass


## Called when the owner is being destroyed to clean up connections and references.
func teardown() -> void:
	pass


=====================================
FILE: ./src/projectiles/player_shot.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://cmdkxwvysirh1"]

[ext_resource type="Script" path="res://src/projectiles/player_shot.gd" id="1_4wg7x"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_playershot"]
size = Vector2(40, 40)

[node name="PlayerShot" type="Area2D" groups=["player_projectile"]]
collision_layer = 0
collision_mask = 148
script = ExtResource("1_4wg7x")
metadata/pool_name = &"player_shots"

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
color = Color(0.92549, 0.92549, 0.92549, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_playershot")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-20, -20, 40, 40)

[connection signal="area_entered" from="." to="." method="_on_area_entered"]
[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="screen_entered" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_entered"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_exited"]

=====================================
FILE: ./src/projectiles/turret_shot.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://d1e2f3g4h5i6j"]

[ext_resource type="Script" path="res://src/projectiles/turret_shot.gd" id="1_turret_shot_script"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_turretshot"]
size = Vector2(20, 20)

[node name="TurretShot" type="Area2D"]
collision_layer = 16
collision_mask = 193
script = ExtResource("1_turret_shot_script")
metadata/pool_name = &"turret_shots"

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -10.0
offset_top = -10.0
offset_right = 10.0
offset_bottom = 10.0
color = Color(0.898039, 0.898039, 0.898039, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_turretshot")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-10, -10, 20, 20)

[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="screen_entered" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_entered"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_exited"]

=====================================
FILE: ./src/projectiles/boss_shot.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://cxnmr7yrvchve"]

[ext_resource type="Script" path="res://src/projectiles/boss_shot.gd" id="1_4qgog"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_bossshot"]
size = Vector2(60, 60)

[node name="BossShot" type="Area2D"]
collision_layer = 16
collision_mask = 65
script = ExtResource("1_4qgog")
metadata/pool_name = &"boss_shots"

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -30.0
offset_top = -30.0
offset_right = 30.0
offset_bottom = 30.0
color = Color(1, 0.8, 0.4, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_bossshot")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-30, -30, 60, 60)

[connection signal="area_entered" from="." to="." method="_on_area_entered"]
[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="screen_entered" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_entered"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_exited"]

=====================================
FILE: ./src/projectiles/turret_shot.gd
=====================================
# res://src/projectiles/turret_shot.gd
class_name TurretShot
extends "res://src/projectiles/base_projectile.gd"


func _ready() -> void:
	add_to_group(Identifiers.Groups.ENEMY_PROJECTILE)
	visual.color = Palette.COLOR_UI_ACCENT_PRIMARY


=====================================
FILE: ./src/projectiles/player_shot.gd
=====================================
# res://src/projectiles/player_shot.gd
class_name PlayerShot
extends "res://src/projectiles/base_projectile.gd"

# Per-projectile tuneable default (Inspector-friendly).
@export var default_speed: float = 1000.0


func _ready() -> void:
	# Visual only; movement & collision handled by BaseProjectile.
	if is_instance_valid(visual):
		visual.color = Palette.COLOR_PLAYER_PROJECTILE


# Ensure the speed is set every time this instance is (re)activated by the pool.
func activate(p_services: ServiceLocator) -> void:
	# First let the base class do its activation
	super.activate(p_services)
	# Then apply player-shot-specific runtime defaults so they apply on reuse.
	speed = default_speed


func _on_area_entered(area: Area2D) -> void:
	if not _is_active:
		return
	# Player shots can destroy enemy projectiles on contact.
	if area.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE):
		if is_instance_valid(_services):
			_services.object_pool.return_instance.call_deferred(area)

	# Then proceed with the base collision handling.
	super._on_area_entered(area)


=====================================
FILE: ./src/projectiles/boss_shot.gd
=====================================
# res://src/projectiles/boss_shot.gd
class_name BossShot
extends "res://src/projectiles/base_projectile.gd"


func _ready() -> void:
	visual.color = Palette.COLOR_HAZARD_PRIMARY
	add_to_group(Identifiers.Groups.ENEMY_PROJECTILE)


# --- Overridden Signal Handlers ---


func _on_body_entered(_body: Node) -> void:
	if not _is_active:
		return
	# This projectile is destroyed by solid world geometry.
	if is_instance_valid(_services):
		_services.object_pool.return_instance.call_deferred(self)


func _on_area_entered(area: Area2D) -> void:
	if not _is_active:
		return
	# Standard collision for player hurtbox, etc.
	_handle_collision(area)


=====================================
FILE: ./src/projectiles/homing_boss_shot.tscn
=====================================
[gd_scene load_steps=3 format=3 uid="uid://homing_boss_shot_scene"]

[ext_resource type="Script" path="res://src/projectiles/homing_boss_shot.gd" id="1_homing_shot_script"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_homing_shot_body"]
size = Vector2(20, 20)

[node name="HomingBossShot" type="Area2D"]
collision_layer = 16
collision_mask = 65
script = ExtResource("1_homing_shot_script")
metadata/pool_name = &"homing_boss_shots"

[node name="ColorRect" type="ColorRect" parent="."]
unique_name_in_owner = true
offset_left = -10.0
offset_top = -10.0
offset_right = 10.0
offset_bottom = 10.0

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
unique_name_in_owner = true
shape = SubResource("RectangleShape2D_homing_shot_body")

[node name="VisibleOnScreenNotifier2D" type="VisibleOnScreenNotifier2D" parent="."]
rect = Rect2(-10, -10, 20, 20)

[node name="LifetimeTimer" type="Timer" parent="."]
unique_name_in_owner = true
one_shot = true

[connection signal="area_entered" from="." to="." method="_on_area_entered"]
[connection signal="body_entered" from="." to="." method="_on_body_entered"]
[connection signal="screen_entered" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_entered"]
[connection signal="screen_exited" from="VisibleOnScreenNotifier2D" to="." method="_on_screen_exited"]
[connection signal="timeout" from="LifetimeTimer" to="." method="_on_lifetime_timer_timeout"]

=====================================
FILE: ./src/projectiles/homing_boss_shot.gd
=====================================
# src/projectiles/homing_boss_shot.gd
class_name HomingBossShot
extends "res://src/projectiles/base_projectile.gd"

# --- Node References ---
@onready var lifetime_timer: Timer = $LifetimeTimer

# --- Exposed config
@export var lifespan: float = 3.0

# --- Private Member Variables ---
var _player_ref: WeakRef
var _active_tween: Tween
var _pending_start_on_screen: bool = false

const FALLBACK_WAIT_SECONDS := 0.05


func _ready() -> void:
	add_to_group(Identifiers.Groups.ENEMY_PROJECTILE)
	visual.color = Palette.COLOR_HAZARD_PRIMARY


func _move(delta: float) -> void:
	if not _player_ref or not _player_ref.get_ref():
		global_position += transform.x * speed * delta
		return

	var player_node: Node = _player_ref.get_ref()
	var direction_to_player: Vector2 = (player_node.global_position - global_position).normalized()
	rotation = lerp_angle(rotation, direction_to_player.angle(), 0.05)
	global_position += transform.x * speed * delta


func activate(p_services: ServiceLocator) -> void:
	super.activate(p_services)

	var player_node: Node = get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)
	_player_ref = weakref(player_node)

	if is_instance_valid(lifetime_timer):
		lifetime_timer.start(lifespan)

	if is_instance_valid(_active_tween):
		_active_tween.kill()
		_active_tween = null

	visual.scale = Vector2.ONE
	collision_shape.scale = Vector2.ONE

	call_deferred("_maybe_schedule_shrink", lifespan)


func deactivate() -> void:
	if is_instance_valid(_active_tween):
		_active_tween.kill()
		_active_tween = null

	visual.scale = Vector2.ONE
	collision_shape.scale = Vector2.ONE

	_pending_start_on_screen = false
	super.deactivate()


func _maybe_schedule_shrink(p_lifespan: float) -> void:
	if not _is_active:
		return

	await get_tree().process_frame

	if not _is_active:
		return

	if _has_been_on_screen:
		_start_shrink_tween(p_lifespan)
		return

	_pending_start_on_screen = true

	var timer: SceneTreeTimer = get_tree().create_timer(FALLBACK_WAIT_SECONDS)
	await timer.timeout

	if _pending_start_on_screen and _is_active:
		_pending_start_on_screen = false
		_start_shrink_tween(p_lifespan)


func _start_shrink_tween(p_lifespan: float) -> void:
	if not _is_active:
		return

	if is_instance_valid(_active_tween):
		_active_tween.kill()

	_active_tween = create_tween()
	_active_tween.set_trans(Tween.TRANS_LINEAR).set_ease(Tween.EASE_IN_OUT)
	_active_tween.tween_property(visual, "scale", Vector2.ZERO, p_lifespan)
	_active_tween.tween_property(collision_shape, "scale", Vector2.ZERO, p_lifespan)


func _on_lifetime_timer_timeout() -> void:
	if not _is_active:
		return
	if is_instance_valid(_services):
		_services.object_pool.return_instance.call_deferred(self)


func _on_screen_entered() -> void:
	super._on_screen_entered()

	if _pending_start_on_screen:
		_pending_start_on_screen = false
		_start_shrink_tween(lifespan)


=====================================
FILE: ./src/projectiles/base_projectile.gd
=====================================
# src/projectiles/base_projectile.gd
class_name BaseProjectile
extends Area2D

# --- Node References ---
@onready var collision_shape: CollisionShape2D = $CollisionShape2D
@onready var visual: ColorRect = $ColorRect

# --- Public Properties ---
@export var speed: float = 400.0
@export var damage: int = 1
var direction: Vector2 = Vector2.RIGHT

# --- Private Member Variables ---
var _services: ServiceLocator
var _is_active: bool = false
var _has_been_on_screen: bool = false

# --- Godot Lifecycle ---


func _physics_process(delta: float) -> void:
	if not _is_active:
		return
	_move(delta)


# --- Virtual Hooks ---


## Can be overridden by child classes for custom movement (e.g., homing).
func _move(delta: float) -> void:
	global_position += direction * speed * delta


# --- IPoolable Contract ---


func activate(p_services: ServiceLocator) -> void:
	self._services = p_services
	assert(is_instance_valid(_services), "%s requires a ServiceLocator dependency." % [self.get_class()])

	_has_been_on_screen = false
	visible = true
	_is_active = true
	process_mode = PROCESS_MODE_INHERIT
	if is_instance_valid(collision_shape):
		collision_shape.disabled = false


func deactivate() -> void:
	visible = false
	_is_active = false
	process_mode = PROCESS_MODE_DISABLED
	if is_instance_valid(collision_shape):
		collision_shape.disabled = true
	_services = null


# --- Centralized Collision & Cleanup ---


func _handle_collision(target: Node) -> void:
	var damageable = _services.combat_utils.find_damageable(target)
	if is_instance_valid(damageable):
		var damage_info := DamageInfo.new()
		damage_info.amount = damage
		damage_info.source_node = self
		damage_info.impact_position = global_position
		damage_info.impact_normal = -direction.normalized() if not direction.is_zero_approx() else Vector2.ZERO
		damageable.apply_damage(damage_info)

	if is_instance_valid(_services):
		_services.object_pool.return_instance.call_deferred(self)


# --- Signal Handlers ---


func _on_body_entered(body: Node) -> void:
	if not _is_active:
		return
	_handle_collision(body)


func _on_area_entered(area: Area2D) -> void:
	if not _is_active:
		return
	_handle_collision(area)


func _on_screen_entered() -> void:
	_has_been_on_screen = true


func _on_screen_exited() -> void:
	if not _is_active:
		return

	if not _has_been_on_screen:
		return

	if is_instance_valid(_services):
		_services.object_pool.return_instance.call_deferred(self)


=====================================
FILE: ./src/data/dialogue/dialogue_line.gd
=====================================
# src/data/dialogue/dialogue_line.gd
@tool
## A custom Resource holding the data for a single line of dialogue.
class_name DialogueLine
extends Resource

@export var speaker: String = ""
@export_multiline var text: String = ""
@export var portrait: Texture2D
@export var voice: AudioStream
@export_range(0.0, 5.0, 0.1) var wait_after: float = 0.2


=====================================
FILE: ./src/data/dialogue/test_conversation.tres
=====================================
[gd_resource type="Resource" script_class="DialogueData" load_steps=4 format=3 uid="uid://ce4ka1q3xh4bd"]

[ext_resource type="Script" uid="uid://duqmqwi2qjc7y" path="res://src/data/dialogue/dialogue_data.gd" id="1_dialogue_data"]
[ext_resource type="Script" uid="uid://cxxrvo55hssvv" path="res://src/data/dialogue/dialogue_line.gd" id="2_dialogue_line"]

[sub_resource type="Resource" id="DialogueLine_1"]
script = ExtResource("2_dialogue_line")
speaker = "BOX BATTLE"
text = "This is the first line of a test conversation."
wait_after = 0.2

[resource]
script = ExtResource("1_dialogue_data")
lines = Array[ExtResource("2_dialogue_line")]([SubResource("DialogueLine_1")])


=====================================
FILE: ./src/data/dialogue/dialogue_data.gd
=====================================
# src/data/dialogue/dialogue_data.gd
@tool
## A custom Resource that holds the data for a full conversation.
class_name DialogueData
extends Resource

## An array of DialogueLine resources that make up the conversation.
@export var lines: Array[DialogueLine] = []


=====================================
FILE: ./src/data/audio/sfx_player_footsteps.tres
=====================================
[gd_resource type="AudioStreamRandomizer" load_steps=2 format=3]

# TODO: Add footstep audio samples and configure randomization.


=====================================
FILE: ./src/data/audio/sfx_player_impact.tres
=====================================
[gd_resource type="AudioStreamRandomizer" load_steps=2 format=3]

# TODO: Add impact audio samples and configure randomization.


=====================================
FILE: ./src/data/combat_config.tres
=====================================
[gd_resource type="Resource" script_class="CombatConfig" load_steps=4 format=3 uid="uid://kov03lmcorvh"]

[ext_resource type="Script" uid="uid://bhpg5eaxemkw1" path="res://src/core/data/config/combat_config.gd" id="1_config"]
[ext_resource type="Shape2D" uid="uid://c1b2d3e4f5g6h" path="res://src/entities/player/data/forward_attack_shape.tres" id="2_forward_shape"]
[ext_resource type="Shape2D" uid="uid://c0dt7jqwtnbr" path="res://src/entities/player/data/upward_attack_shape.tres" id="3_upward_shape"]

[resource]
script = ExtResource("1_config")
player_max_health = 5
player_max_healing_charges = 1
player_heal_duration = 2.0
player_determination_per_charge = 10
player_invincibility_duration = 1.5
player_speed = 450.0
player_jump_force = 680.0
player_jump_release_dampener = 0.4
player_coyote_time = 0.1
player_jump_buffer = 0.1
player_fast_fall_gravity_multiplier = 1.4
player_max_air_jumps = 1
player_wall_slide_speed = 120.0
player_wall_coyote_time = 0.05
player_wall_jump_force_x = 1650.0
player_wall_jump_force_y = 680.0
player_dash_speed = 1400.0
player_dash_duration = 0.15
player_dash_cooldown = 0.5
player_forward_attack_shape = ExtResource("2_forward_shape")
player_upward_attack_shape = ExtResource("3_upward_shape")
player_attack_cooldown = 0.12
player_attack_duration = 0.1
player_attack_friction = 2000.0
player_charge_time = 0.35
player_pogo_force = 450.0
player_knockback_speed = 400.0
player_knockback_duration = 0.1
player_hazard_knockback_speed = 400.0
player_close_range_threshold = 75.0
boss_health = 30
boss_patrol_speed = 100.0
boss_invincibility_duration = 0.1
boss_lunge_speed = 1200.0
homing_shot_damage = 1
homing_shot_speed = 250.0
homing_shot_lifespan = 10.0
gravity = 1200.0
player_melee_close_range_hit_stop_duration = 0.025
player_damage_taken_hit_stop_duration = 0.04
boss_phase_change_hit_stop_duration = 0.1
boss_death_hit_stop_duration = 0.2


=====================================
FILE: ./src/data/layouts/level_layout.gd
=====================================
# src/data/layouts/level_layout.gd
@tool
## A custom Resource that holds the terrain data for a level.
##
## Includes a custom configuration warning to ensure that all rows in the
## terrain data array have the same length for valid parsing.
class_name LevelLayout
extends Resource

# --- Editor Properties ---
@export var terrain_data: PackedStringArray = []:
	set(value):
		terrain_data = value
		# Tell the editor to refresh its property list, which re-runs the warning check.
		notify_property_list_changed()

# --- Godot Lifecycle Methods ---


func _get_configuration_warnings() -> PackedStringArray:
	var warnings = PackedStringArray()
	if terrain_data.is_empty():
		warnings.append("Terrain Data is empty. The level will be blank.")
		return warnings

	var first_row_length = -1
	if not terrain_data[0].is_empty():
		first_row_length = terrain_data[0].length()
	else:  # Handle case where the first row is empty
		warnings.append("The first row of terrain data cannot be empty.")
		return warnings

	for i in range(1, terrain_data.size()):
		if terrain_data[i].length() != first_row_length:
			var msg = "Row %d (length %d) has a different length than the first row (length %d)."
			warnings.append(msg % [i + 1, terrain_data[i].length(), first_row_length])
			break  # Only show the first error found

	return warnings


=====================================
FILE: ./src/data/layouts/layout_00.tres
=====================================
[gd_resource type="Resource" script_class="LevelLayout" load_steps=2 format=3 uid="uid://bst2lw60wetic"]

[ext_resource type="Script" uid="uid://c01s26irlgw56" path="res://src/data/layouts/level_layout.gd" id="1_layout"]

[resource]
script = ExtResource("1_layout")
terrain_data = PackedStringArray("####################", "#..................#", "#....@.............#", "#............&.....#", "#.........#--#.....#", "#.........#..#.....#", "#.........#--#.....#", "#.........#..#.....#", "#..T......#..#.....#", "#.........#..#.....#", "#..................#", "#..................#", "#.........####.....#", "#.........####.....#", "#.........####.....#", "####......####.....#", "####......####..T..#", "####...............#", "#..................#", "###############^^^##")


=====================================
FILE: ./src/data/encounters/encounter_00.tres
=====================================
[gd_resource type="Resource" script_class="EncounterData" load_steps=5 format=3 uid="uid://4lptu40or7m1"]

[ext_resource type="Script" uid="uid://co2urq51qk44e" path="res://src/data/encounters/encounter_data.gd" id="1_encounter"]
[ext_resource type="PackedScene" uid="uid://dmej4a7ykn2q0" path="res://src/entities/boss/base_boss.tscn" id="2_boss_scene"]
[ext_resource type="Resource" uid="uid://bst2lw60wetic" path="res://src/data/layouts/layout_00.tres" id="2_x64bm"]
[ext_resource type="PackedScene" uid="uid://c7d8faf0g1h2i" path="res://src/entities/minions/minion.tscn" id="3_turret_scene"]

[resource]
script = ExtResource("1_encounter")

; --- Layout & Spawning ---
level_layout = ExtResource("2_x64bm")
player_spawn_marker = "@"
boss_spawn_marker = "&"

; --- Boss ---
boss_scene = ExtResource("2_boss_scene")

; --- Minions ---
minion_spawns = {
"T": ExtResource("3_turret_scene")
}

=====================================
FILE: ./src/data/encounters/encounter_data.gd
=====================================
# src/data/encounters/encounter_data.gd
@tool
## A custom Resource that defines a complete encounter or stage.
##
## This allows designers to create new levels by combining a [LevelLayout],
## a boss scene, and minion definitions without writing any code.
class_name EncounterData
extends Resource

# --- Editor Properties ---
@export_group("Layout")
@export var level_layout: LevelLayout
@export var player_spawn_marker: String = "@"

@export_group("Boss")
@export var boss_scene: PackedScene
@export var boss_spawn_marker: String = "&"

@export_group("Minions")
## The key is the character marker in the layout file (e.g., "T").
## The value is the PackedScene for that minion.
@export var minion_spawns: Dictionary = {}


=====================================
FILE: ./src/data/effects/entity_hit_flash_effect.tres
=====================================
[gd_resource type="Resource" script_class="ShaderEffect" load_steps=3 format=3 uid="uid://entity_hit_flash_effect"]

[ext_resource type="Script" path="res://src/core/data/effects/shader_effect.gd" id="1_script"]
[ext_resource type="ShaderMaterial" uid="uid://entity_hit_flash_mat" path="res://materials/entity_hit_flash_material.tres" id="2_material"]

[resource]
script = ExtResource("1_script")
material = ExtResource("2_material")
duration = 0.12
target_scope = 0
coalesce_window = 0.1

=====================================
FILE: ./src/entities/base_entity.gd
=====================================
# src/entities/base_entity.gd
@tool
## The generic base class for all component-based entities in the game.
class_name BaseEntity
extends CharacterBody2D

# --- Editor Properties ---
@export var archetype: EntityArchetype

# --- Private Member Variables ---
var _components_initialized: bool = false
var _services: ServiceLocator
var _components: Dictionary = {}
var _components_by_interface: Dictionary = {} # NEW: Cache for interface lookups

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	if Engine.is_editor_hint():
		return
	_build_from_archetype()


# --- Public Methods ---


## Retrieves a component from this entity by its script type or an interface it implements.
func get_component(type: Script) -> IComponent:
	# First, try a direct lookup by the component's concrete class.
	if _components.has(type):
		return _components.get(type)

	# If that fails, try looking up by an implemented interface.
	if _components_by_interface.has(type):
		return _components_by_interface.get(type)

	return null


## Helper that asserts and provides a clear error if a required component is missing.
func require_component(type: Script) -> IComponent:
	var c = get_component(type)
	if not is_instance_valid(c):
		push_error("Missing required component: %s on entity %s" % [type.resource_path, name])
	return c


func inject_dependencies(p_services: ServiceLocator) -> void:
	_services = p_services


func teardown() -> void:
	for child in get_children():
		if child is IComponent:
			child.teardown()


func setup_components(
	shared_dependencies: Dictionary = {}, per_component_dependencies: Dictionary = {}
) -> void:
	if _components_initialized:
		return

	var base_shared_deps = shared_dependencies.duplicate()
	base_shared_deps["services"] = _services

	for child in get_children():
		if not (child is IComponent):
			continue

		var class_key: String = child.get_script().get_global_name()

		if child.has_meta("REQUIRED_DEPS"):
			var required = child.get_meta("REQUIRED_DEPS")
			var all_deps_for_check = base_shared_deps.duplicate()
			if per_component_dependencies.has(child):
				all_deps_for_check.merge(per_component_dependencies[child])
			
			if per_component_dependencies.has(class_key):
				all_deps_for_check.merge(per_component_dependencies[class_key])

			if not DependencyValidator.validate(child, all_deps_for_check, required):
				push_error("Dependency validation failed for %s. Aborting entity setup." % child.name)
				return

		var merged_deps := base_shared_deps.duplicate()

		if per_component_dependencies.has(child):
			merged_deps.merge(per_component_dependencies[child])

		if per_component_dependencies.has(class_key):
			merged_deps.merge(per_component_dependencies[class_key])

		if child.has_method("setup"):
			child.setup(self, merged_deps)

	_components_initialized = true


# --- Private Methods ---


func _build_from_archetype() -> void:
	if not is_instance_valid(archetype):
		push_error("Entity '%s' is missing its Archetype resource." % name)
		return

	for component_scene in archetype.components:
		if is_instance_valid(component_scene):
			var component_instance = component_scene.instantiate()
			add_child(component_instance)
		else:
			push_warning("Archetype for '%s' contains an invalid component scene." % name)

	_cache_components_by_type()


func _cache_components_by_type() -> void:
	_components.clear()
	_components_by_interface.clear()
	
	for child in get_children():
		if not child is IComponent:
			continue

		var component_script: Script = child.get_script()
		_components[component_script] = child
		
		var base_script: Script = component_script.get_base_script()
		while is_instance_valid(base_script):
			if base_script.resource_path.is_empty() or base_script == IComponent:
				break
			_components_by_interface[base_script] = child
			base_script = base_script.get_base_script()


=====================================
FILE: ./src/entities/archetypes/player_archetype.tres
=====================================
[gd_resource type="Resource" script_class="EntityArchetype" load_steps=10 format=3 uid="uid://player_archetype_resource"]

[ext_resource type="Script" path="res://src/entities/archetypes/entity_archetype.gd" id="1_archetype"]
[ext_resource type="PackedScene" uid="uid://dpl3w8xqyq1a2" path="res://src/entities/components/health_component.tscn" id="2_health"]
[ext_resource type="PackedScene" uid="uid://b1x2y3z4a5b6" path="res://src/entities/components/combat_component.tscn" id="3_combat"]
[ext_resource type="PackedScene" uid="uid://c7d8e9f0g1h2" path="res://src/entities/components/input_component.tscn" id="4_input"]
[ext_resource type="PackedScene" uid="uid://i3j4k5l6m7n8" path="res://src/entities/components/base_state_machine.tscn" id="5_fsm"]
[ext_resource type="PackedScene" uid="uid://o9p0q1r2s3t4" path="res://src/entities/player/components/player_physics_component.tscn" id="6_phys"]
[ext_resource type="PackedScene" uid="uid://u5v6w7x8y9z0" path="res://src/entities/player/components/player_ability_component.tscn" id="7_abil"]
[ext_resource type="PackedScene" uid="uid://a1b2c3d4e5f6" path="res://src/entities/player/components/player_resource_component.tscn" id="8_res"]
[ext_resource type="PackedScene" uid="uid://g7h8i9j0k1l2" path="res://src/entities/components/fx_component.tscn" id="9_fx"]

[resource]
script = ExtResource("1_archetype")
components = [
	; --- Core Components ---
	ExtResource("2_health"), 
	ExtResource("3_combat"), 
	ExtResource("4_input"), 
	ExtResource("5_fsm"), 
	ExtResource("9_fx"), 
	
	; --- Player-Specific Components ---
	ExtResource("6_phys"), 
	ExtResource("7_abil"), 
	ExtResource("8_res")
]

=====================================
FILE: ./src/entities/archetypes/boss_archetype.tres
=====================================
[gd_resource type="Resource" script_class="EntityArchetype" load_steps=5 format=3 uid="uid://boss_archetype_resource"]

[ext_resource type="Script" path="res://src/entities/archetypes/entity_archetype.gd" id="1_archetype"]
[ext_resource type="PackedScene" uid="uid://dpl3w8xqyq1a2" path="res://src/entities/components/health_component.tscn" id="2_health"]
[ext_resource type="PackedScene" uid="uid://i3j4k5l6m7n8" path="res://src/entities/components/base_state_machine.tscn" id="3_fsm"]
[ext_resource type="PackedScene" uid="uid://g7h8i9j0k1l2" path="res://src/entities/components/fx_component.tscn" id="4_fx"]

[resource]
script = ExtResource("1_archetype")

; --- Core Components ---
components = [ExtResource("2_health"), ExtResource("3_fsm"), ExtResource("4_fx")]

=====================================
FILE: ./src/entities/archetypes/minion_archetype.tres
=====================================
[gd_resource type="Resource" script_class="EntityArchetype" load_steps=5 format=3 uid="uid://turret_archetype_resource"]

[ext_resource type="Script" path="res://src/entities/archetypes/entity_archetype.gd" id="1_archetype"]
[ext_resource type="PackedScene" uid="uid://dpl3w8xqyq1a2" path="res://src/entities/components/health_component.tscn" id="2_health"]
[ext_resource type="PackedScene" uid="uid://i3j4k5l6m7n8" path="res://src/entities/components/base_state_machine.tscn" id="3_fsm"]
[ext_resource type="PackedScene" uid="uid://g7h8i9j0k1l2" path="res://src/entities/components/fx_component.tscn" id="4_fx"]

[resource]
script = ExtResource("1_archetype")

; --- Core Components ---
components = [ExtResource("2_health"), ExtResource("3_fsm"), ExtResource("4_fx")]

=====================================
FILE: ./src/entities/archetypes/entity_archetype.gd
=====================================
# src/entities/archetypes/entity_archetype.gd
@tool
## A data resource that defines the component-based structure of an entity.
##
## This acts as a blueprint, telling a BaseEntity which components to instance
## and attach to itself at runtime.
class_name EntityArchetype
extends Resource

## An array of PackedScene files, where each scene is a component
## (e.g., HealthComponent.tscn, InputComponent.tscn).
@export var components: Array[PackedScene] = []


=====================================
FILE: ./src/entities/boss/attack_patterns/lunge_logic.gd
=====================================
# src/entities/boss/attack_patterns/lunge_logic.gd
@tool
## Concrete AttackLogic for executing a high-speed, invulnerable dash.
class_name LungeLogic
extends AttackLogic


func get_telegraph_info(owner: BaseBoss, _pattern: AttackPattern) -> Dictionary:
	var lunge_width = 800.0
	var owner_width = owner.get_node("CollisionShape2D").shape.size.x
	var x_offset = (lunge_width / 2.0) + (owner_width / 2.0)

	return {"size": Vector2(lunge_width, 60), "offset": Vector2(x_offset, 0)}


func execute(owner: BaseBoss, pattern: AttackPattern) -> Callable:
	var lunge_params = {"pattern": pattern}
	var sm: BaseStateMachine = owner.get_component(BaseStateMachine)
	return sm.change_state.bind(Identifiers.BossStates.LUNGE, lunge_params)


=====================================
FILE: ./src/entities/boss/attack_patterns/lunge_attack.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://y6g5o6f7h8i9"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" path="res://src/entities/boss/attack_patterns/lunge_logic.tres" id="2_lunge_logic"]

[resource]
script = ExtResource("1_attack_pattern")

; --- Core Timings ---
telegraph_duration = 0.8
attack_duration = 0.5
cooldown = 2.0

; --- Logic-Specific Data ---
logic = ExtResource("2_lunge_logic")
projectile_count = 0
volley_delay = 0.0

=====================================
FILE: ./src/entities/boss/attack_patterns/homing_omni_burst_pattern.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://homing_omni_burst_tres"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" uid="uid://homing_logic_tres" path="res://src/entities/boss/attack_patterns/homing_omni_burst_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")

; --- Core Timings ---
telegraph_duration = 1.2
attack_duration = 1.0
cooldown = 3.5

; --- Logic-Specific Data ---
logic = ExtResource("2_logic")
projectile_count = 30
volley_delay = 0.0

=====================================
FILE: ./src/entities/boss/attack_patterns/volley_3_shot.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://k3dglh3t1b4a"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" path="res://src/entities/boss/attack_patterns/volley_shot_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")

; --- Core Timings ---
telegraph_duration = 0.7
attack_duration = 0.6
cooldown = 2.5

; --- Logic-Specific Data ---
logic = ExtResource("2_logic")
projectile_count = 3
volley_delay = 0.2

=====================================
FILE: ./src/entities/boss/attack_patterns/volley_5_shot.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://z1x2y3a4b5c6"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" path="res://src/entities/boss/attack_patterns/volley_shot_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")

; --- Core Timings ---
telegraph_duration = 0.6
attack_duration = 1.0
cooldown = 2.5

; --- Logic-Specific Data ---
logic = ExtResource("2_logic")
projectile_count = 5
volley_delay = 0.15

=====================================
FILE: ./src/entities/boss/attack_patterns/projectile_logic.gd
=====================================
# src/entities/boss/attack_patterns/projectile_logic.gd
@tool
## Concrete AttackLogic for firing one or more projectiles.
class_name ProjectileLogic
extends AttackLogic


func get_telegraph_info(_owner: BaseBoss, _pattern: AttackPattern) -> Dictionary:
	return {"size": Vector2(150, 150), "offset": Vector2(100, 0)}


func execute(owner: BaseBoss, pattern: AttackPattern) -> Callable:
	if pattern.projectile_count <= 1:
		return owner.fire_shot_at_player.bind()
	else:
		return owner.fire_volley.bind(pattern.projectile_count, pattern.volley_delay)


=====================================
FILE: ./src/entities/boss/attack_patterns/volley_shot_logic.tres
=====================================
[gd_resource type="Resource" script_class="ProjectileLogic" load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/projectile_logic.gd" id="1_projectile_logic"]

[resource]
script = ExtResource("1_projectile_logic")
projectile_count = 3
volley_delay = 0.2


=====================================
FILE: ./src/entities/boss/attack_patterns/attack_pattern.gd
=====================================
# src/entities/boss/attack_patterns/attack_pattern.gd
@tool
## A data resource that defines the properties of a single boss attack.
##
## This combines timing data with a swappable "AttackLogic" resource that
## contains the actual execution code for the attack (Strategy Pattern).
class_name AttackPattern
extends Resource

# --- Editor Properties ---
@export var logic: AttackLogic  ## The script that defines HOW this attack behaves.
@export var telegraph_duration: float = 0.5
@export var attack_duration: float = 0.1
@export var cooldown: float = 1.5

@export_group("Attack-Specific Data")
# --- ProjectileLogic Data ---
@export var projectile_count: int = 1
@export var volley_delay: float = 0.2


=====================================
FILE: ./src/entities/boss/attack_patterns/lunge_logic.tres
=====================================
[gd_resource type="Resource" script_class="LungeLogic" load_steps=2 format=3 uid="uid://lunge_logic_tres_id"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/lunge_logic.gd" id="1_lunge_logic"]

[resource]
script = ExtResource("1_lunge_logic")


=====================================
FILE: ./src/entities/boss/attack_patterns/single_shot.tres
=====================================
[gd_resource type="Resource" script_class="AttackPattern" load_steps=3 format=3 uid="uid://bve7t5ucr1k"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/attack_pattern.gd" id="1_attack_pattern"]
[ext_resource type="Resource" path="res://src/entities/boss/attack_patterns/single_shot_logic.tres" id="2_logic"]

[resource]
script = ExtResource("1_attack_pattern")

; --- Core Timings ---
telegraph_duration = 0.5
attack_duration = 0.1
cooldown = 1.5

; --- Logic-Specific Data ---
logic = ExtResource("2_logic")
projectile_count = 1
volley_delay = 0.2

=====================================
FILE: ./src/entities/boss/attack_patterns/homing_omni_burst_logic.tres
=====================================
[gd_resource type="Resource" script_class="HomingOmniBurstLogic" load_steps=2 format=3 uid="uid://homing_logic_tres"]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/homing_omni_burst_logic.gd" id="1_logic_script"]

[resource]
script = ExtResource("1_logic_script")
projectile_count = 30
projectile_speed = 250.0

=====================================
FILE: ./src/entities/boss/attack_patterns/single_shot_logic.tres
=====================================
[gd_resource type="Resource" script_class="ProjectileLogic" load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/boss/attack_patterns/projectile_logic.gd" id="1_projectile_logic"]

[resource]
script = ExtResource("1_projectile_logic")
projectile_count = 1
volley_delay = 0.2


=====================================
FILE: ./src/entities/boss/attack_patterns/attack_logic.gd
=====================================
# src/entities/boss/attack_patterns/attack_logic.gd
@tool
## The abstract base class for all boss attack execution logic.
## This implements the Strategy Pattern for boss attacks.
class_name AttackLogic
extends Resource


## Returns the visual information for this attack's telegraph.
## The dictionary should contain: { "size": Vector2, "offset": Vector2 }
## "offset" is the local position relative to the boss.
func get_telegraph_info(_owner: BaseBoss, _pattern: AttackPattern) -> Dictionary:
	# Default to a simple square
	return {
		"size": Vector2(150, 150), "offset": Vector2(_owner.entity_data.facing_direction * 100, 0)
	}


## Prepares and returns the attack action as a Callable.
## This is the core of the Command Pattern implementation.
func execute(_owner: BaseBoss, _pattern: AttackPattern) -> Callable:
	push_warning("AttackLogic.execute() was called but not overridden.")
	return Callable()  # Return an empty, safe callable


=====================================
FILE: ./src/entities/boss/attack_patterns/homing_omni_burst_logic.gd
=====================================
# src/entities/boss/attack_patterns/homing_omni_burst_logic.gd
@tool
## Concrete AttackLogic for a complex, multi-projectile homing attack.
class_name HomingOmniBurstLogic
extends AttackLogic

@export var projectile_count: int = 30


func get_telegraph_info(_owner: BaseBoss, _pattern: AttackPattern) -> Dictionary:
	return {"size": Vector2(600, 600), "offset": Vector2.ZERO}


func execute(owner: BaseBoss, _pattern: AttackPattern) -> Callable:
	return Callable(self, "_fire_omni_burst").bind(owner)


# --- Private Helper for Execution ---
func _fire_omni_burst(owner: BaseBoss) -> void:
	if not is_instance_valid(owner):
		return

	var object_pool: IObjectPool = owner._services.object_pool
	var angle_step = TAU / projectile_count
	for i in range(projectile_count):
		var shot: HomingBossShot = object_pool.get_instance(Identifiers.Pools.HOMING_BOSS_SHOTS)
		if not is_instance_valid(shot):
			continue

		shot.damage = owner.entity_data.config.homing_shot_damage
		shot.speed = owner.entity_data.config.homing_shot_speed
		shot.lifespan = owner.entity_data.config.homing_shot_lifespan

		var angle = i * angle_step
		shot.rotation = angle
		shot.global_position = owner.global_position
		shot.activate(owner._services)


=====================================
FILE: ./src/entities/boss/boss_state_data.gd
=====================================
# src/entities/boss/boss_state_data.gd
## A Resource that holds all shared runtime state data for the Boss.
class_name BossStateData
extends Resource

# --- Configuration Reference ---
var config: CombatConfig

# --- Health & Combat ---
var max_health: int = 30
var health: int = 30:
	set(value):
		health = clamp(value, 0, max_health)

# --- Physics & Movement ---
var facing_direction: float = -1.0


=====================================
FILE: ./src/entities/boss/base_boss.tscn
=====================================
[gd_scene load_steps=15 format=3 uid="uid://dmej4a7ykn2q0"]

[ext_resource type="Script" uid="uid://5bkyx4fguxor" path="res://src/entities/boss/base_boss.gd" id="1_26qjf"]
[ext_resource type="Resource" path="res://src/data/effects/entity_hit_flash_effect.tres" id="2_hit_flash"]
[ext_resource type="Resource" path="res://src/core/data/effects/boss_phase_change_shake.tres" id="7_phase_shake"]
[ext_resource type="Resource" path="res://src/core/data/effects/boss_death_shake.tres" id="8_death_shake"]
[ext_resource type="Resource" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="9_hit_spark_effect"]
[ext_resource type="Resource" path="res://src/entities/archetypes/boss_archetype.tres" id="10_archetype"]
[ext_resource type="Script" uid="uid://dnyvyoos5kkxy" path="res://src/entities/boss/states/state_boss_idle.gd" id="12_state_idle"]
[ext_resource type="Script" uid="uid://bl6ot8t61nixu" path="res://src/entities/boss/states/state_boss_attack.gd" id="13_state_attack"]
[ext_resource type="Script" uid="uid://dgok3ph2i0i47" path="res://src/entities/boss/states/state_boss_cooldown.gd" id="14_state_cooldown"]
[ext_resource type="Script" uid="uid://bsmqi0p5h8urh" path="res://src/entities/boss/states/state_boss_patrol.gd" id="15_state_patrol"]
[ext_resource type="Script" uid="uid://b47bmwcdrdd8d" path="res://src/entities/boss/states/state_boss_lunge.gd" id="16_state_lunge"]
[ext_resource type="Resource" uid="uid://bps1fb52qcel8" path="res://src/core/data/effects/dissolve_effect.tres" id="17_dissolve_effect"]
[ext_resource type="Resource" uid="uid://cg1t62pkbrpeq" path="res://src/entities/boss/data/default_boss_behavior.tres" id="18_default_behavior"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_bossbody"]
size = Vector2(60, 60)

[node name="BaseBoss" type="CharacterBody2D"]
collision_layer = 12
collision_mask = 131
script = ExtResource("1_26qjf")
behavior = ExtResource("18_default_behavior")
hit_flash_effect = ExtResource("2_hit_flash")
intro_shake_effect = ExtResource("7_phase_shake")
phase_change_shake_effect = ExtResource("7_phase_shake")
death_shake_effect = ExtResource("8_death_shake")
hit_spark_effect = ExtResource("9_hit_spark_effect")
dissolve_effect = ExtResource("17_dissolve_effect")
state_idle_script = ExtResource("12_state_idle")
state_attack_script = ExtResource("13_state_attack")
state_cooldown_script = ExtResource("14_state_cooldown")
state_patrol_script = ExtResource("15_state_patrol")
state_lunge_script = ExtResource("16_state_lunge")
archetype = ExtResource("10_archetype")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -30.0
offset_top = -30.0
offset_right = 30.0
offset_bottom = 30.0
color = Color(1, 0.6, 0.6, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_bossbody")

[node name="CooldownTimer" type="Timer" parent="."]
wait_time = 1.5
one_shot = true

[node name="PatrolTimer" type="Timer" parent="."]
wait_time = 3.0
one_shot = true

[connection signal="timeout" from="CooldownTimer" to="." method="_on_cooldown_timer_timeout"]
[connection signal="timeout" from="PatrolTimer" to="." method="_on_patrol_timer_timeout"]


=====================================
FILE: ./src/entities/boss/states/state_boss_idle.gd
=====================================
# src/entities/boss/states/state_boss_idle.gd
## A transient state that immediately selects the next attack pattern.
class_name BossStateIdle
extends BaseState


func enter(_msg := {}) -> void:
	owner.velocity.x = 0

	if owner.current_attack_patterns.is_empty():
		push_warning(
			"BossStateIdle: No attack patterns defined for current phase. Defaulting to Cooldown."
		)
		state_machine.change_state(Identifiers.BossStates.COOLDOWN)
		return

	var chosen_pattern: AttackPattern = owner.current_attack_patterns.pick_random()
	state_machine.change_state(Identifiers.BossStates.ATTACK, {"pattern": chosen_pattern})


=====================================
FILE: ./src/entities/boss/states/state_boss_lunge.gd
=====================================
# src/entities/boss/states/state_boss_lunge.gd
## Executes a high-speed, invulnerable dash attack across the arena.
extends BaseState
class_name BossStateLunge

# --- Private Member Variables ---
var _boss: BaseBoss
var _health: HealthComponent
var _lunge_duration: float
var _invincibility_token: int

# --- State Lifecycle ---


func enter(msg := {}) -> void:
	self._boss = owner as BaseBoss
	if not _boss:
		return

	_health = _boss.get_component(HealthComponent)

	var pattern: AttackPattern = msg.get("pattern")
	_lunge_duration = pattern.attack_duration if pattern else 0.5

	_invincibility_token = _health.grant_invincibility(self)
	_boss.velocity = Vector2(state_data.facing_direction * state_data.config.boss_lunge_speed, 0)


func exit() -> void:
	if is_instance_valid(_boss) and is_instance_valid(_health):
		_health.release_invincibility(_invincibility_token)


func process_physics(delta: float) -> void:
	_lunge_duration -= delta
	if _lunge_duration <= 0:
		state_machine.change_state(Identifiers.BossStates.COOLDOWN)


=====================================
FILE: ./src/entities/boss/states/state_boss_cooldown.gd
=====================================
# src/entities/boss/states/state_boss_cooldown.gd
## The state for when the boss is waiting after completing an attack.
extends BaseState
class_name BossStateCooldown


func enter(_msg := {}) -> void:
	owner.velocity.x = 0
	owner.cooldown_timer.start()


=====================================
FILE: ./src/entities/boss/states/state_boss_attack.gd
=====================================
# src/entities/boss/states/state_boss_attack.gd
## Handles the telegraph and execution of the boss's attacks.
class_name BossStateAttack
extends BaseState

# --- Constants ---
const TelegraphScene = preload(AssetPaths.SCENE_TELEGRAPH_COMPONENT)

# --- Private Member Variables ---
var _current_pattern: AttackPattern
var _boss: BaseBoss

# --- State Lifecycle ---


func enter(msg := {}) -> void:
	self._boss = owner as BaseBoss
	if not _boss:
		push_error("BossStateAttack: Owner is not a BaseBoss. Aborting.")
		state_machine.change_state(Identifiers.BossStates.COOLDOWN)
		return

	if not msg.has("pattern") or not msg.pattern is AttackPattern:
		push_error("BossStateAttack: No valid 'pattern' provided. Aborting.")
		state_machine.change_state(Identifiers.BossStates.COOLDOWN)
		return

	_current_pattern = msg.get("pattern")
	_start_telegraph_and_attack()


# --- Private Methods ---


func _start_telegraph_and_attack() -> void:
	if not is_instance_valid(_current_pattern.logic):
		push_warning("AttackPattern is missing its 'logic' resource.")
		state_machine.change_state(Identifiers.BossStates.COOLDOWN)
		return

	var telegraph = TelegraphScene.instantiate()
	_boss.add_child(telegraph)

	var telegraph_info = _current_pattern.logic.get_telegraph_info(_boss, _current_pattern)
	var telegraph_size = telegraph_info.get("size", Vector2.ONE * 100)
	var relative_offset = telegraph_info.get("offset", Vector2.ZERO)

	var directional_offset = Vector2(
		relative_offset.x * _boss.entity_data.facing_direction, relative_offset.y
	)
	var telegraph_position = _boss.global_position + directional_offset

	telegraph.start_telegraph(
		_current_pattern.telegraph_duration,
		telegraph_size,
		telegraph_position,
		Palette.COLOR_HAZARD_PRIMARY
	)
	await telegraph.telegraph_finished

	# THE FIX: Use a robust check to ensure the owner wasn't freed during the await.
	if not is_instance_valid(_boss):
		return

	var attack_command: Callable = _current_pattern.logic.execute(_boss, _current_pattern)
	if attack_command.is_valid():
		attack_command.call()

	if state_machine.current_state == self:
		_boss.cooldown_timer.wait_time = _current_pattern.cooldown
		state_machine.change_state(Identifiers.BossStates.COOLDOWN)


=====================================
FILE: ./src/entities/boss/states/state_boss_patrol.gd
=====================================
# src/entities/boss/states/state_boss_patrol.gd
## A simple state for moving the boss back and forth between attacks.
extends BaseState
class_name BossStatePatrol


func enter(_msg := {}) -> void:
	owner.patrol_timer.start()


func process_physics(_delta: float) -> void:
	owner.velocity.x = state_data.facing_direction * state_data.config.boss_patrol_speed


=====================================
FILE: ./src/entities/boss/base_boss.gd
=====================================
# src/entities/boss/base_boss.gd
@tool
class_name BaseBoss
extends BaseEntity

# --- Editor Configuration ---
@export_group("Core Configuration")
@export var behavior: BossBehavior
@export_group("Juice & Feedback")
# THE FIX: The hit flash effect is now a configurable property, not a constant.
@export var hit_flash_effect: ShaderEffect
@export var intro_shake_effect: ScreenShakeEffect
@export var phase_change_shake_effect: ScreenShakeEffect
@export var death_shake_effect: ScreenShakeEffect
@export var hit_spark_effect: VFXEffect
@export var dissolve_effect: ShaderEffect
@export_group("State Scripts")
@export var state_idle_script: Script
@export var state_attack_script: Script
@export var state_cooldown_script: Script
@export var state_patrol_script: Script
@export var state_lunge_script: Script

# --- Node References ---
@onready var visual_sprite: ColorRect = $ColorRect
@onready var cooldown_timer: Timer = $CooldownTimer
@onready var patrol_timer: Timer = $PatrolTimer

# --- Public Member Variables ---
var current_attack_patterns: Array[AttackPattern] = []
var phases_remaining: int = 3
var entity_data: BossStateData

# --- Private Member Variables ---
var _player: CharacterBody2D = null
var _active_attack_tween: Tween
var _is_dead: bool = false

# --- Godot Lifecycle Methods ---


func _get_configuration_warnings() -> PackedStringArray:
	var warnings = PackedStringArray()
	if not archetype:
		warnings.append("This node requires an EntityArchetype resource.")
	if not behavior:
		warnings.append("This node requires a BossBehavior resource.")
	elif is_instance_valid(behavior) and behavior.phase_1_patterns.is_empty():
		warnings.append("The assigned BossBehavior has no Phase 1 attack patterns.")
	return warnings


func _ready() -> void:
	super._ready()
	if Engine.is_editor_hint():
		return

	_initialize_data()
	_initialize_and_setup_components()
	_connect_signals()
	_player = get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)

	if (
		is_instance_valid(intro_shake_effect)
		and is_instance_valid(_services)
		and is_instance_valid(_services.fx_manager)
		and _services.fx_manager.has_method("is_camera_shaker_registered")
		and _services.fx_manager.is_camera_shaker_registered()
	):
		_services.fx_manager.request_screen_shake(intro_shake_effect)


func _exit_tree() -> void:
	teardown()


func _physics_process(delta: float) -> void:
	if Engine.is_editor_hint():
		return
	if not is_on_floor():
		velocity.y += entity_data.config.gravity * delta
	move_and_slide()

	var sm: BaseStateMachine = get_component(BaseStateMachine)
	if (
		is_instance_valid(sm)
		and sm.current_state == sm.states[Identifiers.BossStates.PATROL]
		and is_on_wall()
	):
		entity_data.facing_direction *= -1.0


# --- Public Methods ---


func teardown() -> void:
	set_physics_process(false)
	var hc: HealthComponent = get_component(HealthComponent)
	if is_instance_valid(hc):
		if hc.health_changed.is_connected(_on_health_component_health_changed):
			hc.health_changed.disconnect(_on_health_component_health_changed)
		if hc.died.is_connected(_on_health_component_died):
			hc.died.disconnect(_on_health_component_died)
		if hc.health_threshold_reached.is_connected(_on_health_threshold_reached):
			hc.health_threshold_reached.disconnect(_on_health_threshold_reached)

	super.teardown()
	entity_data = null


func get_health_thresholds() -> Array[float]:
	if is_instance_valid(behavior):
		return [behavior.phase_2_threshold, behavior.phase_3_threshold]
	return []


func fire_volley(shot_count: int, delay: float) -> void:
	if is_instance_valid(_active_attack_tween):
		_active_attack_tween.kill()
	_active_attack_tween = get_tree().create_tween()
	for i in range(shot_count):
		_active_attack_tween.tween_callback(fire_shot_at_player)
		if i < shot_count - 1:
			_active_attack_tween.tween_interval(delay)


func fire_shot_at_player() -> void:
	if _is_dead or not is_instance_valid(_player):
		return
	var shot: Node = _services.object_pool.get_instance(Identifiers.Pools.BOSS_SHOTS)
	if not shot:
		return
	_update_player_tracking()
	shot.direction = (_player.global_position - global_position).normalized()
	shot.global_position = global_position
	shot.activate(_services)


# --- Private Methods ---


func _die() -> void:
	if _is_dead:
		return
	_is_dead = true

	var sm: BaseStateMachine = get_component(BaseStateMachine)
	if is_instance_valid(sm):
		sm.teardown()

	cooldown_timer.stop()
	patrol_timer.stop()

	collision_layer = 0
	collision_mask = 0
	set_physics_process(false)

	if is_instance_valid(_active_attack_tween):
		_active_attack_tween.kill()

	if is_instance_valid(death_shake_effect):
		_services.fx_manager.request_screen_shake(death_shake_effect)
	_services.fx_manager.request_hit_stop(entity_data.config.boss_death_hit_stop_duration)

	var fc: FXComponent = get_component(FXComponent)
	if is_instance_valid(dissolve_effect) and is_instance_valid(fc):
		fc.play_effect(dissolve_effect, {}, {"preserve_final_state": true})

	_services.event_bus.emit(EventCatalog.BOSS_DIED, {"boss_node": self})


func _initialize_data() -> void:
	add_to_group(Identifiers.Groups.ENEMY)
	visual_sprite.color = Palette.COLOR_BOSS_PRIMARY
	if is_instance_valid(behavior):
		current_attack_patterns = behavior.phase_1_patterns
	entity_data = BossStateData.new()
	assert(is_instance_valid(_services), "BaseBoss requires a ServiceLocator.")
	entity_data.config = _services.combat_config


func _initialize_and_setup_components() -> void:
	var hc: HealthComponent = get_component(HealthComponent)
	var sm: BaseStateMachine = get_component(BaseStateMachine)
	var fc: FXComponent = get_component(FXComponent)

	var shared_deps := {"data_resource": entity_data, "config": entity_data.config}

	var states: Dictionary = {
		Identifiers.BossStates.IDLE: state_idle_script.new(self, sm, entity_data),
		Identifiers.BossStates.ATTACK: state_attack_script.new(self, sm, entity_data),
		Identifiers.BossStates.COOLDOWN: state_cooldown_script.new(self, sm, entity_data),
		Identifiers.BossStates.PATROL: state_patrol_script.new(self, sm, entity_data),
		Identifiers.BossStates.LUNGE: state_lunge_script.new(self, sm, entity_data),
	}

	var per_component_deps := {
		sm: {"states": states, "initial_state_key": Identifiers.BossStates.COOLDOWN},
		# THE FIX: Pass the exported variable to the FXComponent's dependencies.
		fc: {"visual_node": visual_sprite, "hit_effect": hit_flash_effect},
		hc: {"hit_spark_effect": hit_spark_effect}
	}

	setup_components(shared_deps, per_component_deps)


func _connect_signals() -> void:
	var hc: HealthComponent = get_component(HealthComponent)
	hc.health_changed.connect(_on_health_component_health_changed)
	hc.died.connect(_on_health_component_died)
	hc.health_threshold_reached.connect(_on_health_threshold_reached)


func _update_player_tracking() -> void:
	if is_instance_valid(_player):
		var dir_to_player: float = _player.global_position.x - global_position.x
		if not is_zero_approx(dir_to_player):
			entity_data.facing_direction = sign(dir_to_player)
	self.scale.x = entity_data.facing_direction


# --- Signal Handlers ---


func _on_health_threshold_reached(health_percentage: float) -> void:
	if not is_instance_valid(behavior):
		return

	var new_phases_remaining: int = phases_remaining
	if health_percentage <= behavior.phase_3_threshold and phases_remaining > 1:
		new_phases_remaining = 1
	elif health_percentage <= behavior.phase_2_threshold and phases_remaining > 2:
		new_phases_remaining = 2

	if new_phases_remaining != phases_remaining:
		phases_remaining = new_phases_remaining
		match phases_remaining:
			2:
				current_attack_patterns = behavior.phase_2_patterns
			1:
				current_attack_patterns = behavior.phase_3_patterns
		if is_instance_valid(phase_change_shake_effect):
			_services.fx_manager.request_screen_shake(phase_change_shake_effect)
		_services.fx_manager.request_hit_stop(
			entity_data.config.boss_phase_change_hit_stop_duration
		)
		_services.event_bus.emit(
			EventCatalog.BOSS_PHASE_CHANGED, {"phases_remaining": phases_remaining}
		)


func _on_cooldown_timer_timeout() -> void:
	var sm: BaseStateMachine = get_component(BaseStateMachine)
	if is_instance_valid(sm) and sm.current_state == sm.states[Identifiers.BossStates.COOLDOWN]:
		sm.change_state(Identifiers.BossStates.PATROL)


func _on_patrol_timer_timeout() -> void:
	var sm: BaseStateMachine = get_component(BaseStateMachine)
	if is_instance_valid(sm) and sm.current_state == sm.states[Identifiers.BossStates.PATROL]:
		sm.change_state(Identifiers.BossStates.IDLE)


func _on_health_component_health_changed(current: int, max_val: int) -> void:
	var ev := BossHealthChangedEvent.new()
	ev.current_health = current
	ev.max_health = max_val
	_services.event_bus.emit(EventCatalog.BOSS_HEALTH_CHANGED, ev)


func _on_health_component_died() -> void:
	_die()


=====================================
FILE: ./src/entities/boss/data/default_boss_behavior.tres
=====================================
[gd_resource type="Resource" script_class="BossBehavior" load_steps=8 format=3 uid="uid://cg1t62pkbrpeq"]

[ext_resource type="Script" uid="uid://dni2it8b687id" path="res://src/entities/boss/data/boss_behavior.gd" id="1_behavior_script"]
[ext_resource type="Script" uid="uid://dy4xl0q65hagu" path="res://src/entities/boss/attack_patterns/attack_pattern.gd" id="1_pfqfc"]
[ext_resource type="Resource" uid="uid://bve7t5ucr1k" path="res://src/entities/boss/attack_patterns/single_shot.tres" id="2_pattern_single"]
[ext_resource type="Resource" uid="uid://k3dglh3t1b4a" path="res://src/entities/boss/attack_patterns/volley_3_shot.tres" id="3_pattern_volley3"]
[ext_resource type="Resource" uid="uid://y6g5o6f7h8ja" path="res://src/entities/boss/attack_patterns/lunge_attack.tres" id="4_pattern_lunge"]
[ext_resource type="Resource" uid="uid://01x2y3a4b5c6" path="res://src/entities/boss/attack_patterns/volley_5_shot.tres" id="5_pattern_volley5"]
[ext_resource type="Resource" path="res://src/entities/boss/attack_patterns/homing_omni_burst_pattern.tres" id="6_pattern_homing"]

[resource]
script = ExtResource("1_behavior_script")
phase_2_threshold = 0.7
phase_3_threshold = 0.4
phase_1_patterns = Array[ExtResource("1_pfqfc")]([ExtResource("2_pattern_single")])
phase_2_patterns = Array[ExtResource("1_pfqfc")]([ExtResource("3_pattern_volley3"), ExtResource("4_pattern_lunge")])
phase_3_patterns = Array[ExtResource("1_pfqfc")]([ExtResource("5_pattern_volley5"), ExtResource("4_pattern_lunge"), ExtResource("6_pattern_homing")])


=====================================
FILE: ./src/entities/boss/data/boss_behavior.gd
=====================================
# src/entities/boss/data/boss_behavior.gd
@tool
## A data resource that defines a boss's complete combat behavior.
##
## This encapsulates phase health thresholds and the specific attack patterns
## used in each phase, allowing for the creation of varied boss types without
## changing the core BaseBoss scene or script.
class_name BossBehavior
extends Resource

@export_group("Phase Configuration")
@export_range(0.0, 1.0, 0.01) var phase_2_threshold: float = 0.7
@export_range(0.0, 1.0, 0.01) var phase_3_threshold: float = 0.4

@export_group("Attack Patterns")
@export var phase_1_patterns: Array[AttackPattern] = []
@export var phase_2_patterns: Array[AttackPattern] = []
@export var phase_3_patterns: Array[AttackPattern] = []


=====================================
FILE: ./src/entities/README.md
=====================================
Entities: how to add components & states
=======================================

Purpose
-------
Explain the minimal conventions for adding new components and states to the entity system.

Component contract (example)
----------------------------
Create components by extending the ComponentInterface base. Keep them small and single-purpose.

Example components (GDScript):

# res://src/entities/ComponentInterface.gd
extends Node2D
class_name ComponentInterface

# Called once when the entity or builder attaches the component.
func setup(config: Dictionary) -> void:
    pass

# Called when the component or entity is being destroyed / swapped.
func teardown() -> void:
    pass

# Example concrete component: HealthComponent
# res://src/entities/components/HealthComponent.gd
extends ComponentInterface
class_name HealthComponent

@export var max_hp: int = 100
var hp: int = 100

func setup(config: Dictionary) -> void:
    if config.has("max_hp"):
        max_hp = int(config["max_hp"])
    hp = max_hp

func receive_damage(amount: int) -> void:
    hp -= amount
    if hp <= 0:
        _on_dead()

func _on_dead() -> void:
    # notify EventBus / play death FX via ObjectPool
    EventBus.emit("entity_dead", { "entity": get_parent() })
    queue_free()

State machine (example)
-----------------------
BaseState provides enter/exit and processing hooks. States are swapped by the entity's BaseStateMachine.

# res://src/core/BaseState.gd
extends Node
class_name BaseState

func enter(data = null) -> void: pass
func exit() -> void: pass
func physics_process(delta: float) -> void: pass

# res://src/core/BaseStateMachine.gd
extends Node
class_name BaseStateMachine

var current_state: BaseState = null

func change_state(new_state: BaseState, data = null) -> void:
    if current_state:
        current_state.exit()
        current_state.queue_free() # if state is a node instance
    current_state = new_state
    add_child(current_state)
    current_state.enter(data)

Best practices
--------------
- Keep state logic deterministic; side-effects should be limited and explicit.
- Components must clean themselves up in `teardown()` (disconnect signals, stop timers).
- Use the `EventBus` for cross-system signals rather than global references.
- Store tunable numbers in `.tres` resources and refer to them in `setup()`.

Example workflow to add a component
----------------------------------
1. Create `res://src/entities/components/MyComponent.gd` extending `ComponentInterface`.
2. Expose tuning via `@export` variables or read from a provided config dictionary in `setup()`.
3. Add the component as a child to the entity scene or let entity builder attach it at spawn time.
4. Ensure `teardown()` reverses all runtime connections.



=====================================
FILE: ./src/entities/components/base_state_machine.gd
=====================================
# src/entities/components/base_state_machine.gd
@tool
## A reusable, node-based state machine that conforms to the IComponent interface.
class_name BaseStateMachine
extends IComponent

# THE FIX: Add annotations to ignore the unused signal warnings.
@warning_ignore("unused_signal")
signal melee_hitbox_toggled(is_enabled: bool, is_up_attack: bool)
@warning_ignore("unused_signal")
signal pogo_hitbox_toggled(is_enabled: bool)

const MAX_HISTORY_SIZE = 5
var states: Dictionary = {}
var current_state: BaseState
var owner_node: Node
var state_history: Array[String] = []
var _current_state_key


func _ready() -> void:
	# Run after the physics component.
	process_priority = 0


func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()


func _unhandled_input(event: InputEvent) -> void:
	if current_state:
		current_state.process_input(event)


func _physics_process(delta: float) -> void:
	if current_state:
		current_state.process_physics(delta)


func _exit_tree() -> void:
	teardown()


func setup(_p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = _p_owner
	assert(p_dependencies.has("states"), "StateMachine setup requires a 'states' dictionary.")
	assert(
		p_dependencies.has("initial_state_key"),
		"StateMachine setup requires an 'initial_state_key'."
	)
	self.states = p_dependencies["states"]
	var initial_state_key = p_dependencies["initial_state_key"]
	change_state(initial_state_key)


func teardown() -> void:
	if current_state:
		current_state.exit()

	for state in states.values():
		if is_instance_valid(state):
			state.teardown()
			# States are not nodes, they are Objects, so just free them.
			state.free()

	states.clear()
	state_history.clear()
	current_state = null


func change_state(new_state_key, msg := {}) -> void:
	if not states.has(new_state_key):
		push_warning("StateMachine: Attempted to change to unknown state '%s'." % new_state_key)
		return
	if _current_state_key == new_state_key:
		return
	if current_state:
		current_state.exit()

	_current_state_key = new_state_key
	current_state = states[new_state_key]
	current_state.enter(msg)

	var state_name = str(new_state_key)
	state_history.push_front(state_name)
	if state_history.size() > MAX_HISTORY_SIZE:
		state_history.pop_back()


=====================================
FILE: ./src/entities/components/health_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://dpl3w8xqyq1a2"]

[ext_resource type="Script" path="res://src/entities/components/health_component.gd" id="1_health"]

[node name="HealthComponent" type="Node"]
script = ExtResource("1_health")
metadata/REQUIRED_DEPS = PackedStringArray("data_resource", "config", "services", "hit_spark_effect")

=====================================
FILE: ./src/entities/components/telegraph_component.gd
=====================================
# src/entities/components/telegraph_component.gd
@tool
## A self-contained, reusable component for displaying attack telegraphs.
##
## It shows a visual warning for a set duration, then emits a signal
## and automatically frees itself from the scene tree.
class_name TelegraphComponent
extends Node2D

# --- Signals ---
## Emitted when the telegraph's duration has finished.
signal telegraph_finished

# --- Node References ---
@onready var visual: ColorRect = $Visual

# --- Public Methods ---


## Configures and starts the telegraph visual and timer.
func start_telegraph(duration: float, p_size: Vector2, p_position: Vector2, p_color: Color) -> void:
	self.global_position = p_position
	visual.size = p_size
	visual.color = p_color
	# Center the ColorRect on the component's position.
	visual.position = -p_size / 2.0

	var tween = create_tween()
	await tween.tween_interval(duration).finished

	if is_instance_valid(self):
		telegraph_finished.emit()
		queue_free()


=====================================
FILE: ./src/entities/components/fx_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://g7h8i9j0k1l2"]

[ext_resource type="Script" path="res://src/entities/components/fx_component.gd" id="1_fx"]

[node name="FXComponent" type="Node"]
script = ExtResource("1_fx")
metadata/REQUIRED_DEPS = PackedStringArray("visual_node", "services")

=====================================
FILE: ./src/entities/components/combat_component.gd
=====================================
# src/entities/components/combat_component.gd
@tool
## Centralizes all player combat logic, such as firing projectiles and pogo attacks.
class_name CombatComponent
extends IComponent

# --- Signals ---
signal damage_dealt
signal pogo_bounce_requested

# --- Member Variables ---
var owner_node: CharacterBody2D
var p_data: PlayerStateData
var _services: ServiceLocator # Dependency

# --- Public Methods ---


func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as CharacterBody2D
	self.p_data = p_dependencies.get("data_resource")
	self._services = p_dependencies.get("services")
	assert(is_instance_valid(_services), "CombatComponent requires a ServiceLocator.")


func teardown() -> void:
	owner_node = null
	p_data = null
	_services = null


## Fires a player projectile from the object pool.
func fire_shot() -> void:
	p_data.attack_cooldown_timer = p_data.config.player_attack_cooldown

	var shot = _services.object_pool.get_instance(Identifiers.Pools.PLAYER_SHOTS)
	if not shot:
		return

	var shot_dir = Vector2(p_data.facing_direction, 0)
	var ic: InputComponent = owner_node.get_component(InputComponent)
	if is_instance_valid(ic):
		if ic.buffer.get("up"):
			shot_dir = Vector2.UP
		elif ic.buffer.get("down"):
			shot_dir = Vector2.DOWN

	shot.direction = shot_dir
	shot.global_position = owner_node.global_position + (shot_dir * 60)
	shot.activate(_services)


## Handles a melee hitbox collision.
func trigger_melee_attack(target_body: Node) -> void:
	var target_id = target_body.get_instance_id()
	if p_data.hit_targets_this_swing.has(target_id):
		return

	p_data.hit_targets_this_swing[target_id] = true
	var damageable = _services.combat_utils.find_damageable(target_body)
	if is_instance_valid(damageable):
		var damage_info = DamageInfo.new()
		damage_info.source_node = owner_node
		var distance = owner_node.global_position.distance_to(target_body.global_position)
		var is_close_range = distance <= p_data.config.player_close_range_threshold
		damage_info.amount = 5 if is_close_range else 1
		damage_info.impact_position = target_body.global_position
		damage_info.impact_normal = (target_body.global_position - owner_node.global_position).normalized()

		var damage_result = damageable.apply_damage(damage_info)
		if damage_result.was_damaged:
			damage_dealt.emit()
			if is_close_range:
				_services.fx_manager.request_hit_stop(
					p_data.config.player_melee_close_range_hit_stop_duration
				)


## Attempts to perform a pogo action on a target.
func trigger_pogo(pogo_target: Node) -> bool:
	if not p_data.is_pogo_attack:
		return false
	if not is_instance_valid(pogo_target):
		return false

	var should_bounce = false

	if pogo_target.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE):
		should_bounce = true
		_services.object_pool.return_instance.call_deferred(pogo_target)

	var damageable = _services.combat_utils.find_damageable(pogo_target)
	if is_instance_valid(damageable):
		should_bounce = true
		var damage_info = DamageInfo.new()
		damage_info.amount = 1
		damage_info.source_node = owner_node
		damage_info.bypass_invincibility = true
		damage_info.impact_position = pogo_target.global_position
		damage_info.impact_normal = Vector2.UP
		var damage_result = damageable.apply_damage(damage_info)
		if damage_result.was_damaged:
			damage_dealt.emit()

	if pogo_target is StaticBody2D and pogo_target.is_in_group(Identifiers.Groups.WORLD):
		should_bounce = true

	if should_bounce:
		pogo_bounce_requested.emit()
		return true

	return false


=====================================
FILE: ./src/entities/components/telegraph_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://b1i2c3d4e5f6g"]

[ext_resource type="Script" path="res://src/entities/components/telegraph_component.gd" id="1_telegraph_script"]

[node name="TelegraphComponent" type="Node2D"]
script = ExtResource("1_telegraph_script")

[node name="Visual" type="ColorRect" parent="."]
offset_right = 40.0
offset_bottom = 40.0
color = Color(1, 1, 1, 0.392157)


=====================================
FILE: ./src/entities/components/input_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://c7d8e9f0g1h2"]

[ext_resource type="Script" path="res://src/entities/components/input_component.gd" id="1_input"]

[node name="InputComponent" type="Node"]
script = ExtResource("1_input")
metadata/REQUIRED_DEPS = PackedStringArray("data_resource", "config")

=====================================
FILE: ./src/entities/components/health_component.gd
=====================================
# src/entities/components/health_component.gd
@tool
## Manages all health, damage, and invincibility logic for an entity.
## Implements the IDamageable interface.
class_name HealthComponent
extends IDamageable

# --- Signals ---
signal health_changed(current_health: int, max_health: int)
signal died
signal health_threshold_reached(health_percentage: float)
signal took_damage(damage_info: DamageInfo, damage_result: DamageResult)

# --- Member Variables ---
var entity_data: Resource
var owner_node: CharacterBody2D

var _max_health: int
var _invincibility_duration: float
var _knockback_speed: float
var _hazard_knockback_speed: float
var _invincibility_tokens: Dictionary = {}
var _next_token_id: int = 1
var _services: ServiceLocator
var _hit_spark_effect: VFXEffect

# --- Godot Lifecycle Methods ---


func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()


# --- Public Methods (IComponent Contract) ---


func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as CharacterBody2D
	self.entity_data = p_dependencies.get("data_resource")
	var cfg: CombatConfig = p_dependencies.get("config")
	self._services = p_dependencies.get("services")
	self._hit_spark_effect = p_dependencies.get("hit_spark_effect")

	if not entity_data or not cfg or not _services:
		push_error("HealthComponent.setup: Missing required dependencies.")
		return

	_max_health = entity_data.max_health
	if owner_node.is_in_group(Identifiers.Groups.PLAYER):
		_invincibility_duration = cfg.player_invincibility_duration
		_knockback_speed = cfg.player_knockback_speed
		_hazard_knockback_speed = cfg.player_hazard_knockback_speed
	else:
		_invincibility_duration = cfg.boss_invincibility_duration
		_knockback_speed = 0
		_hazard_knockback_speed = 0

	entity_data.health = _max_health
	health_changed.emit(entity_data.health, _max_health)


func teardown() -> void:
	entity_data = null
	owner_node = null
	_services = null
	_hit_spark_effect = null


# --- Public Methods (IDamageable Contract) ---


func apply_damage(damage_info: DamageInfo) -> DamageResult:
	var result := DamageResult.new()

	if not is_instance_valid(damage_info):
		push_warning("HealthComponent received an invalid DamageInfo object.")
		return result

	if is_invincible() and not damage_info.bypass_invincibility:
		return result

	var health_before_damage: int = entity_data.health
	entity_data.health -= damage_info.amount
	health_changed.emit(entity_data.health, _max_health)

	var post_hit_token: int = grant_invincibility(self)
	get_tree().create_timer(_invincibility_duration).timeout.connect(
		release_invincibility.bind(post_hit_token)
	)

	result.knockback_velocity = _calculate_knockback(damage_info.source_node)
	_check_for_threshold_crossing(health_before_damage, entity_data.health)

	result.was_damaged = true
	took_damage.emit(damage_info, result)

	if result.was_damaged and is_instance_valid(_services) and is_instance_valid(_hit_spark_effect):
		_services.fx_manager.play_vfx(
			_hit_spark_effect, damage_info.impact_position, damage_info.impact_normal
		)

	if entity_data.health <= 0:
		died.emit()

	return result


# --- Public Methods (HealthComponent Specific) ---


func is_invincible() -> bool:
	return not _invincibility_tokens.is_empty()


func grant_invincibility(requester: Object) -> int:
	var token_id := _next_token_id
	_next_token_id += 1
	_invincibility_tokens[token_id] = requester.get_instance_id()
	return token_id


func release_invincibility(token: int) -> void:
	if _invincibility_tokens.has(token):
		_invincibility_tokens.erase(token)


# --- Private Methods ---
func _check_for_threshold_crossing(health_before: int, health_after: int) -> void:
	if not owner_node.has_method("get_health_thresholds"):
		return
	var thresholds: Array[float] = owner_node.get_health_thresholds()
	var old_percent: float = float(health_before) / _max_health
	var new_percent: float = float(health_after) / _max_health
	for threshold in thresholds:
		if old_percent > threshold and new_percent <= threshold:
			health_threshold_reached.emit(threshold)


func _calculate_knockback(source: Node) -> Vector2:
	if _knockback_speed == 0 or not is_instance_valid(source):
		return Vector2.ZERO
	var knockback_dir: Vector2 = (owner_node.global_position - source.global_position).normalized()
	var speed: float = _knockback_speed
	if source.is_in_group(Identifiers.Groups.HAZARD):
		speed = _hazard_knockback_speed
	return (knockback_dir + Vector2.UP * 0.5).normalized() * speed

=====================================
FILE: ./src/entities/components/base_state_machine.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://i3j4k5l6m7n8"]

[ext_resource type="Script" path="res://src/entities/components/base_state_machine.gd" id="1_fsm"]

[node name="StateMachine" type="Node"]
script = ExtResource("1_fsm")

=====================================
FILE: ./src/entities/components/input_component.gd
=====================================
# src/entities/components/input_component.gd
@tool
## A component that centralizes all raw input polling.
##
## It reads from Godot's Input singleton each frame and populates a buffer
## dictionary. Other components and states read from this buffer, decoupling
## them from the global Input singleton.
class_name InputComponent
extends IComponent

# --- Member Variables ---
var owner_node: CharacterBody2D
var p_data: PlayerStateData
var _config: CombatConfig  # Internal reference to the injected config

## A buffer dictionary populated each frame with the current input state.
var buffer: Dictionary = {}

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	# A lower number runs earlier in the physics step.
	# This ensures the buffer is populated before other components try to read it.
	process_priority = -100


func _physics_process(_delta: float) -> void:
	if not is_instance_valid(owner_node):
		return  # Guard against post-teardown calls

	# 1. Clear the buffer at the start of the frame.
	buffer.clear()

	# 2. Populate the buffer with the current input state.
	buffer["move_axis"] = Input.get_axis("ui_left", "ui_right")

	buffer["up"] = Input.is_action_pressed("ui_up")
	buffer["down"] = Input.is_action_pressed("ui_down")

	buffer["jump_just_pressed"] = Input.is_action_just_pressed("ui_jump")
	buffer["jump_held"] = Input.is_action_pressed("ui_jump")
	buffer["jump_released"] = Input.is_action_just_released("ui_jump")

	buffer["attack_pressed"] = Input.is_action_pressed("ui_attack")
	buffer["attack_just_pressed"] = Input.is_action_just_pressed("ui_attack")
	buffer["attack_released"] = Input.is_action_just_released("ui_attack")

	buffer["dash_pressed"] = Input.is_action_just_pressed("ui_dash")


# --- Public Methods ---


func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as CharacterBody2D
	self.p_data = p_dependencies.get("data_resource")
	self._config = p_dependencies.get("config")

	if not p_data or not _config:
		push_error("InputComponent.setup: Missing one or more required dependencies.")
		return


func teardown() -> void:
	set_physics_process(false)  # Immediately stop processing
	owner_node = null
	p_data = null
	_config = null
	buffer.clear()

=====================================
FILE: ./src/entities/components/combat_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://b1x2y3z4a5b6"]

[ext_resource type="Script" path="res://src/entities/components/combat_component.gd" id="1_combat"]

[node name="CombatComponent" type="Node"]
script = ExtResource("1_combat")

=====================================
FILE: ./src/entities/components/base_state.gd
=====================================
# src/entities/components/base_state.gd
## The abstract base class for all entity states.
##
## Defines the lifecycle methods that every state must implement. States are
## responsible for handling logic for a specific entity behavior (e.g., moving,
## attacking, dashing).
class_name BaseState
extends Object

# --- Member Variables ---
var owner: Node
var state_machine: Node
var state_data: Resource

# --- Constructor ---


func _init(p_owner: Node, p_state_machine: Node, p_state_data: Resource) -> void:
	self.owner = p_owner
	self.state_machine = p_state_machine
	self.state_data = p_state_data


# --- Public Methods ---


## Called by the state machine upon exiting to break cyclic references.
func teardown() -> void:
	owner = null
	state_machine = null
	state_data = null


# --- Virtual Lifecycle Methods ---


## Called once when the state machine enters this state.
func enter(_msg := {}) -> void:
	pass


## Called once when the state machine exits this state.
func exit() -> void:
	pass


## Called every physics frame. Used for movement and physics-based logic.
func process_physics(_delta: float) -> void:
	pass


## Called during the `_unhandled_input` cycle. Used for immediate input reactions.
func process_input(_event: InputEvent) -> void:
	pass


=====================================
FILE: ./src/entities/components/fx_component.gd
=====================================
# src/entities/components/fx_component.gd
@tool
## A dedicated component for managing all entity-specific visual effects.
##
## CONTRACT: This component requires a "visual_node" dependency and will
## automatically discover a "HealthComponent" on its owner to trigger damage effects.
class_name FXComponent
extends IComponent

# --- Member Variables ---
var _owner: Node
var _visual_node: CanvasItem
var _health_component: HealthComponent
var _hit_effect: ShaderEffect  # Injected Dependency
var _services: IFXManager

# --- Godot Lifecycle Methods ---
func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()

func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self._owner = p_owner
	var service_locator: ServiceLocator = p_dependencies.get("services")
	assert(is_instance_valid(service_locator), "FXComponent requires a ServiceLocator.")
	self._services = service_locator.fx_manager
	assert(is_instance_valid(_services), "FXComponent could not get IFXManager from ServiceLocator.")

	assert(p_dependencies.has("visual_node"), "FXComponent requires a 'visual_node' dependency.")
	_visual_node = p_dependencies.get("visual_node")
	assert(
		is_instance_valid(_visual_node) and _visual_node is CanvasItem,
		"'visual_node' must be a valid CanvasItem."
	)

	if _owner.has_method("get_component"):
		_health_component = _owner.get_component(HealthComponent)

	if is_instance_valid(_health_component):
		assert(
			p_dependencies.has("hit_effect"),
			"FXComponent requires a 'hit_effect' dependency when a HealthComponent is present."
		)
		_hit_effect = p_dependencies.get("hit_effect")
		assert(
			is_instance_valid(_hit_effect),
			"Injected 'hit_effect' must be a valid ShaderEffect resource."
		)
		if not _health_component.took_damage.is_connected(_on_owner_took_damage):
			_health_component.took_damage.connect(_on_owner_took_damage)

func teardown() -> void:
	if is_instance_valid(_services):
		_services.cancel_effect_on_node(_visual_node)

	if is_instance_valid(_health_component):
		if _health_component.took_damage.is_connected(_on_owner_took_damage):
			_health_component.took_damage.disconnect(_on_owner_took_damage)

	_visual_node = null
	_owner = null
	_health_component = null
	_services = null

# --- Public API ---

func play_effect(effect: ShaderEffect, overrides: Dictionary = {}, opts: Dictionary = {}) -> Tween:
	if not is_instance_valid(_visual_node):
		push_warning("FXComponent cannot play effect: visual node is invalid.")
		return null
	return _services.apply_shader_effect(_visual_node, effect, overrides, opts)

# --- Signal Handlers ---

func _on_owner_took_damage(_damage_info: DamageInfo, _damage_result: DamageResult) -> void:
	if is_instance_valid(_hit_effect):
		play_effect(_hit_effect)


=====================================
FILE: ./src/entities/minions/minion.gd
=====================================
# src/entities/minions/minion.gd
@tool
## A generic minion enemy, whose behavior is defined by a MinionBehavior resource.
class_name Minion
extends BaseEntity

# --- Editor Configuration ---
@export_group("Core Configuration")
@export var behavior: MinionBehavior
@export_group("Juice & Feedback")
# THE FIX: The hit flash effect is now a configurable property, not a constant.
@export var hit_flash_effect: ShaderEffect
@export var hit_spark_effect: VFXEffect
@export var dissolve_effect: ShaderEffect

# --- Node References ---
@onready var visual: Polygon2D = $Visual
@onready var attack_timer: Timer = $AttackTimer
@onready var range_detector_shape: CollisionShape2D = $RangeDetector/CollisionShape2D

# --- Public Member Variables ---
var entity_data: MinionStateData

# --- Private Member Variables ---
var _player: CharacterBody2D
var _is_dead: bool = false

# --- Godot Lifecycle Methods ---


func _get_configuration_warnings() -> PackedStringArray:
	var warnings := PackedStringArray()
	if not archetype:
		warnings.append("This node requires an EntityArchetype resource.")
	if not behavior:
		warnings.append("This node requires a MinionBehavior resource to function.")
	return warnings


func _ready() -> void:
	super._ready()
	if Engine.is_editor_hint():
		return

	_initialize_data()
	_initialize_and_setup_components()
	_connect_signals()

	_player = get_tree().get_first_node_in_group(Identifiers.Groups.PLAYER)


func _physics_process(_delta: float) -> void:
	if not _is_dead:
		move_and_slide()


func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		teardown()


# --- Public Methods ---


func teardown() -> void:
	var hc: HealthComponent = get_component(HealthComponent)
	if is_instance_valid(hc):
		if hc.died.is_connected(_on_health_component_died):
			hc.died.disconnect(_on_health_component_died)

	super.teardown()
	entity_data = null


func deactivate() -> void:
	var sm: BaseStateMachine = get_component(BaseStateMachine)
	if is_instance_valid(sm):
		sm.teardown()
	if is_instance_valid(attack_timer):
		attack_timer.stop()

	set_physics_process(false)
	$RangeDetector.monitoring = false


# --- Private Methods ---


func _fire_at_player() -> void:
	if not is_instance_valid(_player):
		return

	var pool_key: StringName = entity_data.behavior.projectile_pool_key
	var shot: Node = _services.object_pool.get_instance(pool_key)
	if not is_instance_valid(shot):
		push_error("Minion failed to get projectile from pool: '%s'" % pool_key)
		return

	# Look towards player before firing
	var dir_to_player: float = _player.global_position.x - global_position.x
	if not is_zero_approx(dir_to_player):
		entity_data.facing_direction = sign(dir_to_player)

	shot.direction = (self._player.global_position - self.global_position).normalized()
	shot.global_position = self.global_position
	shot.activate(_services)


func _die() -> void:
	if _is_dead:
		return
	_is_dead = true

	collision_layer = 0
	collision_mask = 0
	deactivate()

	var fc: FXComponent = get_component(FXComponent)
	var death_tween: Tween = fc.play_effect(dissolve_effect)
	if is_instance_valid(death_tween):
		await death_tween.finished

	if is_instance_valid(self):
		queue_free()


func _initialize_data() -> void:
	add_to_group(Identifiers.Groups.ENEMY)
	visual.color = Palette.COLOR_TERRAIN_SECONDARY
	entity_data = MinionStateData.new()
	assert(is_instance_valid(_services), "Minion requires a ServiceLocator.")

	assert(is_instance_valid(behavior), "Minion requires a valid MinionBehavior resource.")
	entity_data.behavior = behavior
	entity_data.max_health = behavior.max_health
	entity_data.services = _services


func _initialize_and_setup_components() -> void:
	var circle_shape := CircleShape2D.new()
	circle_shape.radius = entity_data.behavior.detection_radius
	range_detector_shape.shape = circle_shape

	var hc: HealthComponent = get_component(HealthComponent)
	var sm: BaseStateMachine = get_component(BaseStateMachine)
	var fc: FXComponent = get_component(FXComponent)

	var shared_deps := {
		"data_resource": entity_data,
		"config": _services.combat_config
	}

	var states: Dictionary = {
		Identifiers.MinionStates.IDLE:
		load("res://src/entities/minions/states/state_minion_idle.gd").new(self, sm, entity_data),
		Identifiers.MinionStates.ATTACK:
		load("res://src/entities/minions/states/state_minion_attack.gd").new(self, sm, entity_data)
	}

	var per_component_deps := {
		sm: {"states": states, "initial_state_key": Identifiers.MinionStates.IDLE},
		# THE FIX: Pass the exported variable to the FXComponent's dependencies.
		fc: {"visual_node": visual, "hit_effect": hit_flash_effect},
		hc: {"hit_spark_effect": hit_spark_effect}
	}

	setup_components(shared_deps, per_component_deps)


func _connect_signals() -> void:
	var hc: HealthComponent = get_component(HealthComponent)
	hc.died.connect(_on_health_component_died)


# --- Signal Handlers ---


func _on_range_detector_body_entered(body: Node) -> void:
	if not entity_data:
		return
	if body.is_in_group(Identifiers.Groups.PLAYER):
		entity_data.is_player_in_range = true


func _on_range_detector_body_exited(body: Node) -> void:
	if not entity_data:
		return
	if body.is_in_group(Identifiers.Groups.PLAYER):
		entity_data.is_player_in_range = false


func _on_health_component_died() -> void:
	_die()


=====================================
FILE: ./src/entities/minions/movement_logic/stationary_movement.tres
=====================================
[gd_resource type="Resource" script_class="StationaryMovementLogic" load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/minions/movement_logic/stationary_movement_logic.gd" id="1_script"]

[resource]
script = ExtResource("1_script")


=====================================
FILE: ./src/entities/minions/movement_logic/patrol_movement.tres
=====================================
[gd_resource type="Resource" script_class="PatrolMovementLogic" load_steps=2 format=3]

[ext_resource type="Script" path="res://src/entities/minions/movement_logic/patrol_movement_logic.gd" id="1_script"]

[resource]
script = ExtResource("1_script")


=====================================
FILE: ./src/entities/minions/movement_logic/stationary_movement_logic.gd
=====================================
# src/entities/minions/movement_logic/stationary_movement_logic.gd
@tool
## A concrete movement strategy where the minion does not move at all.
class_name StationaryMovementLogic
extends MovementLogic


## Returns zero velocity, effectively keeping the minion stationary.
func execute(_delta: float, _minion: Minion, _state_data: MinionStateData) -> Vector2:
	return Vector2.ZERO


=====================================
FILE: ./src/entities/minions/movement_logic/movement_logic.gd
=====================================
# src/entities/minions/movement_logic/movement_logic.gd
@tool
## The abstract base class for all minion movement strategies.
## Defines the contract for how a minion's velocity is calculated each frame.
class_name MovementLogic
extends Resource

## Calculates and returns the minion's velocity for the current physics frame.
## This is the core method to be implemented by all concrete movement strategies.
## @param delta: The time elapsed since the last physics frame.
## @param minion: A reference to the Minion node executing this logic.
## @param state_data: The shared state data resource for the minion.
## @return: The calculated velocity vector for the current frame.
func execute(_delta: float, _minion: Minion, _state_data: MinionStateData) -> Vector2:
	push_warning("MovementLogic.execute() was called but not overridden by the implementer.")
	return Vector2.ZERO


=====================================
FILE: ./src/entities/minions/movement_logic/patrol_movement_logic.gd
=====================================
# src/entities/minions/movement_logic/patrol_movement_logic.gd
@tool
## A concrete movement strategy where the minion moves back and forth,
## reversing direction when it hits a wall.
class_name PatrolMovementLogic
extends MovementLogic

## Moves the minion horizontally, applying gravity, and reverses on wall collision.
func execute(delta: float, minion: Minion, state_data: MinionStateData) -> Vector2:
	var new_velocity := minion.velocity

	# THE FIX: Gravity is now handled by the movement strategy itself.
	if not minion.is_on_floor():
		new_velocity.y += state_data.services.combat_config.gravity * delta

	if minion.is_on_wall():
		state_data.facing_direction *= -1.0

	# NOTE: We currently use boss_patrol_speed. We can add a minion-specific
	# speed to MinionBehavior later if needed.
	new_velocity.x = state_data.facing_direction * state_data.services.combat_config.boss_patrol_speed
	return new_velocity

=====================================
FILE: ./src/entities/minions/minion_state_data.gd
=====================================
# src/entities/minions/minion_state_data.gd
## A Resource that holds all shared runtime state data for a Minion.
class_name MinionStateData
extends Resource

# --- Configuration Reference ---
var behavior: MinionBehavior
var services: ServiceLocator

# --- Health & Combat ---
var max_health: int = 3
var health: int = 3:
	set(value):
		health = clamp(value, 0, max_health)

var is_invincible: bool = false

# --- Targeting ---
var is_player_in_range: bool = false

# --- Physics & Movement ---
var facing_direction: float = -1.0

=====================================
FILE: ./src/entities/minions/minion.tscn
=====================================
[gd_scene load_steps=9 format=3 uid="uid://c7d8faf0g1h2i"]

[ext_resource type="Script" uid="uid://4xepmjomesfc" path="res://src/entities/minions/minion.gd" id="1_minion_script"]
[ext_resource type="Resource" path="res://src/data/effects/entity_hit_flash_effect.tres" id="2_hit_flash"]
[ext_resource type="Resource" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="3_hit_spark_effect"]
[ext_resource type="Resource" path="res://src/entities/archetypes/minion_archetype.tres" id="4_archetype"]
[ext_resource type="Resource" uid="uid://bps1fb52qcel8" path="res://src/core/data/effects/dissolve_effect.tres" id="5_dissolve_effect"]
[ext_resource type="Resource" path="res://src/entities/minions/data/turret_behavior.tres" id="6_turret_behavior"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_minionbody"]
size = Vector2(50, 50)

[sub_resource type="CircleShape2D" id="CircleShape2D_rangedetector"]
radius = 400.0

[node name="Minion" type="CharacterBody2D" groups=["enemy"]]
collision_layer = 4
collision_mask = 131
script = ExtResource("1_minion_script")
behavior = ExtResource("6_turret_behavior")
hit_flash_effect = ExtResource("2_hit_flash")
hit_spark_effect = ExtResource("3_hit_spark_effect")
dissolve_effect = ExtResource("5_dissolve_effect")
archetype = ExtResource("4_archetype")

[node name="Visual" type="Polygon2D" parent="."]
color = Color(0.490196, 0.490196, 0.490196, 1)
polygon = PackedVector2Array(-25, -25, 25, -25, 25, 25, -25, 25)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_minionbody")

[node name="AttackTimer" type="Timer" parent="."]
wait_time = 2.0
one_shot = true

[node name="RangeDetector" type="Area2D" parent="."]
collision_layer = 0

[node name="CollisionShape2D" type="CollisionShape2D" parent="RangeDetector"]
shape = SubResource("CircleShape2D_rangedetector")

[connection signal="body_entered" from="RangeDetector" to="." method="_on_range_detector_body_entered"]
[connection signal="body_exited" from="RangeDetector" to="." method="_on_range_detector_body_exited"]


=====================================
FILE: ./src/entities/minions/states/state_minion_attack.gd
=====================================
# src/entities/minions/states/state_minion_attack.gd
## The state for when the minion is executing its attack.
class_name MinionStateAttack
extends BaseState

var _minion: Minion


func enter(_msg := {}) -> void:
	self._minion = owner as Minion
	if not is_instance_valid(_minion):
		state_machine.change_state(Identifiers.MinionStates.IDLE)
		return
	
	_minion.velocity = Vector2.ZERO
	_minion._fire_at_player()
	_minion.attack_timer.start(state_data.behavior.attack_cooldown)
	
	# This state is now transient; it immediately returns to Idle.
	# The attack timer's cooldown will prevent it from attacking again right away.
	state_machine.change_state(Identifiers.MinionStates.IDLE)

=====================================
FILE: ./src/entities/minions/states/state_minion_idle.gd
=====================================
# src/entities/minions/states/state_minion_idle.gd
## The default state for a minion. It handles movement via the assigned
## MovementLogic and checks for conditions to transition to the attack state.
class_name MinionStateIdle
extends BaseState

var _minion: Minion


func enter(_msg := {}) -> void:
	self._minion = owner as Minion


func process_physics(delta: float) -> void:
	if not is_instance_valid(_minion):
		return

	# Delegate movement logic to the assigned strategy.
	if is_instance_valid(state_data.behavior.movement_logic):
		var new_velocity: Vector2 = state_data.behavior.movement_logic.execute(
			delta, _minion, state_data
		)
		_minion.velocity = new_velocity
	
	# THE FIX: The state machine no longer applies gravity. This is now the
	# sole responsibility of the active MovementLogic resource.

	# Check for attack conditions.
	if state_data.is_player_in_range and _minion.attack_timer.is_stopped():
		state_machine.change_state(Identifiers.MinionStates.ATTACK)

=====================================
FILE: ./src/entities/minions/data/minion_behavior.gd
=====================================
# src/entities/minions/data/minion_behavior.gd
@tool
## A data resource that defines a minion's complete combat behavior.
##
## This combines base stats with swappable logic resources for movement and
## attacks, allowing for the creation of varied minion types from a single
## generic Minion scene.
class_name MinionBehavior
extends Resource

@export_group("Stats")
@export_range(1, 100, 1) var max_health: int = 3

@export_group("Movement")
@export var movement_logic: MovementLogic

@export_group("Combat")
# TODO: Implement a swappable AttackLogic system for minions.
@export_range(0.1, 10.0, 0.1) var attack_cooldown: float = 2.0
@export_range(50, 1000, 10) var detection_radius: float = 400.0
@export var projectile_pool_key: StringName = &"turret_shots"


=====================================
FILE: ./src/entities/minions/data/turret_behavior.tres
=====================================
[gd_resource type="Resource" script_class="MinionBehavior" load_steps=3 format=3]

[ext_resource type="Script" path="res://src/entities/minions/data/minion_behavior.gd" id="1_script"]
[ext_resource type="Resource" path="res://src/entities/minions/movement_logic/stationary_movement.tres" id="2_movement"]

[resource]
script = ExtResource("1_script")
max_health = 3
movement_logic = ExtResource("2_movement")
attack_cooldown = 2.0
detection_radius = 400.0
projectile_pool_key = &"turret_shots"


=====================================
FILE: ./src/entities/player/player.tscn
=====================================
[gd_scene load_steps=16 format=3 uid="uid://c6vknl71ea1bo"]

[ext_resource type="Script" uid="uid://bymbb3pjo71tf" path="res://src/entities/player/player.gd" id="1_4d1td"]
[ext_resource type="Resource" path="res://src/entities/archetypes/player_archetype.tres" id="2_archetype"]
[ext_resource type="Resource" path="res://src/core/data/effects/player_damage_shake.tres" id="3_shake_effect"]
[ext_resource type="Resource" path="res://src/core/data/effects/player_hit_spark_effect.tres" id="4_hit_spark_effect"]
[ext_resource type="Script" uid="uid://pyb4pd4uixxk" path="res://src/entities/player/states/state_move.gd" id="5_state_move"]
[ext_resource type="Script" uid="uid://52jrtscsjy6s" path="res://src/entities/player/states/state_jump.gd" id="6_state_jump"]
[ext_resource type="Script" uid="uid://dd6xefkcdr77e" path="res://src/entities/player/states/state_fall.gd" id="7_state_fall"]
[ext_resource type="Script" uid="uid://11fbrak080kl" path="res://src/entities/player/states/state_dash.gd" id="8_state_dash"]
[ext_resource type="Script" uid="uid://m3xnbhn5umv6" path="res://src/entities/player/states/state_wall_slide.gd" id="9_state_wall_slide"]
[ext_resource type="Script" uid="uid://cem1wgbis0qlx" path="res://src/entities/player/states/state_attack.gd" id="10_state_attack"]
[ext_resource type="Script" uid="uid://bxwc5vsj7qsw1" path="res://src/entities/player/states/state_hurt.gd" id="11_state_hurt"]
[ext_resource type="Script" uid="uid://dv503l6b2cfqr" path="res://src/entities/player/states/state_heal.gd" id="12_state_heal"]
[ext_resource type="Script" uid="uid://d1l7j3jqn4awq" path="res://src/entities/player/states/state_pogo.gd" id="13_state_pogo"]
[ext_resource type="Resource" uid="uid://bps1fb52qcel8" path="res://src/core/data/effects/dissolve_effect.tres" id="14_dissolve_effect"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_playerbody"]
size = Vector2(40, 40)

[node name="Player" type="CharacterBody2D"]
collision_mask = 142
script = ExtResource("1_4d1td")
damage_shake_effect = ExtResource("3_shake_effect")
hit_spark_effect = ExtResource("4_hit_spark_effect")
dissolve_effect = ExtResource("14_dissolve_effect")
state_move_script = ExtResource("5_state_move")
state_jump_script = ExtResource("6_state_jump")
state_fall_script = ExtResource("7_state_fall")
state_dash_script = ExtResource("8_state_dash")
state_wall_slide_script = ExtResource("9_state_wall_slide")
state_attack_script = ExtResource("10_state_attack")
state_hurt_script = ExtResource("11_state_hurt")
state_heal_script = ExtResource("12_state_heal")
state_pogo_script = ExtResource("13_state_pogo")
archetype = ExtResource("2_archetype")

[node name="ColorRect" type="ColorRect" parent="."]
offset_left = -20.0
offset_top = -20.0
offset_right = 20.0
offset_bottom = 20.0
color = Color(0.941176, 0.941176, 0.941176, 1)

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("RectangleShape2D_playerbody")

[node name="MeleeHitbox" type="Area2D" parent="."]
collision_layer = 32
collision_mask = 148

[node name="CollisionShape2D" type="CollisionShape2D" parent="MeleeHitbox"]
position = Vector2(60, 0)
shape = SubResource("RectangleShape2D_playerbody")
disabled = true

[node name="PogoHitbox" type="Area2D" parent="."]
collision_layer = 32
collision_mask = 150

[node name="CollisionShape2D" type="CollisionShape2D" parent="PogoHitbox"]
shape = SubResource("RectangleShape2D_playerbody")
disabled = true

[node name="Hurtbox" type="Area2D" parent="."]
collision_layer = 64
collision_mask = 28

[node name="CollisionShape2D" type="CollisionShape2D" parent="Hurtbox"]
shape = SubResource("RectangleShape2D_playerbody")

[node name="HealingTimer" type="Timer" parent="."]
one_shot = true

=====================================
FILE: ./src/entities/player/player.gd
=====================================
# src/entities/player/player.gd
@tool
class_name Player
extends BaseEntity

# --- Signals ---
signal health_changed(current_health, max_health)
signal died

# --- Constants ---
const ACTION_ALLOWED_STATES = [
	Identifiers.PlayerStates.MOVE,
	Identifiers.PlayerStates.FALL,
	Identifiers.PlayerStates.JUMP,
	Identifiers.PlayerStates.WALL_SLIDE
]
const HIT_FLASH_EFFECT = preload("res://src/data/effects/entity_hit_flash_effect.tres")

# --- Editor Properties ---
@export_group("Juice & Feedback")
@export var damage_shake_effect: ScreenShakeEffect
@export var hit_spark_effect: VFXEffect
@export var dissolve_effect: ShaderEffect
@export_group("State Scripts")
@export var state_move_script: Script
@export var state_jump_script: Script
@export var state_fall_script: Script
@export var state_dash_script: Script
@export var state_wall_slide_script: Script
@export var state_attack_script: Script
@export var state_hurt_script: Script
@export var state_heal_script: Script
@export var state_pogo_script: Script

# --- Node References ---
@onready var visual_sprite: ColorRect = $ColorRect
@onready var hurtbox: Area2D = $Hurtbox
@onready var healing_timer: Timer = $HealingTimer
@onready var melee_hitbox: Area2D = $MeleeHitbox
@onready var pogo_hitbox: Area2D = $PogoHitbox

# --- Data ---
var entity_data: PlayerStateData

# --- Private Member Variables ---
var _is_dead: bool = false

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	super._ready()
	if Engine.is_editor_hint():
		return

	add_to_group(Identifiers.Groups.PLAYER)
	_initialize_and_setup_components()
	_connect_signals()

	visual_sprite.color = Palette.COLOR_PLAYER
	entity_data.healing_charges = 0
	get_component(PlayerResourceComponent).on_damage_dealt()
	entity_data.determination_counter = 0


func _physics_process(delta: float) -> void:
	if _is_dead:
		return
	_update_timers(delta)


# --- Public Methods ---


func teardown() -> void:
	var hc: HealthComponent = get_component(HealthComponent)
	if is_instance_valid(hc):
		if hc.health_changed.is_connected(_on_health_component_health_changed):
			hc.health_changed.disconnect(_on_health_component_health_changed)
		if hc.died.is_connected(_on_health_component_died):
			hc.died.disconnect(_on_health_component_died)

	var cc: CombatComponent = get_component(CombatComponent)
	if is_instance_valid(cc):
		var rc: PlayerResourceComponent = get_component(PlayerResourceComponent)
		if is_instance_valid(rc) and cc.damage_dealt.is_connected(rc.on_damage_dealt):
			cc.damage_dealt.disconnect(rc.on_damage_dealt)
		if cc.pogo_bounce_requested.is_connected(_on_pogo_bounce_requested):
			cc.pogo_bounce_requested.disconnect(_on_pogo_bounce_requested)

	var sm: BaseStateMachine = get_component(BaseStateMachine)
	if is_instance_valid(sm):
		if sm.melee_hitbox_toggled.is_connected(_enable_melee_hitbox):
			sm.melee_hitbox_toggled.disconnect(_enable_melee_hitbox)
		if sm.pogo_hitbox_toggled.is_connected(_enable_pogo_hitbox):
			sm.pogo_hitbox_toggled.disconnect(_enable_pogo_hitbox)

	var ac: PlayerAbilityComponent = get_component(PlayerAbilityComponent)
	if is_instance_valid(ac):
		if ac.state_change_requested.is_connected(_on_ability_state_change_requested):
			ac.state_change_requested.disconnect(_on_ability_state_change_requested)

	if is_instance_valid(healing_timer):
		if healing_timer.timeout.is_connected(_on_healing_timer_timeout):
			healing_timer.timeout.disconnect(_on_healing_timer_timeout)

	super.teardown()
	entity_data = null


# --- Private Methods ---


func _die() -> void:
	if _is_dead:
		return
	_is_dead = true

	collision_layer = 0
	collision_mask = 0
	set_physics_process(false)

	var sm: BaseStateMachine = get_component(BaseStateMachine)
	if is_instance_valid(sm):
		sm.teardown()

	var fc: FXComponent = get_component(FXComponent)
	if is_instance_valid(dissolve_effect) and is_instance_valid(fc):
		var tween: Tween = fc.play_effect(dissolve_effect, {}, {"preserve_final_state": false})
		if is_instance_valid(tween):
			await tween.finished

	died.emit()


func _enable_melee_hitbox(is_enabled: bool, is_up_attack: bool = false) -> void:
	var shape_node: CollisionShape2D = melee_hitbox.get_node("CollisionShape2D")
	if is_enabled:
		if is_up_attack:
			shape_node.shape = entity_data.config.player_upward_attack_shape
			shape_node.position = Vector2(0, -40)
		else:
			shape_node.shape = entity_data.config.player_forward_attack_shape
			shape_node.position = Vector2(entity_data.facing_direction * 60, 0)
	shape_node.set_deferred("disabled", not is_enabled)


func _enable_pogo_hitbox(is_enabled: bool) -> void:
	var shape_node: CollisionShape2D = pogo_hitbox.get_node("CollisionShape2D")
	shape_node.position = Vector2(0, 40)
	shape_node.set_deferred("disabled", not is_enabled)


func _initialize_and_setup_components() -> void:
	entity_data = PlayerStateData.new()
	assert(is_instance_valid(_services), "Player requires a ServiceLocator.")
	entity_data.config = _services.combat_config

	var hc: HealthComponent = get_component(HealthComponent)
	var sm: BaseStateMachine = get_component(BaseStateMachine)

	var shared_deps := {"data_resource": entity_data, "config": entity_data.config}

	var states = {
		Identifiers.PlayerStates.MOVE: state_move_script.new(self, sm, entity_data),
		Identifiers.PlayerStates.FALL: state_fall_script.new(self, sm, entity_data),
		Identifiers.PlayerStates.JUMP: state_jump_script.new(self, sm, entity_data),
		Identifiers.PlayerStates.DASH: state_dash_script.new(self, sm, entity_data),
		Identifiers.PlayerStates.WALL_SLIDE: state_wall_slide_script.new(self, sm, entity_data),
		Identifiers.PlayerStates.ATTACK: state_attack_script.new(self, sm, entity_data),
		Identifiers.PlayerStates.HURT: state_hurt_script.new(self, sm, entity_data),
		Identifiers.PlayerStates.HEAL: state_heal_script.new(self, sm, entity_data),
		Identifiers.PlayerStates.POGO: state_pogo_script.new(self, sm, entity_data),
	}

	var per_component_deps := {
		sm: {"states": states, "initial_state_key": Identifiers.PlayerStates.FALL},
		get_component(FXComponent): {"visual_node": visual_sprite, "hit_effect": HIT_FLASH_EFFECT},
		hc: {"hit_spark_effect": hit_spark_effect}
	}

	setup_components(shared_deps, per_component_deps)


func _connect_signals() -> void:
	melee_hitbox.body_entered.connect(_on_melee_hitbox_body_entered)
	pogo_hitbox.body_entered.connect(_on_pogo_hitbox_body_entered)
	melee_hitbox.area_entered.connect(_on_hitbox_area_entered)
	pogo_hitbox.area_entered.connect(_on_hitbox_area_entered)
	hurtbox.area_entered.connect(_on_hurtbox_area_entered)

	var hc: HealthComponent = get_component(HealthComponent)
	hc.health_changed.connect(_on_health_component_health_changed)
	hc.died.connect(_on_health_component_died)

	var cc: CombatComponent = get_component(CombatComponent)
	var rc: PlayerResourceComponent = get_component(PlayerResourceComponent)
	cc.damage_dealt.connect(rc.on_damage_dealt)
	cc.pogo_bounce_requested.connect(_on_pogo_bounce_requested)

	var sm: BaseStateMachine = get_component(BaseStateMachine)
	sm.melee_hitbox_toggled.connect(_enable_melee_hitbox)
	sm.pogo_hitbox_toggled.connect(_enable_pogo_hitbox)

	var ac: PlayerAbilityComponent = get_component(PlayerAbilityComponent)
	ac.state_change_requested.connect(_on_ability_state_change_requested)

	healing_timer.timeout.connect(_on_healing_timer_timeout)


func _update_timers(delta: float) -> void:
	if not is_instance_valid(entity_data):
		return

	entity_data.coyote_timer = max(0.0, entity_data.coyote_timer - delta)
	entity_data.wall_coyote_timer = max(0.0, entity_data.wall_coyote_timer - delta)
	entity_data.dash_cooldown_timer = max(0.0, entity_data.dash_cooldown_timer - delta)
	entity_data.dash_duration_timer = max(0.0, entity_data.dash_duration_timer - delta)
	entity_data.attack_duration_timer = max(0.0, entity_data.attack_duration_timer - delta)
	entity_data.attack_cooldown_timer = max(0.0, entity_data.attack_cooldown_timer - delta)
	entity_data.knockback_timer = max(0.0, entity_data.knockback_timer - delta)
	entity_data.pogo_fall_prevention_timer = max(
		0.0, entity_data.pogo_fall_prevention_timer - delta
	)
	var ic: InputComponent = get_component(InputComponent)
	if entity_data.is_charging and is_instance_valid(ic) and ic.buffer.get("attack_pressed"):
		entity_data.charge_timer += delta


# --- Signal Handlers ---


func _on_ability_state_change_requested(state_key: StringName, msg: Dictionary = {}) -> void:
	var sm: BaseStateMachine = get_component(BaseStateMachine)
	if is_instance_valid(sm):
		sm.change_state(state_key, msg)


func _on_melee_hitbox_body_entered(body: Node) -> void:
	get_component(CombatComponent).trigger_melee_attack(body)


func _on_pogo_hitbox_body_entered(body: Node) -> void:
	get_component(CombatComponent).trigger_pogo(body)


func _on_hitbox_area_entered(area: Area2D) -> void:
	if area.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE):
		if entity_data.is_pogo_attack:
			get_component(CombatComponent).trigger_pogo(area)
		else:
			_services.object_pool.return_instance.call_deferred(area)


func _on_hurtbox_area_entered(area: Area2D) -> void:
	var hc: HealthComponent = get_component(HealthComponent)
	if hc.is_invincible():
		return
	if area.is_in_group(Identifiers.Groups.ENEMY_PROJECTILE):
		var damage_info = DamageInfo.new()
		damage_info.amount = 1
		damage_info.source_node = area
		damage_info.impact_position = global_position
		damage_info.impact_normal = (global_position - area.global_position).normalized()
		var damage_result = hc.apply_damage(damage_info)

		if not is_instance_valid(entity_data):
			return

		if damage_result.was_damaged and entity_data.health > 0:
			self.velocity = damage_result.knockback_velocity
			get_component(BaseStateMachine).change_state(Identifiers.PlayerStates.HURT)
		_services.object_pool.return_instance.call_deferred(area)


func _on_healing_timer_timeout() -> void:
	var sm: BaseStateMachine = get_component(BaseStateMachine)
	if sm.current_state == sm.states[Identifiers.PlayerStates.HEAL]:
		entity_data.health += 1
		get_component(PlayerResourceComponent).consume_healing_charge()
		_on_health_component_health_changed(entity_data.health, entity_data.max_health)
		sm.change_state(Identifiers.PlayerStates.MOVE)


func _on_health_component_health_changed(current: int, max_val: int) -> void:
	var ev = PlayerHealthChangedEvent.new()
	ev.current_health = current
	ev.max_health = max_val
	_services.event_bus.emit(EventCatalog.PLAYER_HEALTH_CHANGED, ev)
	health_changed.emit(current, max_val)


func _on_health_component_died() -> void:
	_die()


func _on_pogo_bounce_requested() -> void:
	velocity.y = -entity_data.config.player_pogo_force
	position.y -= 1
	entity_data.can_dash = true
	entity_data.air_jumps_left = entity_data.config.player_max_air_jumps
	get_component(BaseStateMachine).change_state(Identifiers.PlayerStates.FALL)


func _cancel_heal() -> void:
	if healing_timer.is_stopped():
		return
	healing_timer.stop()


=====================================
FILE: ./src/entities/player/components/player_resource_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://a1b2c3d4e5f6"]

[ext_resource type="Script" path="res://src/entities/player/components/player_resource_component.gd" id="1_res"]

[node name="PlayerResourceComponent" type="Node"]
script = ExtResource("1_res")

=====================================
FILE: ./src/entities/player/components/player_ability_component.gd
=====================================
# src/entities/player/components/player_ability_component.gd
@tool
## Governs the activation logic for player abilities.
##
## Reads the input buffer and game state to determine if an action (like
## dashing or healing) can be performed, then emits a signal to request a state change.
class_name PlayerAbilityComponent
extends IComponent

# --- Signals ---
## Emitted when this component determines a state change should occur.
signal state_change_requested(state_key: StringName, msg: Dictionary)

# --- Constants ---
const JumpHelper = preload("res://src/entities/player/components/player_jump_helper.gd")

# --- Member Variables ---
var owner_node: Player
var p_data: PlayerStateData

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	# Run after the physics component.
	process_priority = 0


func _physics_process(_delta: float) -> void:
	if not is_instance_valid(owner_node):
		return

	var input_component: InputComponent = owner_node.get_component(InputComponent)
	if not is_instance_valid(input_component):
		return

	var current_state_key = owner_node.get_component(BaseStateMachine)._current_state_key

	if not current_state_key in Player.ACTION_ALLOWED_STATES:
		return

	# --- Action Checks (Prioritized) ---

	if input_component.buffer.get("jump_just_pressed"):
		var is_holding_down = input_component.buffer.get("down", false)

		# 1. Heal (Highest priority for this input combination)
		if (
			is_holding_down
			and p_data.healing_charges > 0
			and owner_node.is_on_floor()
			and is_zero_approx(owner_node.velocity.x)
		):
			state_change_requested.emit(Identifiers.PlayerStates.HEAL, {})
			return # Stop further processing of this input

		# 2. Platform Drop
		if is_holding_down:
			if JumpHelper.try_platform_drop(owner_node):
				# The helper calls change_state directly for this one, so we just return.
				return

		# 3. Standard Jump (includes wall, ground, coyote, and air jumps)
		if JumpHelper.try_jump(owner_node, p_data):
			# The helper calls change_state directly, so we return.
			return

	if input_component.buffer.get("attack_just_pressed") and p_data.attack_cooldown_timer <= 0:
		p_data.is_charging = true
		p_data.charge_timer = 0.0

	if input_component.buffer.get("attack_released"):
		if p_data.is_charging:
			if p_data.charge_timer >= p_data.config.player_charge_time:
				owner_node.get_component(CombatComponent).fire_shot()
			elif input_component.buffer.get("down"):
				state_change_requested.emit(Identifiers.PlayerStates.POGO, {})
			else:
				state_change_requested.emit(Identifiers.PlayerStates.ATTACK, {})
			p_data.is_charging = false

	if (
		input_component.buffer.get("dash_pressed")
		and p_data.can_dash
		and p_data.dash_cooldown_timer <= 0
	):
		state_change_requested.emit(Identifiers.PlayerStates.DASH, {})


# --- Public Methods ---


func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as Player
	self.p_data = p_dependencies.get("data_resource")


func teardown() -> void:
	set_physics_process(false)
	owner_node = null
	p_data = null


=====================================
FILE: ./src/entities/player/components/player_jump_helper.gd
=====================================
# src/entities/player/components/player_jump_helper.gd
## A stateless helper class that centralizes all jump-related logic for the Player.
## Its single responsibility is to determine if a jump can occur and what kind of
## jump it is, based on the player's current state.
class_name PlayerJumpHelper
extends RefCounted

# --- Public Methods ---


## Checks all possible jump conditions in a prioritized order and executes one if valid.
## Returns true if a jump was successfully initiated, false otherwise.
static func try_jump(owner: Player, p_data: PlayerStateData) -> bool:
	if not is_instance_valid(owner):
		return false

	var physics: PlayerPhysicsComponent = owner.get_component(PlayerPhysicsComponent)
	var sm: BaseStateMachine = owner.get_component(BaseStateMachine)

	if not is_instance_valid(physics) or not is_instance_valid(sm):
		return false

	# 1. Wall Jump (Highest Priority)
	if p_data.wall_coyote_timer > 0:
		physics.perform_wall_jump()
		sm.change_state(Identifiers.PlayerStates.JUMP)
		return true

	# 2. Ground Jump (includes coyote time)
	if owner.is_on_floor() or p_data.coyote_timer > 0:
		sm.change_state(Identifiers.PlayerStates.JUMP)
		return true

	# 3. Air Jump
	if p_data.air_jumps_left > 0:
		sm.change_state(Identifiers.PlayerStates.JUMP, {"is_air_jump": true})
		return true

	return false


## Checks if the player is attempting to drop through a one-way platform.
## Returns true if the drop was successful, false otherwise.
static func try_platform_drop(owner: Player) -> bool:
	if not is_instance_valid(owner) or not owner is CharacterBody2D:
		return false

	var floor_col = owner.get_last_slide_collision()
	if not floor_col:
		return false

	var floor_collider = floor_col.get_collider()
	if (
		is_instance_valid(floor_collider)
		and floor_collider.is_in_group(Identifiers.Groups.ONEWAY_PLATFORMS)
	):
		owner.position.y += 2 # Nudge the player down to clear the platform
		owner.get_component(BaseStateMachine).change_state(Identifiers.PlayerStates.FALL)
		return true

	return false

=====================================
FILE: ./src/entities/player/components/player_physics_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://o9p0q1r2s3t4"]

[ext_resource type="Script" path="res://src/entities/player/components/player_physics_component.gd" id="1_phys"]

[node name="PlayerPhysicsComponent" type="Node"]
script = ExtResource("1_phys")

=====================================
FILE: ./src/entities/player/components/player_physics_component.gd
=====================================
# src/entities/player/components/player_physics_component.gd
@tool
## Manages all direct physics interactions for the player character.
##
## Handles gravity, movement, collision detection, and applying velocity via
## move_and_slide(). It serves as the single point of contact with the
## Godot physics engine for the player.
class_name PlayerPhysicsComponent
extends IComponent

# --- Member Variables ---
var owner_node: Player
var p_data: PlayerStateData

# --- Godot Lifecycle Methods ---


func _ready() -> void:
	# Run before other components to ensure move_and_slide() is called
	# before any physics state checks like is_on_floor().
	process_priority = -50


func _physics_process(_delta: float) -> void:
	if not is_instance_valid(owner_node):
		return  # Guard against post-teardown calls

	owner_node.move_and_slide()
	_check_for_contact_damage()

	# GUARD: The owner may have been freed by the contact damage check.
	if not is_instance_valid(owner_node):
		return

	if owner_node.is_on_wall() and not owner_node.is_on_floor():
		p_data.wall_coyote_timer = p_data.config.player_wall_coyote_time
		p_data.last_wall_normal = owner_node.get_wall_normal()


# --- Public Methods ---


func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as Player
	self.p_data = p_dependencies.get("data_resource")


func teardown() -> void:
	set_physics_process(false)
	owner_node = null
	p_data = null


func apply_horizontal_movement() -> void:
	var input_component: InputComponent = owner_node.get_component(InputComponent)
	if not is_instance_valid(input_component):
		return
	var move_axis = input_component.buffer.get("move_axis", 0.0)
	owner_node.velocity.x = move_axis * p_data.config.player_speed
	if not is_zero_approx(move_axis):
		p_data.facing_direction = sign(move_axis)


func apply_gravity(delta: float, multiplier: float = 1.0) -> void:
	owner_node.velocity.y += p_data.config.gravity * multiplier * delta


## Checks if the conditions for performing a wall slide are met.
func can_wall_slide() -> bool:
	var ic: InputComponent = owner_node.get_component(InputComponent)
	if not is_instance_valid(ic):
		return false
	var move_axis = ic.buffer.get("move_axis", 0.0)
	return (
		p_data.wall_coyote_timer > 0
		and not owner_node.is_on_floor()
		and move_axis != 0
		and sign(move_axis) == -p_data.last_wall_normal.x
	)


## Applies the velocity and resets timers for a wall jump.
func perform_wall_jump() -> void:
	owner_node.velocity.y = -p_data.config.player_wall_jump_force_y
	owner_node.velocity.x = p_data.last_wall_normal.x * p_data.config.player_wall_jump_force_x
	p_data.coyote_timer = 0
	p_data.wall_coyote_timer = 0


# --- Private Methods ---


func _check_for_contact_damage() -> void:
	var health_component: HealthComponent = owner_node.get_component(HealthComponent)
	if not is_instance_valid(health_component) or health_component.is_invincible():
		return

	for i in range(owner_node.get_slide_collision_count()):
		var col = owner_node.get_slide_collision(i)
		if not col:
			continue

		var collider = col.get_collider()
		var is_damage_source = (
			is_instance_valid(collider)
			and (
				collider.is_in_group(Identifiers.Groups.ENEMY)
				or collider.is_in_group(Identifiers.Groups.HAZARD)
			)
		)

		if not is_damage_source:
			continue

		var damage_info = DamageInfo.new()
		damage_info.amount = 1
		damage_info.source_node = collider
		damage_info.impact_position = col.get_position()
		damage_info.impact_normal = col.get_normal()
		var damage_result = health_component.apply_damage(damage_info)

		if not is_instance_valid(owner_node):
			return

		if damage_result.was_damaged and p_data.health > 0:
			owner_node.velocity = damage_result.knockback_velocity
			owner_node.get_component(BaseStateMachine).change_state(Identifiers.PlayerStates.HURT)
		break

=====================================
FILE: ./src/entities/player/components/player_ability_component.tscn
=====================================
[gd_scene load_steps=2 format=3 uid="uid://u5v6w7x8y9z0"]

[ext_resource type="Script" path="res://src/entities/player/components/player_ability_component.gd" id="1_abil"]

[node name="PlayerAbilityComponent" type="Node"]
script = ExtResource("1_abil")

=====================================
FILE: ./src/entities/player/components/player_resource_component.gd
=====================================
# src/entities/player/components/player_resource_component.gd
@tool
## Manages the player's resource economy (Determination and Healing).
class_name PlayerResourceComponent
extends IComponent

# --- Member Variables ---
var owner_node: BaseEntity
var p_data: PlayerStateData
var _services: ServiceLocator  # Dependency

# --- Public Methods ---


func setup(p_owner: Node, p_dependencies: Dictionary = {}) -> void:
	self.owner_node = p_owner as BaseEntity
	self.p_data = p_dependencies.get("data_resource")
	self._services = p_dependencies.get("services")
	assert(
		is_instance_valid(_services),
		"PlayerResourceComponent requires a ServiceLocator dependency."
	)


func teardown() -> void:
	owner_node = null
	p_data = null
	_services = null


## Called when the player successfully deals damage to an enemy.
func on_damage_dealt() -> void:
	if p_data.healing_charges >= p_data.config.player_max_healing_charges:
		return # Do not increment determination if charges are already at max.

	p_data.determination_counter += 1
	if p_data.determination_counter >= p_data.config.player_determination_per_charge:
		p_data.determination_counter = 0
		p_data.healing_charges += 1
		_emit_healing_charges_changed_event()


## Consumes one healing charge.
func consume_healing_charge() -> void:
	if p_data.healing_charges > 0:
		p_data.healing_charges -= 1
		_emit_healing_charges_changed_event()


# --- Private Methods ---


func _emit_healing_charges_changed_event() -> void:
	var ev = PlayerHealingChargesChangedEvent.new()
	ev.current_charges = p_data.healing_charges
	_services.event_bus.emit(EventCatalog.PLAYER_HEALING_CHARGES_CHANGED, ev)


=====================================
FILE: ./src/entities/player/states/state_jump.gd
=====================================
# src/entities/player/states/state_jump.gd
## Handles the player's upward movement (jump).
extends BaseState

var _physics: PlayerPhysicsComponent
var _input: InputComponent


func enter(msg := {}) -> void:
	_physics = owner.get_component(PlayerPhysicsComponent)
	_input = owner.get_component(InputComponent)

	if msg.get("is_air_jump", false):
		state_data.air_jumps_left -= 1

	owner.velocity.y = -state_data.config.player_jump_force
	state_data.coyote_timer = 0


func process_physics(delta: float) -> void:
	_physics.apply_horizontal_movement()

	if _input.buffer.get("jump_just_pressed"):
		if state_data.air_jumps_left > 0:
			_perform_air_jump()

	if _input.buffer.get("jump_released") and owner.velocity.y < 0:
		owner.velocity.y *= state_data.config.player_jump_release_dampener

	_apply_gravity(delta)

	if owner.is_on_floor():
		state_machine.change_state(Identifiers.PlayerStates.MOVE)
		return

	if _physics.can_wall_slide():
		state_machine.change_state(Identifiers.PlayerStates.WALL_SLIDE)
		return


func _apply_gravity(delta: float) -> void:
	_physics.apply_gravity(delta)
	if owner.velocity.y > 0.0:
		state_machine.change_state(Identifiers.PlayerStates.FALL)


func _perform_air_jump() -> void:
	state_data.air_jumps_left -= 1
	owner.velocity.y = -state_data.config.player_jump_force


=====================================
FILE: ./src/entities/player/states/state_dash.gd
=====================================
# src/entities/player/states/state_dash.gd
extends BaseState

var _dash_direction: Vector2
var _invincibility_token: int
var _health: HealthComponent


func enter(_msg := {}):
	_health = owner.get_component(HealthComponent)

	state_data.can_dash = false
	state_data.dash_duration_timer = state_data.config.player_dash_duration
	state_data.dash_cooldown_timer = state_data.config.player_dash_cooldown

	_invincibility_token = _health.grant_invincibility(self)

	_dash_direction = _get_dash_direction()
	owner.velocity = _dash_direction * state_data.config.player_dash_speed


func exit():
	if is_instance_valid(owner) and is_instance_valid(_health):
		_health.release_invincibility(_invincibility_token)

	if _dash_direction.y != 0:
		owner.velocity.y = 0.0
	if _dash_direction.x != 0:
		owner.velocity.x = 0.0


func process_physics(_delta: float):
	if state_data.dash_duration_timer <= 0:
		state_machine.change_state(Identifiers.PlayerStates.FALL)


func _get_dash_direction():
	var ic: InputComponent = owner.get_component(InputComponent)
	if ic.buffer.get("up"):
		return Vector2.UP
	if ic.buffer.get("down"):
		return Vector2.DOWN
	return Vector2(state_data.facing_direction, 0)


=====================================
FILE: ./src/entities/player/states/state_heal.gd
=====================================
# src/entities/player/states/state_heal.gd
# Handles the player's healing state.
extends BaseState


func enter(_msg := {}):
	owner.velocity = Vector2.ZERO
	owner.healing_timer.start(state_data.config.player_heal_duration)


func exit():
	owner._cancel_heal()


func process_physics(_delta: float):
	if (
		not Input.is_action_pressed("ui_down")
		or not Input.is_action_pressed("ui_jump")
		or not is_zero_approx(owner.velocity.x)
		or not owner.is_on_floor()
	):
		state_machine.change_state(Identifiers.PlayerStates.MOVE)


=====================================
FILE: ./src/entities/player/states/state_wall_slide.gd
=====================================
# src/entities/player/states/state_wall_slide.gd
# Handles the player's wall sliding state.
extends BaseState

var _physics: PlayerPhysicsComponent
var _input: InputComponent


func enter(_msg := {}):
	_physics = owner.get_component(PlayerPhysicsComponent)
	_input = owner.get_component(InputComponent)
	state_data.can_dash = true
	state_data.air_jumps_left = state_data.config.player_max_air_jumps


func exit():
	if state_data.last_wall_normal != Vector2.ZERO:
		state_data.facing_direction = sign(state_data.last_wall_normal.x)


func process_physics(delta: float):
	var gravity = state_data.config.gravity
	var wall_slide_speed = state_data.config.player_wall_slide_speed
	owner.velocity.y = min(owner.velocity.y + gravity * delta, wall_slide_speed)

	state_data.facing_direction = sign(-state_data.last_wall_normal.x)

	if _input.buffer.get("jump_just_pressed"):
		_physics.perform_wall_jump()
		state_machine.change_state(Identifiers.PlayerStates.JUMP)
		return

	var move_axis = _input.buffer.get("move_axis", 0.0)
	if move_axis * -state_data.last_wall_normal.x < 0.8:
		state_machine.change_state(Identifiers.PlayerStates.FALL)
		return

	if state_data.wall_coyote_timer <= 0:
		state_machine.change_state(Identifiers.PlayerStates.FALL)
		return

	if owner.is_on_floor():
		state_machine.change_state(Identifiers.PlayerStates.MOVE)
		return


=====================================
FILE: ./src/entities/player/states/state_attack.gd
=====================================
# src/entities/player/states/state_attack.gd
## This state handles the player's melee attack.
class_name PlayerStateAttack
extends BaseState

var _input: InputComponent

# --- State Lifecycle ---


func enter(_msg := {}) -> void:
	_input = owner.get_component(InputComponent)
	state_data.hit_targets_this_swing.clear()
	state_data.attack_duration_timer = state_data.config.player_attack_duration
	state_data.attack_cooldown_timer = state_data.config.player_attack_cooldown
	var is_up_attack = _input.buffer.get("up", false)
	state_machine.melee_hitbox_toggled.emit(true, is_up_attack)


func exit() -> void:
	state_machine.melee_hitbox_toggled.emit(false, false)
	state_data.hit_targets_this_swing.clear()


func process_physics(delta: float) -> void:
	var friction = state_data.config.player_attack_friction
	owner.velocity = owner.velocity.move_toward(Vector2.ZERO, friction * delta)

	if state_data.attack_duration_timer <= 0:
		state_machine.change_state(Identifiers.PlayerStates.FALL)


=====================================
FILE: ./src/entities/player/states/state_pogo.gd
=====================================
# src/entities/player/states/state_pogo.gd
## Handles the player's downward pogo attack state.
class_name PlayerStatePogo
extends BaseState

var _physics: PlayerPhysicsComponent

# --- State Lifecycle ---


func enter(_msg := {}) -> void:
	_physics = owner.get_component(PlayerPhysicsComponent)
	state_data.is_pogo_attack = true
	state_data.attack_duration_timer = state_data.config.player_attack_duration
	state_machine.pogo_hitbox_toggled.emit(true)


func exit() -> void:
	state_machine.pogo_hitbox_toggled.emit(false)
	state_data.is_pogo_attack = false


func process_physics(delta: float) -> void:
	_physics.apply_gravity(delta)

	if owner.is_on_floor():
		state_machine.change_state(Identifiers.PlayerStates.MOVE)
		return

	if state_data.attack_duration_timer <= 0:
		state_machine.change_state(Identifiers.PlayerStates.FALL)


=====================================
FILE: ./src/entities/player/states/state_hurt.gd
=====================================
# src/entities/player/states/state_hurt.gd
## Handles the player's knockback and stun state after taking damage.
extends BaseState

var _physics: PlayerPhysicsComponent


func enter(_msg := {}) -> void:
	_physics = owner.get_component(PlayerPhysicsComponent)
	state_data.knockback_timer = state_data.config.player_knockback_duration
	state_data.is_charging = false
	owner._cancel_heal()


func process_physics(delta: float) -> void:
	_physics.apply_gravity(delta)
	owner.velocity.x = move_toward(owner.velocity.x, 0, 800 * delta)

	if state_data.knockback_timer <= 0:
		state_machine.change_state(Identifiers.PlayerStates.FALL)


=====================================
FILE: ./src/entities/player/states/state_fall.gd
=====================================
# src/entities/player/states/state_fall.gd
## Handles the player's falling state (downward vertical movement).
extends BaseState

const JumpHelper = preload("res://src/entities/player/components/player_jump_helper.gd")

var _physics: PlayerPhysicsComponent
var _input: InputComponent


func enter(_msg := {}) -> void:
	_physics = owner.get_component(PlayerPhysicsComponent)
	_input = owner.get_component(InputComponent)


func process_physics(delta: float) -> void:
	_physics.apply_horizontal_movement()
	_apply_gravity(delta)

	if owner.is_on_floor():
		state_machine.change_state(Identifiers.PlayerStates.MOVE)
		return

	if _physics.can_wall_slide():
		state_machine.change_state(Identifiers.PlayerStates.WALL_SLIDE)
		return

	if _input.buffer.get("jump_just_pressed"):
		JumpHelper.try_jump(owner, state_data)


func _apply_gravity(delta: float) -> void:
	var gravity_multiplier = 1.0
	if _input.buffer.get("down"):
		gravity_multiplier = state_data.config.player_fast_fall_gravity_multiplier
	_physics.apply_gravity(delta, gravity_multiplier)


=====================================
FILE: ./src/entities/player/states/state_move.gd
=====================================
# src/entities/player/states/state_move.gd
## Handles the player's grounded movement state.
extends BaseState

var _physics: PlayerPhysicsComponent


func enter(_msg := {}) -> void:
	_physics = owner.get_component(PlayerPhysicsComponent)
	state_data.air_jumps_left = state_data.config.player_max_air_jumps
	state_data.can_dash = true


func process_physics(delta: float) -> void:
	state_data.coyote_timer = state_data.config.player_coyote_time

	_physics.apply_gravity(delta)
	_physics.apply_horizontal_movement()

	if not owner.is_on_floor():
		state_machine.change_state(Identifiers.PlayerStates.FALL)
		return



=====================================
FILE: ./src/entities/player/data/player_state_data.gd
=====================================
# src/entities/player/data/player_state_data.gd
@tool
## A Resource that holds all shared runtime state data for the Player.
class_name PlayerStateData
extends Resource

# --- Configuration Reference ---
var config: CombatConfig

# --- Health & Combat ---
var max_health: int = 5
var max_healing_charges: int = 1
var health: int = 5:
	set(value):
		health = clamp(value, 0, max_health)
var healing_charges: int = 0:
	set(value):
		healing_charges = clamp(value, 0, max_healing_charges)
var determination_counter: int = 0
var hit_targets_this_swing: Dictionary = {}

# --- Physics & Movement ---
var air_jumps_left: int = 0
var facing_direction: int = 1
var last_wall_normal: Vector2 = Vector2.ZERO
var can_dash: bool = true
var pogo_fall_prevention_timer: float = 0.0

# --- Timers ---
var coyote_timer: float = 0.0
var wall_coyote_timer: float = 0.0
var dash_duration_timer: float = 0.0
var dash_cooldown_timer: float = 0.0
var attack_duration_timer: float = 0.0
var attack_cooldown_timer: float = 0.0
var knockback_timer: float = 0.0

# --- State Flags ---
var is_charging: bool = false
var charge_timer: float = 0.0
var is_pogo_attack: bool = false


=====================================
FILE: ./src/entities/player/data/upward_attack_shape.tres
=====================================
[gd_resource type="RectangleShape2D" load_steps=0 format=3 uid="uid://c0dt7jqwtnbr"]

[resource]
size = Vector2(40, 40)


=====================================
FILE: ./src/entities/player/data/forward_attack_shape.tres
=====================================
[gd_resource type="RectangleShape2D" load_steps=0 format=3 uid="uid://c1b2d3e4f5g6h"]

[resource]
size = Vector2(80, 40)


